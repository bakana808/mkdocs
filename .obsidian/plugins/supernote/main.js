/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// supernote-typescript/lib/format.js
var require_format = __commonJS({
  "supernote-typescript/lib/format.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RecognitionStatuses = void 0;
    var RecognitionStatuses;
    (function(RecognitionStatuses2) {
      RecognitionStatuses2["NONE"] = "0";
      RecognitionStatuses2["DONE"] = "1";
      RecognitionStatuses2["RUNNING"] = "2";
    })(RecognitionStatuses = exports2.RecognitionStatuses || (exports2.RecognitionStatuses = {}));
  }
});

// supernote-typescript/lib/parsing.js
var require_parsing = __commonJS({
  "supernote-typescript/lib/parsing.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SupernoteX = exports2.extractLayerInfo = exports2.extractNestedKeyValue = exports2.extractKeyValue = exports2.parseKeyValue = exports2.getContentAtAddress = void 0;
    var format_1 = require_format();
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    function readUintLE(data, offset, byteLength) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      checkOffset(offset, byteLength, data.length);
      let val = data[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength && (mul *= 256)) {
        val += data[offset + i] * mul;
      }
      return val;
    }
    function getContentAtAddress(buffer, address, byteLength) {
      if (address === 0)
        return null;
      const blockLength = readUintLE(buffer, address, byteLength);
      const content = buffer.subarray(address + byteLength, address + byteLength + blockLength);
      return content;
    }
    exports2.getContentAtAddress = getContentAtAddress;
    function parseKeyValue(buffer, address, byteLength) {
      const content = getContentAtAddress(buffer, address, byteLength);
      if (content === null)
        return {};
      const str = uint8ArrayToString(content);
      return extractKeyValue(str);
    }
    exports2.parseKeyValue = parseKeyValue;
    function extractKeyValue(content) {
      const pattern = /<([^:<>]+):([^:<>]+)>/gm;
      const pairs = [...content.matchAll(pattern)];
      const data = pairs.reduce((acc, [_, key, value]) => {
        if (key in acc) {
          let newValue = typeof acc[key] === "string" ? [acc[key], value] : [...acc[key], value];
          acc[key] = newValue;
        } else {
          acc[key] = value;
        }
        return acc;
      }, {});
      return data;
    }
    exports2.extractKeyValue = extractKeyValue;
    function extractNestedKeyValue(record, delimiter = "_", prefixes = []) {
      const data = {};
      Object.entries(record).forEach(([key, value]) => {
        let main;
        let sub;
        if (typeof value !== "string")
          return;
        const idx = key.indexOf(delimiter);
        if (idx > -1) {
          main = key.substring(0, idx);
          sub = key.substring(idx + 1);
        } else {
          for (const prefix of prefixes) {
            if (!key.startsWith(prefix))
              continue;
            main = prefix;
            sub = key.substring(main.length);
            break;
          }
        }
        if (!(main && sub))
          return;
        if (main in data)
          data[main][sub] = value;
        else
          data[main] = { [sub]: value };
      });
      return data;
    }
    exports2.extractNestedKeyValue = extractNestedKeyValue;
    function extractLayerInfo(content) {
      const layerPattern = /{(?<content>[^{}]+)}/gm;
      const dictPattern = /"(?<key>[^"\[{}\]]+)"#"?(?<value>[^"\[{}\],]+)/gm;
      const layerContents = Array.from(content.matchAll(layerPattern));
      const layerInfos = layerContents.map((match) => {
        var _a, _b;
        if (match.groups === void 0)
          throw new Error("Undefined layer content.");
        const layerDictContents = Array.from(match.groups.content.matchAll(dictPattern));
        const data = layerDictContents.reduce((acc, match2) => {
          if (match2.groups === void 0)
            throw new Error("Undefined key/value pair.");
          const { key, value } = match2.groups;
          acc[key] = value;
          return acc;
        }, {});
        const layerInfo = {
          layerId: parseInt((_a = data.layerId) !== null && _a !== void 0 ? _a : "0"),
          name: (_b = data.name) !== null && _b !== void 0 ? _b : "Main layer",
          isBackgroundLayer: data.isBackgroundLayer === "true",
          isAllowAdd: data.isAllowAdd === "true",
          isCurrentLayer: data.isCurrentLayer === "true",
          isVisible: data.isVisible === "true",
          isDeleted: data.isDeleted === "true",
          isAllowUp: data.isAllowUp === "true",
          isAllowDown: data.isAllowDown === "true"
        };
        return layerInfo;
      });
      return layerInfos;
    }
    exports2.extractLayerInfo = extractLayerInfo;
    function uint8ArrayToString(uint8Array, encoding = "utf8", start = 0, end) {
      end = end || uint8Array.length;
      const slicedArray = uint8Array.slice(start, end);
      const decoder = new TextDecoder(encoding);
      return decoder.decode(slicedArray);
    }
    var SupernoteX2 = class {
      constructor(buffer) {
        this.pageWidth = 1404;
        this.pageHeight = 1872;
        this.addressSize = 4;
        this.lengthFieldSize = 4;
        this.defaultLayers = ["MAINLAYER", "LAYER1", "LAYER2", "LAYER3", "BGLAYER"];
        this._parseBuffer(buffer);
      }
      /** Parse note contents from buffer. */
      _parseBuffer(buffer) {
        this._parseSignature(buffer);
        this._parseFooter(buffer);
        this._parseHeader(buffer);
        this._parsePages(buffer);
        this._parseCover(buffer);
        this._parseKeywords(buffer);
        this._parseTitles(buffer);
        return this;
      }
      /** Parse Supernote file signature from buffer. */
      _parseSignature(buffer) {
        const pattern = /^noteSN_FILE_VER_(\d{8})/;
        const content = uint8ArrayToString(buffer, "utf8", 0, 24);
        const match = content.match(pattern);
        if (!match)
          throw new Error("Cannot parse this file. Signature doesn't match.");
        this.signature = content;
        this.version = parseFloat(match[1]);
        return this.signature;
      }
      /** Parse the footer of a Supernote file's buffer contents. */
      _parseFooter(buffer) {
        const chunk = buffer.subarray(buffer.length - this.addressSize);
        const address = readUintLE(chunk, 0, this.addressSize);
        const data = parseKeyValue(buffer, address, this.lengthFieldSize);
        const nested = extractNestedKeyValue(data, "_", ["PAGE"]);
        this.footer = Object.assign({ FILE: { FEATURE: "24" }, COVER: { "0": "0" }, KEYWORD: {}, TITLE: {}, STYLE: {}, PAGE: {} }, nested);
        return this.footer;
      }
      /** Parse the header of a Supernote file's buffer contents.
       * Relies on the address as given in the file's footer. */
      _parseHeader(buffer) {
        var _a;
        const address = ((_a = this.footer.FILE) === null || _a === void 0 ? void 0 : _a.FEATURE) ? parseInt(this.footer.FILE.FEATURE) : 24;
        const data = parseKeyValue(buffer, address, this.lengthFieldSize);
        this.header = Object.assign({ MODULE_LABEL: "0", FILE_TYPE: "0", APPLY_EQUIPMENT: "0", FINAL_OPERATION_PAGE: "0", FINAL_OPERATION_LAYER: "0", ORIGINAL_STYLE: "0", ORIGINAL_STYLEMD5: "0", DEVICE_DPI: "0", SOFT_DPI: "0", FILE_PARSE_TYPE: "0", RATTA_ETMD: "0", APP_VERSION: "0", FILE_RECOGN_TYPE: "0" }, data);
        return this.header;
      }
      /** Parse pages of a Supernote file's buffer contents.
       * Relies on the address as given in the file's footer. */
      _parsePages(buffer) {
        const collator = new Intl.Collator([], { numeric: true });
        const pages = Array.from(Object.keys(this.footer.PAGE)).sort((a, b) => collator.compare(a, b)).map((idx) => {
          var _a, _b, _c, _d, _e, _f;
          const address = parseInt(this.footer.PAGE[idx]);
          const data = parseKeyValue(buffer, address, this.lengthFieldSize);
          return Object.assign(Object.assign({ PAGESTYLE: "0", PAGESTYLEMD5: "0", LAYERSWITCH: "0", TOTALPATH: "0", THUMBNAILTYPE: "0", RECOGNSTATUS: format_1.RecognitionStatuses.NONE, RECOGNTEXT: "0", RECOGNFILE: "0", RECOGNFILESTATUS: format_1.RecognitionStatuses.NONE }, data), { MAINLAYER: this._parseLayer(buffer, parseInt((_a = data.MAINLAYER) !== null && _a !== void 0 ? _a : "0")), LAYER1: this._parseLayer(buffer, parseInt((_b = data.LAYER1) !== null && _b !== void 0 ? _b : "0")), LAYER2: this._parseLayer(buffer, parseInt((_c = data.LAYER2) !== null && _c !== void 0 ? _c : "0")), LAYER3: this._parseLayer(buffer, parseInt((_d = data.LAYER3) !== null && _d !== void 0 ? _d : "0")), BGLAYER: this._parseLayer(buffer, parseInt((_e = data.BGLAYER) !== null && _e !== void 0 ? _e : "0")), LAYERINFO: extractLayerInfo(data["LAYERINFO"]), LAYERSEQ: data["LAYERSEQ"].split(","), text: this._parseText(buffer, data["RECOGNTEXT"]), totalPathBuffer: getContentAtAddress(buffer, parseInt((_f = data.TOTALPATH) !== null && _f !== void 0 ? _f : "0"), this.lengthFieldSize) });
        });
        this.pages = pages;
        return pages;
      }
      /** Parse text of a Supernote file's buffer contents.
       * Relies on the address as given in the file's footer. */
      _parseText(buffer, text) {
        if (text === "0" || text === void 0) {
          return;
        }
        const address = parseInt(text);
        const data = getContentAtAddress(buffer, address, this.lengthFieldSize);
        if (data === null) {
          return;
        }
        const recognJson = new TextDecoder("utf8").decode(data);
        const recogn = JSON.parse(atob(recognJson));
        const elements = recogn.elements || [];
        const labels = elements.filter((e) => e.type === "Text").map((e) => decodeURIComponent(escape(e.label)));
        return labels.join("\n");
      }
      /** Parse layer at a specific address in a Supernote file's buffer contents. */
      _parseLayer(buffer, address) {
        var _a;
        const data = parseKeyValue(buffer, address, this.lengthFieldSize);
        const bitmapBuffer = getContentAtAddress(buffer, parseInt((_a = data.LAYERBITMAP) !== null && _a !== void 0 ? _a : "0"), this.lengthFieldSize);
        return Object.assign(Object.assign({ LAYERTYPE: "NOTE", LAYERPROTOCOL: "RATTA_RLE", LAYERNAME: "MAINLAYER", LAYERPATH: "0", LAYERBITMAP: "0", LAYERVECTORGRAPH: "0", LAYERRECOGN: "0" }, data), { bitmapBuffer });
      }
      /** Parse cover from Supernote file's buffer contents. */
      _parseCover(buffer) {
        var _a;
        const address = parseInt((_a = this.footer.COVER["0"]) !== null && _a !== void 0 ? _a : this.footer.COVER["1"]);
        if (address && address > 0) {
          const bitmapBuffer = getContentAtAddress(buffer, address, this.lengthFieldSize);
          this.cover = { bitmapBuffer };
        }
        return this.cover;
      }
      /** Parse keywords from Supernote file's buffer contents. */
      _parseKeywords(buffer) {
        this.keywords = {};
        Object.entries(this.footer.KEYWORD).forEach(([key, value]) => {
          if (!(key in this.keywords))
            this.keywords[key] = [];
          if (typeof value === "string")
            this.keywords[key].push(this._parseKeyword(buffer, parseInt(value)));
          else
            value.forEach((address) => this.keywords[key].push(this._parseKeyword(buffer, parseInt(address))));
        });
        return this.keywords;
      }
      /** Parse a single keyword entry at a certain buffer address. */
      _parseKeyword(buffer, address) {
        var _a;
        const data = parseKeyValue(buffer, address, this.lengthFieldSize);
        const bitmapBuffer = getContentAtAddress(buffer, parseInt((_a = data.KEYWORDSITE) !== null && _a !== void 0 ? _a : "0"), this.lengthFieldSize);
        const keyword = {
          KEYWORDSEQNO: "0",
          KEYWORDPAGE: "1",
          KEYWORDRECT: ["0", "0", "0", "0"],
          KEYWORDRECTORI: ["0", "0", "0", "0"],
          KEYWORDSITE: "0",
          KEYWORDLEN: "0",
          KEYWORD: "",
          bitmapBuffer
        };
        return keyword;
      }
      /** Parse titles from Supernote file's buffer contents. */
      _parseTitles(buffer) {
        this.titles = {};
        Object.entries(this.footer.TITLE).forEach(([key, value]) => {
          if (!(key in this.titles))
            this.titles[key] = [];
          if (typeof value === "string")
            this.titles[key].push(this._parseTitle(buffer, parseInt(value)));
          else
            value.forEach((address) => this.titles[key].push(this._parseTitle(buffer, parseInt(address))));
        });
        return this.titles;
      }
      /** Parse a single title entry at a certain buffer address. */
      _parseTitle(buffer, address) {
        var _a;
        const data = parseKeyValue(buffer, address, this.lengthFieldSize);
        const bitmapBuffer = getContentAtAddress(buffer, parseInt((_a = data.TITLEBITMAP) !== null && _a !== void 0 ? _a : "0"), this.lengthFieldSize);
        const title = Object.assign(Object.assign({ TITLESEQNO: "0", TITLELEVEL: "1", TITLERECT: ["0", "0", "0", "0"], TITLERECTORI: ["0", "0", "0", "0"], TITLEBITMAP: "0", TITLEPROTOCOL: "RATTA_RLE", TITLESTYLE: "1000254" }, data), { bitmapBuffer });
        return title;
      }
    };
    exports2.SupernoteX = SupernoteX2;
  }
});

// node_modules/image-js/lib/image/core/bitMethods.js
var require_bitMethods = __commonJS({
  "node_modules/image-js/lib/image/core/bitMethods.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = setBitMethods;
    var bitMethods = {
      /**
       * Get the bit of a pixel using a pixel index.
       * This method can only be called on binary images.
       * @memberof Image
       * @instance
       * @param {number} pixel - The pixel index which corresponds to `x * image.width + y`
       * @return {number} 0: bit is unset, 1: bit is set
       */
      getBit(pixel) {
        return this.data[getSlot(pixel)] & 1 << getShift(pixel) ? 1 : 0;
      },
      /**
       * Set the bit of a pixel using a pixel index.
       * This method can only be called on binary images.
       * @memberof Image
       * @instance
       * @param {number} pixel - The pixel index which corresponds to `x * image.width + y`
       */
      setBit(pixel) {
        this.data[getSlot(pixel)] |= 1 << getShift(pixel);
      },
      /**
       * Clear the bit of a pixel using a pixel index.
       * This method can only be called on binary images.
       * @memberof Image
       * @instance
       * @param {number} pixel - The pixel index which corresponds to `x * image.width + y`
       */
      clearBit(pixel) {
        this.data[getSlot(pixel)] &= ~(1 << getShift(pixel));
      },
      /**
       * Toggle (invert) the bit of a pixel using a pixel index.
       * This method can only be called on binary images.
       * @memberof Image
       * @instance
       * @param {number} pixel - The pixel index which corresponds to `x * image.width + y`
       */
      toggleBit(pixel) {
        this.data[getSlot(pixel)] ^= 1 << getShift(pixel);
      },
      /**
       * Get the bit of a pixel using coordinates.
       * This method can only be called on binary images.
       * @memberof Image
       * @instance
       * @param {number} x - x coordinate (0 = left)
       * @param {number} y - y coordinate (0 = top)
       * @return {number} 0: bit is unset, 1: bit is set
       */
      getBitXY(x, y) {
        if (x >= this.width || y >= this.height)
          return 0;
        return this.getBit(y * this.width + x);
      },
      /**
       * Set the bit of a pixel using coordinates.
       * This method can only be called on binary images.
       * @memberof Image
       * @instance
       * @param {number} x - x coordinate (0 = left)
       * @param {number} y - y coordinate (0 = top)
       */
      setBitXY(x, y) {
        this.setBit(y * this.width + x);
      },
      /**
       * Clear the bit of a pixel using coordinates.
       * @memberof Image
       * @instance
       * @param {number} x - x coordinate (0 = left)
       * @param {number} y - y coordinate (0 = top)
       */
      clearBitXY(x, y) {
        this.clearBit(y * this.width + x);
      },
      /**
       * Toggle (invert) the bit of a pixel using coordinates.
       * @memberof Image
       * @instance
       * @param {number} x - x coordinate (0 = left)
       * @param {number} y - y coordinate (0 = top)
       */
      toggleBitXY(x, y) {
        this.toggleBit(y * this.width + x);
      }
    };
    function getSlot(pixel) {
      return pixel >> 3;
    }
    function getShift(pixel) {
      return 7 - (pixel & 7);
    }
    function setBitMethods(Image2) {
      for (const i in bitMethods) {
        Image2.prototype[i] = bitMethods[i];
      }
    }
  }
});

// node_modules/image-js/lib/image/core/checkProcessable.js
var require_checkProcessable = __commonJS({
  "node_modules/image-js/lib/image/core/checkProcessable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = checkProcessable;
    function checkProcessable(processName, options = {}) {
      let {
        bitDepth,
        alpha,
        colorModel,
        components,
        channels
      } = options;
      if (typeof processName !== "string" || processName.length === 0) {
        throw new TypeError("processName must be a string");
      }
      if (bitDepth) {
        if (!Array.isArray(bitDepth)) {
          bitDepth = [bitDepth];
        }
        if (!bitDepth.includes(this.bitDepth)) {
          throw new TypeError(`The process: ${processName} can only be applied if bit depth is in: ${bitDepth}`);
        }
      }
      if (alpha) {
        if (!Array.isArray(alpha)) {
          alpha = [alpha];
        }
        if (!alpha.includes(this.alpha)) {
          throw new TypeError(`The process: ${processName} can only be applied if alpha is in: ${alpha}`);
        }
      }
      if (colorModel) {
        if (!Array.isArray(colorModel)) {
          colorModel = [colorModel];
        }
        if (!colorModel.includes(this.colorModel)) {
          throw new TypeError(`The process: ${processName} can only be applied if color model is in: ${colorModel}`);
        }
      }
      if (components) {
        if (!Array.isArray(components)) {
          components = [components];
        }
        if (!components.includes(this.components)) {
          let errorMessage = `The process: ${processName} can only be applied if the number of components is in: ${components}`;
          if (components.length === 1 && components[0] === 1) {
            throw new TypeError(`${errorMessage}.\rYou should transform your image using "image.grey()" before applying the algorithm.`);
          } else {
            throw new TypeError(errorMessage);
          }
        }
      }
      if (channels) {
        if (!Array.isArray(channels)) {
          channels = [channels];
        }
        if (!channels.includes(this.channels)) {
          throw new TypeError(`The process: ${processName} can only be applied if the number of channels is in: ${channels}`);
        }
      }
    }
  }
});

// node_modules/blob-util/dist/blob-util.cjs.js
var require_blob_util_cjs = __commonJS({
  "node_modules/blob-util/dist/blob-util.cjs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function loadImage(src, crossOrigin) {
      return new Promise(function(resolve2, reject2) {
        var img = new Image();
        if (crossOrigin) {
          img.crossOrigin = crossOrigin;
        }
        img.onload = function() {
          resolve2(img);
        };
        img.onerror = reject2;
        img.src = src;
      });
    }
    function imgToCanvas(img) {
      var canvas = document.createElement("canvas");
      canvas.width = img.width;
      canvas.height = img.height;
      var context = canvas.getContext("2d");
      context.drawImage(img, 0, 0, img.width, img.height, 0, 0, img.width, img.height);
      return canvas;
    }
    function createBlob(parts, properties) {
      parts = parts || [];
      properties = properties || {};
      if (typeof properties === "string") {
        properties = { type: properties };
      }
      try {
        return new Blob(parts, properties);
      } catch (e) {
        if (e.name !== "TypeError") {
          throw e;
        }
        var Builder = typeof BlobBuilder !== "undefined" ? BlobBuilder : typeof MSBlobBuilder !== "undefined" ? MSBlobBuilder : typeof MozBlobBuilder !== "undefined" ? MozBlobBuilder : WebKitBlobBuilder;
        var builder = new Builder();
        for (var i = 0; i < parts.length; i += 1) {
          builder.append(parts[i]);
        }
        return builder.getBlob(properties.type);
      }
    }
    function createObjectURL(blob) {
      return (typeof URL !== "undefined" ? URL : webkitURL).createObjectURL(blob);
    }
    function revokeObjectURL(url) {
      return (typeof URL !== "undefined" ? URL : webkitURL).revokeObjectURL(url);
    }
    function blobToBinaryString(blob) {
      return new Promise(function(resolve2, reject2) {
        var reader = new FileReader();
        var hasBinaryString = typeof reader.readAsBinaryString === "function";
        reader.onloadend = function() {
          var result = reader.result || "";
          if (hasBinaryString) {
            return resolve2(result);
          }
          resolve2(arrayBufferToBinaryString(result));
        };
        reader.onerror = reject2;
        if (hasBinaryString) {
          reader.readAsBinaryString(blob);
        } else {
          reader.readAsArrayBuffer(blob);
        }
      });
    }
    function base64StringToBlob(base64, type) {
      var parts = [binaryStringToArrayBuffer(atob(base64))];
      return type ? createBlob(parts, { type }) : createBlob(parts);
    }
    function binaryStringToBlob(binary, type) {
      return base64StringToBlob(btoa(binary), type);
    }
    function blobToBase64String(blob) {
      return blobToBinaryString(blob).then(btoa);
    }
    function dataURLToBlob(dataURL) {
      var type = dataURL.match(/data:([^;]+)/)[1];
      var base64 = dataURL.replace(/^[^,]+,/, "");
      var buff = binaryStringToArrayBuffer(atob(base64));
      return createBlob([buff], { type });
    }
    function blobToDataURL(blob) {
      return blobToBase64String(blob).then(function(base64String) {
        return "data:" + blob.type + ";base64," + base64String;
      });
    }
    function imgSrcToDataURL(src, type, crossOrigin, quality) {
      type = type || "image/png";
      return loadImage(src, crossOrigin).then(imgToCanvas).then(function(canvas) {
        return canvas.toDataURL(type, quality);
      });
    }
    function canvasToBlob(canvas, type, quality) {
      if (typeof canvas.toBlob === "function") {
        return new Promise(function(resolve2) {
          canvas.toBlob(resolve2, type, quality);
        });
      }
      return Promise.resolve(dataURLToBlob(canvas.toDataURL(type, quality)));
    }
    function imgSrcToBlob(src, type, crossOrigin, quality) {
      type = type || "image/png";
      return loadImage(src, crossOrigin).then(imgToCanvas).then(function(canvas) {
        return canvasToBlob(canvas, type, quality);
      });
    }
    function arrayBufferToBlob(buffer, type) {
      return createBlob([buffer], type);
    }
    function blobToArrayBuffer(blob) {
      return new Promise(function(resolve2, reject2) {
        var reader = new FileReader();
        reader.onloadend = function() {
          var result = reader.result || new ArrayBuffer(0);
          resolve2(result);
        };
        reader.onerror = reject2;
        reader.readAsArrayBuffer(blob);
      });
    }
    function arrayBufferToBinaryString(buffer) {
      var binary = "";
      var bytes = new Uint8Array(buffer);
      var length = bytes.byteLength;
      var i = -1;
      while (++i < length) {
        binary += String.fromCharCode(bytes[i]);
      }
      return binary;
    }
    function binaryStringToArrayBuffer(binary) {
      var length = binary.length;
      var buf = new ArrayBuffer(length);
      var arr = new Uint8Array(buf);
      var i = -1;
      while (++i < length) {
        arr[i] = binary.charCodeAt(i);
      }
      return buf;
    }
    exports2.createBlob = createBlob;
    exports2.createObjectURL = createObjectURL;
    exports2.revokeObjectURL = revokeObjectURL;
    exports2.blobToBinaryString = blobToBinaryString;
    exports2.base64StringToBlob = base64StringToBlob;
    exports2.binaryStringToBlob = binaryStringToBlob;
    exports2.blobToBase64String = blobToBase64String;
    exports2.dataURLToBlob = dataURLToBlob;
    exports2.blobToDataURL = blobToDataURL;
    exports2.imgSrcToDataURL = imgSrcToDataURL;
    exports2.canvasToBlob = canvasToBlob;
    exports2.imgSrcToBlob = imgSrcToBlob;
    exports2.arrayBufferToBlob = arrayBufferToBlob;
    exports2.blobToArrayBuffer = blobToArrayBuffer;
    exports2.arrayBufferToBinaryString = arrayBufferToBinaryString;
    exports2.binaryStringToArrayBuffer = binaryStringToArrayBuffer;
  }
});

// node_modules/iobuffer/lib/text-encoding-polyfill.js
var require_text_encoding_polyfill = __commonJS({
  "node_modules/iobuffer/lib/text-encoding-polyfill.js"(exports2) {
    "use strict";
    (function(scope) {
      "use strict";
      if (scope["TextEncoder"] && scope["TextDecoder"]) {
        return false;
      }
      function FastTextEncoder(utfLabel = "utf-8") {
        if (utfLabel !== "utf-8") {
          throw new RangeError(`Failed to construct 'TextEncoder': The encoding label provided ('${utfLabel}') is invalid.`);
        }
      }
      Object.defineProperty(FastTextEncoder.prototype, "encoding", {
        value: "utf-8"
      });
      FastTextEncoder.prototype.encode = function(string, options = { stream: false }) {
        if (options.stream) {
          throw new Error(`Failed to encode: the 'stream' option is unsupported.`);
        }
        let pos = 0;
        const len = string.length;
        const out = [];
        let at = 0;
        let tlen = Math.max(32, len + (len >> 1) + 7);
        let target = new Uint8Array(tlen >> 3 << 3);
        while (pos < len) {
          let value = string.charCodeAt(pos++);
          if (value >= 55296 && value <= 56319) {
            if (pos < len) {
              const extra = string.charCodeAt(pos);
              if ((extra & 64512) === 56320) {
                ++pos;
                value = ((value & 1023) << 10) + (extra & 1023) + 65536;
              }
            }
            if (value >= 55296 && value <= 56319) {
              continue;
            }
          }
          if (at + 4 > target.length) {
            tlen += 8;
            tlen *= 1 + pos / string.length * 2;
            tlen = tlen >> 3 << 3;
            const update = new Uint8Array(tlen);
            update.set(target);
            target = update;
          }
          if ((value & 4294967168) === 0) {
            target[at++] = value;
            continue;
          } else if ((value & 4294965248) === 0) {
            target[at++] = value >> 6 & 31 | 192;
          } else if ((value & 4294901760) === 0) {
            target[at++] = value >> 12 & 15 | 224;
            target[at++] = value >> 6 & 63 | 128;
          } else if ((value & 4292870144) === 0) {
            target[at++] = value >> 18 & 7 | 240;
            target[at++] = value >> 12 & 63 | 128;
            target[at++] = value >> 6 & 63 | 128;
          } else {
            continue;
          }
          target[at++] = value & 63 | 128;
        }
        return target.slice(0, at);
      };
      function FastTextDecoder(utfLabel = "utf-8", options = { fatal: false }) {
        if (utfLabel !== "utf-8") {
          throw new RangeError(`Failed to construct 'TextDecoder': The encoding label provided ('${utfLabel}') is invalid.`);
        }
        if (options.fatal) {
          throw new Error(`Failed to construct 'TextDecoder': the 'fatal' option is unsupported.`);
        }
      }
      Object.defineProperty(FastTextDecoder.prototype, "encoding", {
        value: "utf-8"
      });
      Object.defineProperty(FastTextDecoder.prototype, "fatal", { value: false });
      Object.defineProperty(FastTextDecoder.prototype, "ignoreBOM", {
        value: false
      });
      FastTextDecoder.prototype.decode = function(buffer, options = { stream: false }) {
        if (options["stream"]) {
          throw new Error(`Failed to decode: the 'stream' option is unsupported.`);
        }
        const bytes = new Uint8Array(buffer);
        let pos = 0;
        const len = bytes.length;
        const out = [];
        while (pos < len) {
          const byte1 = bytes[pos++];
          if (byte1 === 0) {
            break;
          }
          if ((byte1 & 128) === 0) {
            out.push(byte1);
          } else if ((byte1 & 224) === 192) {
            const byte2 = bytes[pos++] & 63;
            out.push((byte1 & 31) << 6 | byte2);
          } else if ((byte1 & 240) === 224) {
            const byte2 = bytes[pos++] & 63;
            const byte3 = bytes[pos++] & 63;
            out.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
          } else if ((byte1 & 248) === 240) {
            const byte2 = bytes[pos++] & 63;
            const byte3 = bytes[pos++] & 63;
            const byte4 = bytes[pos++] & 63;
            let codepoint = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
            if (codepoint > 65535) {
              codepoint -= 65536;
              out.push(codepoint >>> 10 & 1023 | 55296);
              codepoint = 56320 | codepoint & 1023;
            }
            out.push(codepoint);
          } else {
          }
        }
        return String.fromCharCode.apply(null, out);
      };
      scope["TextEncoder"] = FastTextEncoder;
      scope["TextDecoder"] = FastTextDecoder;
    })(typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : exports2);
  }
});

// node_modules/iobuffer/lib/text.browser.js
var require_text_browser = __commonJS({
  "node_modules/iobuffer/lib/text.browser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encode = exports2.decode = void 0;
    require_text_encoding_polyfill();
    function decode(bytes, encoding = "utf8") {
      const decoder = new TextDecoder(encoding);
      return decoder.decode(bytes);
    }
    exports2.decode = decode;
    var encoder = new TextEncoder();
    function encode(str) {
      return encoder.encode(str);
    }
    exports2.encode = encode;
  }
});

// node_modules/iobuffer/lib/IOBuffer.js
var require_IOBuffer = __commonJS({
  "node_modules/iobuffer/lib/IOBuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IOBuffer = void 0;
    var text_1 = require_text_browser();
    var defaultByteLength = 1024 * 8;
    var hostBigEndian = (() => {
      const array = new Uint8Array(4);
      const view = new Uint32Array(array.buffer);
      return !((view[0] = 1) & array[0]);
    })();
    var typedArrays = {
      int8: globalThis.Int8Array,
      uint8: globalThis.Uint8Array,
      int16: globalThis.Int16Array,
      uint16: globalThis.Uint16Array,
      int32: globalThis.Int32Array,
      uint32: globalThis.Uint32Array,
      uint64: globalThis.BigUint64Array,
      int64: globalThis.BigInt64Array,
      float32: globalThis.Float32Array,
      float64: globalThis.Float64Array
    };
    var IOBuffer = class {
      /**
       * @param data - The data to construct the IOBuffer with.
       * If data is a number, it will be the new buffer's length<br>
       * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>
       * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,
       * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.
       * @param options
       */
      constructor(data = defaultByteLength, options = {}) {
        let dataIsGiven = false;
        if (typeof data === "number") {
          data = new ArrayBuffer(data);
        } else {
          dataIsGiven = true;
          this.lastWrittenByte = data.byteLength;
        }
        const offset = options.offset ? options.offset >>> 0 : 0;
        const byteLength = data.byteLength - offset;
        let dvOffset = offset;
        if (ArrayBuffer.isView(data) || data instanceof IOBuffer) {
          if (data.byteLength !== data.buffer.byteLength) {
            dvOffset = data.byteOffset + offset;
          }
          data = data.buffer;
        }
        if (dataIsGiven) {
          this.lastWrittenByte = byteLength;
        } else {
          this.lastWrittenByte = 0;
        }
        this.buffer = data;
        this.length = byteLength;
        this.byteLength = byteLength;
        this.byteOffset = dvOffset;
        this.offset = 0;
        this.littleEndian = true;
        this._data = new DataView(this.buffer, dvOffset, byteLength);
        this._mark = 0;
        this._marks = [];
      }
      /**
       * Checks if the memory allocated to the buffer is sufficient to store more
       * bytes after the offset.
       * @param byteLength - The needed memory in bytes.
       * @returns `true` if there is sufficient space and `false` otherwise.
       */
      available(byteLength = 1) {
        return this.offset + byteLength <= this.length;
      }
      /**
       * Check if little-endian mode is used for reading and writing multi-byte
       * values.
       * @returns `true` if little-endian mode is used, `false` otherwise.
       */
      isLittleEndian() {
        return this.littleEndian;
      }
      /**
       * Set little-endian mode for reading and writing multi-byte values.
       */
      setLittleEndian() {
        this.littleEndian = true;
        return this;
      }
      /**
       * Check if big-endian mode is used for reading and writing multi-byte values.
       * @returns `true` if big-endian mode is used, `false` otherwise.
       */
      isBigEndian() {
        return !this.littleEndian;
      }
      /**
       * Switches to big-endian mode for reading and writing multi-byte values.
       */
      setBigEndian() {
        this.littleEndian = false;
        return this;
      }
      /**
       * Move the pointer n bytes forward.
       * @param n - Number of bytes to skip.
       */
      skip(n = 1) {
        this.offset += n;
        return this;
      }
      /**
       * Move the pointer n bytes backward.
       * @param n - Number of bytes to move back.
       */
      back(n = 1) {
        this.offset -= n;
        return this;
      }
      /**
       * Move the pointer to the given offset.
       * @param offset
       */
      seek(offset) {
        this.offset = offset;
        return this;
      }
      /**
       * Store the current pointer offset.
       * @see {@link IOBuffer#reset}
       */
      mark() {
        this._mark = this.offset;
        return this;
      }
      /**
       * Move the pointer back to the last pointer offset set by mark.
       * @see {@link IOBuffer#mark}
       */
      reset() {
        this.offset = this._mark;
        return this;
      }
      /**
       * Push the current pointer offset to the mark stack.
       * @see {@link IOBuffer#popMark}
       */
      pushMark() {
        this._marks.push(this.offset);
        return this;
      }
      /**
       * Pop the last pointer offset from the mark stack, and set the current
       * pointer offset to the popped value.
       * @see {@link IOBuffer#pushMark}
       */
      popMark() {
        const offset = this._marks.pop();
        if (offset === void 0) {
          throw new Error("Mark stack empty");
        }
        this.seek(offset);
        return this;
      }
      /**
       * Move the pointer offset back to 0.
       */
      rewind() {
        this.offset = 0;
        return this;
      }
      /**
       * Make sure the buffer has sufficient memory to write a given byteLength at
       * the current pointer offset.
       * If the buffer's memory is insufficient, this method will create a new
       * buffer (a copy) with a length that is twice (byteLength + current offset).
       * @param byteLength
       */
      ensureAvailable(byteLength = 1) {
        if (!this.available(byteLength)) {
          const lengthNeeded = this.offset + byteLength;
          const newLength = lengthNeeded * 2;
          const newArray = new Uint8Array(newLength);
          newArray.set(new Uint8Array(this.buffer));
          this.buffer = newArray.buffer;
          this.length = this.byteLength = newLength;
          this._data = new DataView(this.buffer);
        }
        return this;
      }
      /**
       * Read a byte and return false if the byte's value is 0, or true otherwise.
       * Moves pointer forward by one byte.
       */
      readBoolean() {
        return this.readUint8() !== 0;
      }
      /**
       * Read a signed 8-bit integer and move pointer forward by 1 byte.
       */
      readInt8() {
        return this._data.getInt8(this.offset++);
      }
      /**
       * Read an unsigned 8-bit integer and move pointer forward by 1 byte.
       */
      readUint8() {
        return this._data.getUint8(this.offset++);
      }
      /**
       * Alias for {@link IOBuffer#readUint8}.
       */
      readByte() {
        return this.readUint8();
      }
      /**
       * Read `n` bytes and move pointer forward by `n` bytes.
       */
      readBytes(n = 1) {
        return this.readArray(n, "uint8");
      }
      /**
       * Creates an array of corresponding to the type `type` and size `size`.
       * For example type `uint8` will create a `Uint8Array`.
       * @param size - size of the resulting array
       * @param type - number type of elements to read
       */
      readArray(size, type) {
        const bytes = typedArrays[type].BYTES_PER_ELEMENT * size;
        const offset = this.byteOffset + this.offset;
        const slice = this.buffer.slice(offset, offset + bytes);
        if (this.littleEndian === hostBigEndian && type !== "uint8" && type !== "int8") {
          const slice2 = new Uint8Array(this.buffer.slice(offset, offset + bytes));
          slice2.reverse();
          const returnArray2 = new typedArrays[type](slice2.buffer);
          this.offset += bytes;
          returnArray2.reverse();
          return returnArray2;
        }
        const returnArray = new typedArrays[type](slice);
        this.offset += bytes;
        return returnArray;
      }
      /**
       * Read a 16-bit signed integer and move pointer forward by 2 bytes.
       */
      readInt16() {
        const value = this._data.getInt16(this.offset, this.littleEndian);
        this.offset += 2;
        return value;
      }
      /**
       * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.
       */
      readUint16() {
        const value = this._data.getUint16(this.offset, this.littleEndian);
        this.offset += 2;
        return value;
      }
      /**
       * Read a 32-bit signed integer and move pointer forward by 4 bytes.
       */
      readInt32() {
        const value = this._data.getInt32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      }
      /**
       * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.
       */
      readUint32() {
        const value = this._data.getUint32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      }
      /**
       * Read a 32-bit floating number and move pointer forward by 4 bytes.
       */
      readFloat32() {
        const value = this._data.getFloat32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      }
      /**
       * Read a 64-bit floating number and move pointer forward by 8 bytes.
       */
      readFloat64() {
        const value = this._data.getFloat64(this.offset, this.littleEndian);
        this.offset += 8;
        return value;
      }
      /**
       * Read a 64-bit signed integer number and move pointer forward by 8 bytes.
       */
      readBigInt64() {
        const value = this._data.getBigInt64(this.offset, this.littleEndian);
        this.offset += 8;
        return value;
      }
      /**
       * Read a 64-bit unsigned integer number and move pointer forward by 8 bytes.
       */
      readBigUint64() {
        const value = this._data.getBigUint64(this.offset, this.littleEndian);
        this.offset += 8;
        return value;
      }
      /**
       * Read a 1-byte ASCII character and move pointer forward by 1 byte.
       */
      readChar() {
        return String.fromCharCode(this.readInt8());
      }
      /**
       * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.
       */
      readChars(n = 1) {
        let result = "";
        for (let i = 0; i < n; i++) {
          result += this.readChar();
        }
        return result;
      }
      /**
       * Read the next `n` bytes, return a UTF-8 decoded string and move pointer
       * forward by `n` bytes.
       */
      readUtf8(n = 1) {
        return (0, text_1.decode)(this.readBytes(n));
      }
      /**
       * Read the next `n` bytes, return a string decoded with `encoding` and move pointer
       * forward by `n` bytes.
       * If no encoding is passed, the function is equivalent to @see {@link IOBuffer#readUtf8}
       */
      decodeText(n = 1, encoding = "utf-8") {
        return (0, text_1.decode)(this.readBytes(n), encoding);
      }
      /**
       * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer
       * forward by 1 byte.
       */
      writeBoolean(value) {
        this.writeUint8(value ? 255 : 0);
        return this;
      }
      /**
       * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.
       */
      writeInt8(value) {
        this.ensureAvailable(1);
        this._data.setInt8(this.offset++, value);
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as an 8-bit unsigned integer and move pointer forward by 1
       * byte.
       */
      writeUint8(value) {
        this.ensureAvailable(1);
        this._data.setUint8(this.offset++, value);
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * An alias for {@link IOBuffer#writeUint8}.
       */
      writeByte(value) {
        return this.writeUint8(value);
      }
      /**
       * Write all elements of `bytes` as uint8 values and move pointer forward by
       * `bytes.length` bytes.
       */
      writeBytes(bytes) {
        this.ensureAvailable(bytes.length);
        for (let i = 0; i < bytes.length; i++) {
          this._data.setUint8(this.offset++, bytes[i]);
        }
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 16-bit signed integer and move pointer forward by 2
       * bytes.
       */
      writeInt16(value) {
        this.ensureAvailable(2);
        this._data.setInt16(this.offset, value, this.littleEndian);
        this.offset += 2;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 16-bit unsigned integer and move pointer forward by 2
       * bytes.
       */
      writeUint16(value) {
        this.ensureAvailable(2);
        this._data.setUint16(this.offset, value, this.littleEndian);
        this.offset += 2;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 32-bit signed integer and move pointer forward by 4
       * bytes.
       */
      writeInt32(value) {
        this.ensureAvailable(4);
        this._data.setInt32(this.offset, value, this.littleEndian);
        this.offset += 4;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 32-bit unsigned integer and move pointer forward by 4
       * bytes.
       */
      writeUint32(value) {
        this.ensureAvailable(4);
        this._data.setUint32(this.offset, value, this.littleEndian);
        this.offset += 4;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 32-bit floating number and move pointer forward by 4
       * bytes.
       */
      writeFloat32(value) {
        this.ensureAvailable(4);
        this._data.setFloat32(this.offset, value, this.littleEndian);
        this.offset += 4;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 64-bit floating number and move pointer forward by 8
       * bytes.
       */
      writeFloat64(value) {
        this.ensureAvailable(8);
        this._data.setFloat64(this.offset, value, this.littleEndian);
        this.offset += 8;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 64-bit signed bigint and move pointer forward by 8
       * bytes.
       */
      writeBigInt64(value) {
        this.ensureAvailable(8);
        this._data.setBigInt64(this.offset, value, this.littleEndian);
        this.offset += 8;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 64-bit unsigned bigint and move pointer forward by 8
       * bytes.
       */
      writeBigUint64(value) {
        this.ensureAvailable(8);
        this._data.setBigUint64(this.offset, value, this.littleEndian);
        this.offset += 8;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write the charCode of `str`'s first character as an 8-bit unsigned integer
       * and move pointer forward by 1 byte.
       */
      writeChar(str) {
        return this.writeUint8(str.charCodeAt(0));
      }
      /**
       * Write the charCodes of all `str`'s characters as 8-bit unsigned integers
       * and move pointer forward by `str.length` bytes.
       */
      writeChars(str) {
        for (let i = 0; i < str.length; i++) {
          this.writeUint8(str.charCodeAt(i));
        }
        return this;
      }
      /**
       * UTF-8 encode and write `str` to the current pointer offset and move pointer
       * forward according to the encoded length.
       */
      writeUtf8(str) {
        return this.writeBytes((0, text_1.encode)(str));
      }
      /**
       * Export a Uint8Array view of the internal buffer.
       * The view starts at the byte offset and its length
       * is calculated to stop at the last written byte or the original length.
       */
      toArray() {
        return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);
      }
      /**
       * Update the last written byte offset
       * @private
       */
      _updateLastWrittenByte() {
        if (this.offset > this.lastWrittenByte) {
          this.lastWrittenByte = this.offset;
        }
      }
    };
    exports2.IOBuffer = IOBuffer;
  }
});

// node_modules/fast-bmp/src/constants.js
var require_constants = __commonJS({
  "node_modules/fast-bmp/src/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      BITMAPV5HEADER: {
        LogicalColorSpace: {
          // https://msdn.microsoft.com/en-us/library/cc250396.aspx
          LCS_CALIBRATED_RGB: 0,
          LCS_sRGB: 1934772034,
          // eslint-disable-line camelcase
          LCS_WINDOWS_COLOR_SPACE: 1466527264
        },
        Compression: {
          // https://msdn.microsoft.com/en-us/library/cc250415.aspx
          BI_RGB: 0,
          // No compression
          BI_RLE8: 1,
          BI_RLE4: 2,
          BI_BITFIELDS: 3,
          BI_JPEG: 4,
          BI_PNG: 5,
          BI_CMYK: 11,
          BI_CMYKRLE8: 12,
          BI_CMYKRLE4: 13
        },
        GamutMappingIntent: {
          // https://msdn.microsoft.com/en-us/library/cc250392.aspx
          LCS_GM_ABS_COLORIMETRIC: 8,
          LCS_GM_BUSINESS: 1,
          LCS_GM_GRAPHICS: 2,
          LCS_GM_IMAGES: 4
        }
      }
    };
  }
});

// node_modules/fast-bmp/src/BMPEncoder.js
var require_BMPEncoder = __commonJS({
  "node_modules/fast-bmp/src/BMPEncoder.js"(exports2, module2) {
    "use strict";
    var { IOBuffer } = require_IOBuffer();
    var constants = require_constants();
    var tableLeft = [];
    for (let i = 0; i <= 8; i++) {
      tableLeft.push(255 << i);
    }
    var BMPEncoder = class extends IOBuffer {
      constructor(data) {
        if (data.bitDepth !== 1) {
          throw new Error("Only bitDepth of 1 is supported");
        }
        if (!data.height || !data.width) {
          throw new Error("ImageData width and height are required");
        }
        super(data.data);
        this.width = data.width;
        this.height = data.height;
        this.bitDepth = data.bitDepth;
        this.channels = data.channels;
        this.components = data.components;
      }
      encode() {
        this.encoded = new IOBuffer();
        this.encoded.skip(14);
        this.writeBitmapV5Header();
        this.writeColorTable();
        const offset = this.encoded.offset;
        this.writePixelArray();
        this.encoded.rewind();
        this.writeBitmapFileHeader(offset);
        return this.encoded.toArray();
      }
      writePixelArray() {
        let io = this.encoded;
        const rowSize = Math.floor((this.bitDepth * this.width + 31) / 32) * 4;
        const dataRowSize = Math.ceil(this.bitDepth * this.width / 8);
        const skipSize = rowSize - dataRowSize;
        const bitOverflow = this.bitDepth * this.width % 8;
        const bitSkip = bitOverflow === 0 ? 0 : 8 - bitOverflow;
        const totalBytes = rowSize * this.height;
        let byteA, byteB;
        let offset = 0;
        let relOffset = 0;
        let iOffset = 8;
        io.mark();
        byteB = this.readUint8();
        for (let i = this.height - 1; i >= 0; i--) {
          const lastRow = i === 0;
          io.reset();
          io.skip(i * rowSize);
          for (let j = 0; j < dataRowSize; j++) {
            const lastCol = j === dataRowSize - 1;
            if (relOffset <= bitSkip && lastCol) {
              io.writeByte(byteB << relOffset);
              if ((bitSkip === 0 || bitSkip === relOffset) && !lastRow) {
                byteA = byteB;
                byteB = this.readByte();
              }
            } else if (relOffset === 0) {
              byteA = byteB;
              byteB = this.readUint8();
              io.writeByte(byteA);
            } else {
              byteA = byteB;
              byteB = this.readUint8();
              io.writeByte(
                byteA << relOffset & tableLeft[relOffset] | byteB >> iOffset
              );
            }
            if (lastCol) {
              offset += bitOverflow || 0;
              io.skip(skipSize);
              relOffset = offset % 8;
              iOffset = 8 - relOffset;
            }
          }
        }
        if (rowSize > dataRowSize) {
          io.reset();
          io.skip(totalBytes - 1);
          io.writeUint8(0);
        }
      }
      writeColorTable() {
        this.encoded.writeUint32(0).writeUint32(16777215);
      }
      writeBitmapFileHeader(imageOffset) {
        this.encoded.writeChars("BM").writeInt32(this.encoded.lastWrittenByte).writeUint16(0).writeUint16(0).writeUint32(imageOffset);
      }
      writeBitmapV5Header() {
        const rowSize = Math.floor((this.bitDepth * this.width + 31) / 32) * 4;
        const totalBytes = rowSize * this.height;
        this.encoded.writeUint32(124).writeInt32(this.width).writeInt32(this.height).writeUint16(1).writeUint16(this.bitDepth).writeUint32(constants.BITMAPV5HEADER.Compression.BI_RGB).writeUint32(totalBytes).writeInt32(0).writeInt32(0).writeUint32(Math.pow(2, this.bitDepth)).writeUint32(Math.pow(2, this.bitDepth)).writeUint32(4278190080).writeUint32(16711680).writeUint32(65280).writeUint32(255).writeUint32(constants.BITMAPV5HEADER.LogicalColorSpace.LCS_sRGB).skip(36).skip(12).writeUint32(constants.BITMAPV5HEADER.GamutMappingIntent.LCS_GM_IMAGES).skip(12);
      }
    };
    module2.exports = BMPEncoder;
  }
});

// node_modules/fast-bmp/src/index.js
var require_src = __commonJS({
  "node_modules/fast-bmp/src/index.js"(exports2) {
    "use strict";
    var Encoder = require_BMPEncoder();
    exports2.encode = function encode(data) {
      const encoder = new Encoder(data);
      return encoder.encode();
    };
  }
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "node_modules/pako/lib/zlib/trees.js"(exports2, module2) {
    "use strict";
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      let len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
    );
    var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    var d_code = (dist) => {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    };
    var put_short = (s, w) => {
      s.pending_buf[s.pending++] = w & 255;
      s.pending_buf[s.pending++] = w >>> 8 & 255;
    };
    var send_bits = (s, value, length) => {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & 65535;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 65535;
        s.bi_valid += length;
      }
    };
    var send_code = (s, c, tree) => {
      send_bits(
        s,
        tree[c * 2],
        tree[c * 2 + 1]
        /*.Len*/
      );
    };
    var bi_reverse = (code, len) => {
      let res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    };
    var bi_flush = (s) => {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 255;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    };
    var gen_bitlen = (s, desc) => {
      const tree = desc.dyn_tree;
      const max_code = desc.max_code;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const extra = desc.stat_desc.extra_bits;
      const base = desc.stat_desc.extra_base;
      const max_length = desc.stat_desc.max_length;
      let h;
      let n, m;
      let bits;
      let xbits;
      let f;
      let overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    };
    var gen_codes = (tree, max_code, bl_count) => {
      const next_code = new Array(MAX_BITS + 1);
      let code = 0;
      let bits;
      let n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        code = code + bl_count[bits - 1] << 1;
        next_code[bits] = code;
      }
      for (n = 0; n <= max_code; n++) {
        let len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    };
    var tr_static_init = () => {
      let n;
      let bits;
      let length;
      let code;
      let dist;
      const bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    };
    var init_block = (s) => {
      let n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.sym_next = s.matches = 0;
    };
    var bi_windup = (s) => {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    };
    var smaller = (tree, n, m, depth) => {
      const _n2 = n * 2;
      const _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    };
    var pqdownheap = (s, tree, k) => {
      const v = s.heap[k];
      let j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    };
    var compress_block = (s, ltree, dtree) => {
      let dist;
      let lc;
      let sx = 0;
      let code;
      let extra;
      if (s.sym_next !== 0) {
        do {
          dist = s.pending_buf[s.sym_buf + sx++] & 255;
          dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
          lc = s.pending_buf[s.sym_buf + sx++];
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (sx < s.sym_next);
      }
      send_code(s, END_BLOCK, ltree);
    };
    var build_tree = (s, desc) => {
      const tree = desc.dyn_tree;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const elems = desc.stat_desc.elems;
      let n, m;
      let max_code = -1;
      let node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[
          1
          /*SMALLEST*/
        ] = s.heap[s.heap_len--];
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
        m = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    };
    var scan_tree = (s, tree, max_code) => {
      let n;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    var send_tree = (s, tree, max_code) => {
      let n;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    var build_bl_tree = (s) => {
      let max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    };
    var send_all_trees = (s, lcodes, dcodes, blcodes) => {
      let rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    };
    var detect_data_type = (s) => {
      let block_mask = 4093624447;
      let n;
      for (n = 0; n <= 31; n++, block_mask >>>= 1) {
        if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    };
    var static_init_done = false;
    var _tr_init = (s) => {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    };
    var _tr_stored_block = (s, buf, stored_len, last) => {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      bi_windup(s);
      put_short(s, stored_len);
      put_short(s, ~stored_len);
      if (stored_len) {
        s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
      }
      s.pending += stored_len;
    };
    var _tr_align = (s) => {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    };
    var _tr_flush_block = (s, buf, stored_len, last) => {
      let opt_lenb, static_lenb;
      let max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    };
    var _tr_tally = (s, dist, lc) => {
      s.pending_buf[s.sym_buf + s.sym_next++] = dist;
      s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
      s.pending_buf[s.sym_buf + s.sym_next++] = lc;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.sym_next === s.sym_end;
    };
    module2.exports._tr_init = _tr_init;
    module2.exports._tr_stored_block = _tr_stored_block;
    module2.exports._tr_flush_block = _tr_flush_block;
    module2.exports._tr_tally = _tr_tally;
    module2.exports._tr_align = _tr_align;
  }
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "node_modules/pako/lib/zlib/adler32.js"(exports2, module2) {
    "use strict";
    var adler32 = (adler, buf, len, pos) => {
      let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    };
    module2.exports = adler32;
  }
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "node_modules/pako/lib/zlib/crc32.js"(exports2, module2) {
    "use strict";
    var makeTable = () => {
      let c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    };
    var crcTable = new Uint32Array(makeTable());
    var crc32 = (crc, buf, len, pos) => {
      const t = crcTable;
      const end = pos + len;
      crc ^= -1;
      for (let i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    };
    module2.exports = crc32;
  }
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "node_modules/pako/lib/zlib/messages.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// node_modules/pako/lib/zlib/constants.js
var require_constants2 = __commonJS({
  "node_modules/pako/lib/zlib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "node_modules/pako/lib/zlib/deflate.js"(exports2, module2) {
    "use strict";
    var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var msg = require_messages();
    var {
      Z_NO_FLUSH,
      Z_PARTIAL_FLUSH,
      Z_FULL_FLUSH,
      Z_FINISH,
      Z_BLOCK,
      Z_OK,
      Z_STREAM_END,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_BUF_ERROR,
      Z_DEFAULT_COMPRESSION,
      Z_FILTERED,
      Z_HUFFMAN_ONLY,
      Z_RLE,
      Z_FIXED,
      Z_DEFAULT_STRATEGY,
      Z_UNKNOWN,
      Z_DEFLATED
    } = require_constants2();
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var GZIP_STATE = 57;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    var err = (strm, errorCode) => {
      strm.msg = msg[errorCode];
      return errorCode;
    };
    var rank = (f) => {
      return f * 2 - (f > 4 ? 9 : 0);
    };
    var zero = (buf) => {
      let len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    };
    var slide_hash = (s) => {
      let n, m;
      let p;
      let wsize = s.w_size;
      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = m >= wsize ? m - wsize : 0;
      } while (--n);
      n = wsize;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = m >= wsize ? m - wsize : 0;
      } while (--n);
    };
    var HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
    var HASH = HASH_ZLIB;
    var flush_pending = (strm) => {
      const s = strm.state;
      let len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    };
    var flush_block_only = (s, last) => {
      _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    };
    var put_byte = (s, b) => {
      s.pending_buf[s.pending++] = b;
    };
    var putShortMSB = (s, b) => {
      s.pending_buf[s.pending++] = b >>> 8 & 255;
      s.pending_buf[s.pending++] = b & 255;
    };
    var read_buf = (strm, buf, start, size) => {
      let len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    };
    var longest_match = (s, cur_match) => {
      let chain_length = s.max_chain_length;
      let scan = s.strstart;
      let match;
      let len;
      let best_len = s.prev_length;
      let nice_match = s.nice_match;
      const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      const _win = s.window;
      const wmask = s.w_mask;
      const prev = s.prev;
      const strend = s.strstart + MAX_MATCH;
      let scan_end1 = _win[scan + best_len - 1];
      let scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    };
    var fill_window = (s) => {
      const _w_size = s.w_size;
      let n, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          if (s.insert > s.strstart) {
            s.insert = s.strstart;
          }
          slide_hash(s);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
          while (s.insert) {
            s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    };
    var deflate_stored = (s, flush) => {
      let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
      let len, left, have, last = 0;
      let used = s.strm.avail_in;
      do {
        len = 65535;
        have = s.bi_valid + 42 >> 3;
        if (s.strm.avail_out < have) {
          break;
        }
        have = s.strm.avail_out - have;
        left = s.strstart - s.block_start;
        if (len > left + s.strm.avail_in) {
          len = left + s.strm.avail_in;
        }
        if (len > have) {
          len = have;
        }
        if (len < min_block && (len === 0 && flush !== Z_FINISH || flush === Z_NO_FLUSH || len !== left + s.strm.avail_in)) {
          break;
        }
        last = flush === Z_FINISH && len === left + s.strm.avail_in ? 1 : 0;
        _tr_stored_block(s, 0, 0, last);
        s.pending_buf[s.pending - 4] = len;
        s.pending_buf[s.pending - 3] = len >> 8;
        s.pending_buf[s.pending - 2] = ~len;
        s.pending_buf[s.pending - 1] = ~len >> 8;
        flush_pending(s.strm);
        if (left) {
          if (left > len) {
            left = len;
          }
          s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
          s.strm.next_out += left;
          s.strm.avail_out -= left;
          s.strm.total_out += left;
          s.block_start += left;
          len -= left;
        }
        if (len) {
          read_buf(s.strm, s.strm.output, s.strm.next_out, len);
          s.strm.next_out += len;
          s.strm.avail_out -= len;
          s.strm.total_out += len;
        }
      } while (last === 0);
      used -= s.strm.avail_in;
      if (used) {
        if (used >= s.w_size) {
          s.matches = 2;
          s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
          s.strstart = s.w_size;
          s.insert = s.strstart;
        } else {
          if (s.window_size - s.strstart <= used) {
            s.strstart -= s.w_size;
            s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
            if (s.matches < 2) {
              s.matches++;
            }
            if (s.insert > s.strstart) {
              s.insert = s.strstart;
            }
          }
          s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
          s.strstart += used;
          s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
        }
        s.block_start = s.strstart;
      }
      if (s.high_water < s.strstart) {
        s.high_water = s.strstart;
      }
      if (last) {
        return BS_FINISH_DONE;
      }
      if (flush !== Z_NO_FLUSH && flush !== Z_FINISH && s.strm.avail_in === 0 && s.strstart === s.block_start) {
        return BS_BLOCK_DONE;
      }
      have = s.window_size - s.strstart;
      if (s.strm.avail_in > have && s.block_start >= s.w_size) {
        s.block_start -= s.w_size;
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        have += s.w_size;
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      if (have > s.strm.avail_in) {
        have = s.strm.avail_in;
      }
      if (have) {
        read_buf(s.strm, s.window, s.strstart, have);
        s.strstart += have;
        s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
      }
      if (s.high_water < s.strstart) {
        s.high_water = s.strstart;
      }
      have = s.bi_valid + 42 >> 3;
      have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
      min_block = have > s.w_size ? s.w_size : have;
      left = s.strstart - s.block_start;
      if (left >= min_block || (left || flush === Z_FINISH) && flush !== Z_NO_FLUSH && s.strm.avail_in === 0 && left <= have) {
        len = left > have ? have : left;
        last = flush === Z_FINISH && s.strm.avail_in === 0 && len === left ? 1 : 0;
        _tr_stored_block(s, s.block_start, len, last);
        s.block_start += len;
        flush_pending(s.strm);
      }
      return last ? BS_FINISH_STARTED : BS_NEED_MORE;
    };
    var deflate_fast = (s, flush) => {
      let hash_head;
      let bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
          }
        } else {
          bflush = _tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_slow = (s, flush) => {
      let hash_head;
      let bflush;
      let max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_rle = (s, flush) => {
      let bflush;
      let prev;
      let scan, strend;
      const _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = _tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_huff = (s, flush) => {
      let bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = _tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    var lm_init = (s) => {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    };
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
      this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
      this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new Uint16Array(MAX_BITS + 1);
      this.heap = new Uint16Array(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new Uint16Array(2 * L_CODES + 1);
      zero(this.depth);
      this.sym_buf = 0;
      this.lit_bufsize = 0;
      this.sym_next = 0;
      this.sym_end = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    var deflateStateCheck = (strm) => {
      if (!strm) {
        return 1;
      }
      const s = strm.state;
      if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
      s.status !== GZIP_STATE && //#endif
      s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
        return 1;
      }
      return 0;
    };
    var deflateResetKeep = (strm) => {
      if (deflateStateCheck(strm)) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      const s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = //#ifdef GZIP
      s.wrap === 2 ? GZIP_STATE : (
        //#endif
        s.wrap ? INIT_STATE : BUSY_STATE
      );
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = -2;
      _tr_init(s);
      return Z_OK;
    };
    var deflateReset = (strm) => {
      const ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    };
    var deflateSetHeader = (strm, head) => {
      if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    };
    var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      let wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      const s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.status = INIT_STATE;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new Uint8Array(s.w_size * 2);
      s.head = new Uint16Array(s.hash_size);
      s.prev = new Uint16Array(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new Uint8Array(s.pending_buf_size);
      s.sym_buf = s.lit_bufsize;
      s.sym_end = (s.lit_bufsize - 1) * 3;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    };
    var deflateInit = (strm, level) => {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    };
    var deflate = (strm, flush) => {
      if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      const s = strm.state;
      if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      const old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === INIT_STATE && s.wrap === 0) {
        s.status = BUSY_STATE;
      }
      if (s.status === INIT_STATE) {
        let header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        let level_flags = -1;
        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        putShortMSB(s, header);
        if (s.strstart !== 0) {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
        s.status = BUSY_STATE;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      }
      if (s.status === GZIP_STATE) {
        strm.adler = 0;
        put_byte(s, 31);
        put_byte(s, 139);
        put_byte(s, 8);
        if (!s.gzhead) {
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, OS_CODE);
          s.status = BUSY_STATE;
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        } else {
          put_byte(
            s,
            (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
          );
          put_byte(s, s.gzhead.time & 255);
          put_byte(s, s.gzhead.time >> 8 & 255);
          put_byte(s, s.gzhead.time >> 16 & 255);
          put_byte(s, s.gzhead.time >> 24 & 255);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            put_byte(s, s.gzhead.extra.length & 255);
            put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = EXTRA_STATE;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          let beg = s.pending;
          let left = (s.gzhead.extra.length & 65535) - s.gzindex;
          while (s.pending + left > s.pending_buf_size) {
            let copy = s.pending_buf_size - s.pending;
            s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
            s.pending = s.pending_buf_size;
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            s.gzindex += copy;
            flush_pending(strm);
            if (s.pending !== 0) {
              s.last_flush = -1;
              return Z_OK;
            }
            beg = 0;
            left -= copy;
          }
          let gzhead_extra = new Uint8Array(s.gzhead.extra);
          s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
          s.pending += left;
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          s.gzindex = 0;
        }
        s.status = NAME_STATE;
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          let beg = s.pending;
          let val;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK;
              }
              beg = 0;
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          s.gzindex = 0;
        }
        s.status = COMMENT_STATE;
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          let beg = s.pending;
          let val;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK;
              }
              beg = 0;
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
        }
        s.status = HCRC_STATE;
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
            if (s.pending !== 0) {
              s.last_flush = -1;
              return Z_OK;
            }
          }
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
        }
        s.status = BUSY_STATE;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            _tr_align(s);
          } else if (flush !== Z_BLOCK) {
            _tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        put_byte(s, strm.adler >> 16 & 255);
        put_byte(s, strm.adler >> 24 & 255);
        put_byte(s, strm.total_in & 255);
        put_byte(s, strm.total_in >> 8 & 255);
        put_byte(s, strm.total_in >> 16 & 255);
        put_byte(s, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    };
    var deflateEnd = (strm) => {
      if (deflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const status = strm.state.status;
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    };
    var deflateSetDictionary = (strm, dictionary) => {
      let dictLength = dictionary.length;
      if (deflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const s = strm.state;
      const wrap = s.wrap;
      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        let tmpDict = new Uint8Array(s.w_size);
        tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      const avail = strm.avail_in;
      const next = strm.next_in;
      const input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        let str = s.strstart;
        let n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    };
    module2.exports.deflateInit = deflateInit;
    module2.exports.deflateInit2 = deflateInit2;
    module2.exports.deflateReset = deflateReset;
    module2.exports.deflateResetKeep = deflateResetKeep;
    module2.exports.deflateSetHeader = deflateSetHeader;
    module2.exports.deflate = deflate;
    module2.exports.deflateEnd = deflateEnd;
    module2.exports.deflateSetDictionary = deflateSetDictionary;
    module2.exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "node_modules/pako/lib/utils/common.js"(exports2, module2) {
    "use strict";
    var _has = (obj, key) => {
      return Object.prototype.hasOwnProperty.call(obj, key);
    };
    module2.exports.assign = function(obj) {
      const sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        const source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (const p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    module2.exports.flattenChunks = (chunks) => {
      let len = 0;
      for (let i = 0, l = chunks.length; i < l; i++) {
        len += chunks[i].length;
      }
      const result = new Uint8Array(len);
      for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
        let chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    };
  }
});

// node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "node_modules/pako/lib/utils/strings.js"(exports2, module2) {
    "use strict";
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new Uint8Array(256);
    for (let q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    _utf8len[254] = _utf8len[254] = 1;
    module2.exports.string2buf = (str) => {
      if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
        return new TextEncoder().encode(str);
      }
      let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      buf = new Uint8Array(buf_len);
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i++] = c;
        } else if (c < 2048) {
          buf[i++] = 192 | c >>> 6;
          buf[i++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i++] = 224 | c >>> 12;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        } else {
          buf[i++] = 240 | c >>> 18;
          buf[i++] = 128 | c >>> 12 & 63;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        }
      }
      return buf;
    };
    var buf2binstring = (buf, len) => {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK) {
          return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
        }
      }
      let result = "";
      for (let i = 0; i < len; i++) {
        result += String.fromCharCode(buf[i]);
      }
      return result;
    };
    module2.exports.buf2string = (buf, max) => {
      const len = max || buf.length;
      if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
        return new TextDecoder().decode(buf.subarray(0, max));
      }
      let i, out;
      const utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len; ) {
        let c = buf[i++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        let c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i < len) {
          c = c << 6 | buf[i++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    module2.exports.utf8border = (buf, max) => {
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      let pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
  }
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "node_modules/pako/lib/zlib/zstream.js"(exports2, module2) {
    "use strict";
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module2.exports = ZStream;
  }
});

// node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "node_modules/pako/lib/deflate.js"(exports2, module2) {
    "use strict";
    var zlib_deflate = require_deflate();
    var utils = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString = Object.prototype.toString;
    var {
      Z_NO_FLUSH,
      Z_SYNC_FLUSH,
      Z_FULL_FLUSH,
      Z_FINISH,
      Z_OK,
      Z_STREAM_END,
      Z_DEFAULT_COMPRESSION,
      Z_DEFAULT_STRATEGY,
      Z_DEFLATED
    } = require_constants2();
    function Deflate(options) {
      this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY
      }, options || {});
      let opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      let status = zlib_deflate.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        let dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      let status, _flush_mode;
      if (this.ended) {
        return false;
      }
      if (flush_mode === ~~flush_mode)
        _flush_mode = flush_mode;
      else
        _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        status = zlib_deflate.deflate(strm, _flush_mode);
        if (status === Z_STREAM_END) {
          if (strm.next_out > 0) {
            this.onData(strm.output.subarray(0, strm.next_out));
          }
          status = zlib_deflate.deflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === Z_OK;
        }
        if (strm.avail_out === 0) {
          this.onData(strm.output);
          continue;
        }
        if (_flush_mode > 0 && strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        if (strm.avail_in === 0)
          break;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        this.result = utils.flattenChunks(this.chunks);
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      const deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    module2.exports.Deflate = Deflate;
    module2.exports.deflate = deflate;
    module2.exports.deflateRaw = deflateRaw;
    module2.exports.gzip = gzip;
    module2.exports.constants = require_constants2();
  }
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "node_modules/pako/lib/zlib/inffast.js"(exports2, module2) {
    "use strict";
    var BAD = 16209;
    var TYPE = 16191;
    module2.exports = function inflate_fast(strm, start) {
      let _in;
      let last;
      let _out;
      let beg;
      let end;
      let dmax;
      let wsize;
      let whave;
      let wnext;
      let s_window;
      let hold;
      let bits;
      let lcode;
      let dcode;
      let lmask;
      let dmask;
      let here;
      let op;
      let len;
      let dist;
      let from;
      let from_source;
      let input, output;
      const state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "node_modules/pako/lib/zlib/inftrees.js"(exports2, module2) {
    "use strict";
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = new Uint16Array([
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ]);
    var lext = new Uint8Array([
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ]);
    var dbase = new Uint16Array([
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ]);
    var dext = new Uint8Array([
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ]);
    var inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
      const bits = opts.bits;
      let len = 0;
      let sym = 0;
      let min = 0, max = 0;
      let root = 0;
      let curr = 0;
      let drop = 0;
      let left = 0;
      let used = 0;
      let huff = 0;
      let incr;
      let fill;
      let low;
      let mask;
      let next;
      let base = null;
      let match;
      const count = new Uint16Array(MAXBITS + 1);
      const offs = new Uint16Array(MAXBITS + 1);
      let extra = null;
      let here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        match = 20;
      } else if (type === LENS) {
        base = lbase;
        extra = lext;
        match = 257;
      } else {
        base = dbase;
        extra = dext;
        match = 0;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] + 1 < match) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] >= match) {
          here_op = extra[work[sym] - match];
          here_val = base[work[sym] - match];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
    module2.exports = inflate_table;
  }
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "node_modules/pako/lib/zlib/inflate.js"(exports2, module2) {
    "use strict";
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var {
      Z_FINISH,
      Z_BLOCK,
      Z_TREES,
      Z_OK,
      Z_STREAM_END,
      Z_NEED_DICT,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_MEM_ERROR,
      Z_BUF_ERROR,
      Z_DEFLATED
    } = require_constants2();
    var HEAD = 16180;
    var FLAGS = 16181;
    var TIME = 16182;
    var OS = 16183;
    var EXLEN = 16184;
    var EXTRA = 16185;
    var NAME = 16186;
    var COMMENT = 16187;
    var HCRC = 16188;
    var DICTID = 16189;
    var DICT = 16190;
    var TYPE = 16191;
    var TYPEDO = 16192;
    var STORED = 16193;
    var COPY_ = 16194;
    var COPY = 16195;
    var TABLE = 16196;
    var LENLENS = 16197;
    var CODELENS = 16198;
    var LEN_ = 16199;
    var LEN = 16200;
    var LENEXT = 16201;
    var DIST = 16202;
    var DISTEXT = 16203;
    var MATCH = 16204;
    var LIT = 16205;
    var CHECK = 16206;
    var LENGTH = 16207;
    var DONE = 16208;
    var BAD = 16209;
    var MEM = 16210;
    var SYNC = 16211;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    var zswap32 = (q) => {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    };
    function InflateState() {
      this.strm = null;
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new Uint16Array(320);
      this.work = new Uint16Array(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    var inflateStateCheck = (strm) => {
      if (!strm) {
        return 1;
      }
      const state = strm.state;
      if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
        return 1;
      }
      return 0;
    };
    var inflateResetKeep = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.flags = -1;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
      state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    };
    var inflateReset = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    };
    var inflateReset2 = (strm, windowBits) => {
      let wrap;
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 5;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    };
    var inflateInit2 = (strm, windowBits) => {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      const state = new InflateState();
      strm.state = state;
      state.strm = strm;
      state.window = null;
      state.mode = HEAD;
      const ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    };
    var inflateInit = (strm) => {
      return inflateInit2(strm, DEF_WBITS);
    };
    var virgin = true;
    var lenfix;
    var distfix;
    var fixedtables = (state) => {
      if (virgin) {
        lenfix = new Int32Array(512);
        distfix = new Int32Array(32);
        let sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    };
    var updatewindow = (strm, src, end, copy) => {
      let dist;
      const state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new Uint8Array(state.wsize);
      }
      if (copy >= state.wsize) {
        state.window.set(src.subarray(end - state.wsize, end), 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
        copy -= dist;
        if (copy) {
          state.window.set(src.subarray(end - copy, end), 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    };
    var inflate = (strm, flush) => {
      let state;
      let input, output;
      let next;
      let put;
      let have, left;
      let hold;
      let bits;
      let _in, _out;
      let copy;
      let from;
      let from_source;
      let here = 0;
      let here_bits, here_op, here_val;
      let last_bits, last_op, last_val;
      let len;
      let ret;
      const hbuf = new Uint8Array(4);
      let opts;
      let n;
      const order = (
        /* permutation of code lengths */
        new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
      );
      if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                if (state.wbits === 0) {
                  state.wbits = 15;
                }
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              }
              if (len > 15 || len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << state.wbits;
              state.flags = 0;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512 && state.wrap & 4) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Uint8Array(state.head.extra_len);
                    }
                    state.head.extra.set(
                      input.subarray(
                        next,
                        // extra field is limited to 65536 bytes
                        // - no need for additional size check
                        next + copy
                      ),
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512 && state.wrap & 4) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512 && state.wrap & 4) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512 && state.wrap & 4) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.wrap & 4 && hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                output.set(input.subarray(next, next + copy), put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (state.wrap & 4 && _out) {
                  strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap & 4 && _out) {
        strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    };
    var inflateEnd = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      let state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    };
    var inflateGetHeader = (strm, head) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    };
    var inflateSetDictionary = (strm, dictionary) => {
      const dictLength = dictionary.length;
      let state;
      let dictid;
      let ret;
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    };
    module2.exports.inflateReset = inflateReset;
    module2.exports.inflateReset2 = inflateReset2;
    module2.exports.inflateResetKeep = inflateResetKeep;
    module2.exports.inflateInit = inflateInit;
    module2.exports.inflateInit2 = inflateInit2;
    module2.exports.inflate = inflate;
    module2.exports.inflateEnd = inflateEnd;
    module2.exports.inflateGetHeader = inflateGetHeader;
    module2.exports.inflateSetDictionary = inflateSetDictionary;
    module2.exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "node_modules/pako/lib/zlib/gzheader.js"(exports2, module2) {
    "use strict";
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module2.exports = GZheader;
  }
});

// node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "node_modules/pako/lib/inflate.js"(exports2, module2) {
    "use strict";
    var zlib_inflate = require_inflate();
    var utils = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString = Object.prototype.toString;
    var {
      Z_NO_FLUSH,
      Z_FINISH,
      Z_OK,
      Z_STREAM_END,
      Z_NEED_DICT,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_MEM_ERROR
    } = require_constants2();
    function Inflate(options) {
      this.options = utils.assign({
        chunkSize: 1024 * 64,
        windowBits: 15,
        to: ""
      }, options || {});
      const opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      let status = zlib_inflate.inflateInit2(
        this.strm,
        opt.windowBits
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      const dictionary = this.options.dictionary;
      let status, _flush_mode, last_avail_out;
      if (this.ended)
        return false;
      if (flush_mode === ~~flush_mode)
        _flush_mode = flush_mode;
      else
        _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, _flush_mode);
        if (status === Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(strm, dictionary);
          if (status === Z_OK) {
            status = zlib_inflate.inflate(strm, _flush_mode);
          } else if (status === Z_DATA_ERROR) {
            status = Z_NEED_DICT;
          }
        }
        while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
          zlib_inflate.inflateReset(strm);
          status = zlib_inflate.inflate(strm, _flush_mode);
        }
        switch (status) {
          case Z_STREAM_ERROR:
          case Z_DATA_ERROR:
          case Z_NEED_DICT:
          case Z_MEM_ERROR:
            this.onEnd(status);
            this.ended = true;
            return false;
        }
        last_avail_out = strm.avail_out;
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === Z_STREAM_END) {
            if (this.options.to === "string") {
              let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              let tail = strm.next_out - next_out_utf8;
              let utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail)
                strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
              this.onData(utf8str);
            } else {
              this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
            }
          }
        }
        if (status === Z_OK && last_avail_out === 0)
          continue;
        if (status === Z_STREAM_END) {
          status = zlib_inflate.inflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return true;
        }
        if (strm.avail_in === 0)
          break;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      const inflator = new Inflate(options);
      inflator.push(input);
      if (inflator.err)
        throw inflator.msg || msg[inflator.err];
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    module2.exports.Inflate = Inflate;
    module2.exports.inflate = inflate;
    module2.exports.inflateRaw = inflateRaw;
    module2.exports.ungzip = inflate;
    module2.exports.constants = require_constants2();
  }
});

// node_modules/pako/index.js
var require_pako = __commonJS({
  "node_modules/pako/index.js"(exports2, module2) {
    "use strict";
    var { Deflate, deflate, deflateRaw, gzip } = require_deflate2();
    var { Inflate, inflate, inflateRaw, ungzip } = require_inflate2();
    var constants = require_constants2();
    module2.exports.Deflate = Deflate;
    module2.exports.deflate = deflate;
    module2.exports.deflateRaw = deflateRaw;
    module2.exports.gzip = gzip;
    module2.exports.Inflate = Inflate;
    module2.exports.inflate = inflate;
    module2.exports.inflateRaw = inflateRaw;
    module2.exports.ungzip = ungzip;
    module2.exports.constants = constants;
  }
});

// node_modules/fast-png/lib/common.js
var require_common2 = __commonJS({
  "node_modules/fast-png/lib/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.crc = exports2.pngSignature = void 0;
    exports2.pngSignature = [137, 80, 78, 71, 13, 10, 26, 10];
    var crcTable = [];
    for (let n = 0; n < 256; n++) {
      let c = n;
      for (let k = 0; k < 8; k++) {
        if (c & 1) {
          c = 3988292384 ^ c >>> 1;
        } else {
          c = c >>> 1;
        }
      }
      crcTable[n] = c;
    }
    var initialCrc = 4294967295;
    function updateCrc(currentCrc, data, length) {
      let c = currentCrc;
      for (let n = 0; n < length; n++) {
        c = crcTable[(c ^ data[n]) & 255] ^ c >>> 8;
      }
      return c;
    }
    function crc(data, length) {
      return (updateCrc(initialCrc, data, length) ^ initialCrc) >>> 0;
    }
    exports2.crc = crc;
  }
});

// node_modules/fast-png/lib/internalTypes.js
var require_internalTypes = __commonJS({
  "node_modules/fast-png/lib/internalTypes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InterlaceMethod = exports2.FilterMethod = exports2.CompressionMethod = exports2.ColorType = void 0;
    var ColorType;
    (function(ColorType2) {
      ColorType2[ColorType2["UNKNOWN"] = -1] = "UNKNOWN";
      ColorType2[ColorType2["GREYSCALE"] = 0] = "GREYSCALE";
      ColorType2[ColorType2["TRUECOLOUR"] = 2] = "TRUECOLOUR";
      ColorType2[ColorType2["INDEXED_COLOUR"] = 3] = "INDEXED_COLOUR";
      ColorType2[ColorType2["GREYSCALE_ALPHA"] = 4] = "GREYSCALE_ALPHA";
      ColorType2[ColorType2["TRUECOLOUR_ALPHA"] = 6] = "TRUECOLOUR_ALPHA";
    })(ColorType || (exports2.ColorType = ColorType = {}));
    var CompressionMethod;
    (function(CompressionMethod2) {
      CompressionMethod2[CompressionMethod2["UNKNOWN"] = -1] = "UNKNOWN";
      CompressionMethod2[CompressionMethod2["DEFLATE"] = 0] = "DEFLATE";
    })(CompressionMethod || (exports2.CompressionMethod = CompressionMethod = {}));
    var FilterMethod;
    (function(FilterMethod2) {
      FilterMethod2[FilterMethod2["UNKNOWN"] = -1] = "UNKNOWN";
      FilterMethod2[FilterMethod2["ADAPTIVE"] = 0] = "ADAPTIVE";
    })(FilterMethod || (exports2.FilterMethod = FilterMethod = {}));
    var InterlaceMethod;
    (function(InterlaceMethod2) {
      InterlaceMethod2[InterlaceMethod2["UNKNOWN"] = -1] = "UNKNOWN";
      InterlaceMethod2[InterlaceMethod2["NO_INTERLACE"] = 0] = "NO_INTERLACE";
      InterlaceMethod2[InterlaceMethod2["ADAM7"] = 1] = "ADAM7";
    })(InterlaceMethod || (exports2.InterlaceMethod = InterlaceMethod = {}));
  }
});

// node_modules/fast-png/lib/PngDecoder.js
var require_PngDecoder = __commonJS({
  "node_modules/fast-png/lib/PngDecoder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var iobuffer_1 = require_IOBuffer();
    var pako_1 = require_pako();
    var common_1 = require_common2();
    var internalTypes_1 = require_internalTypes();
    var empty = new Uint8Array(0);
    var NULL = "\0";
    var uint16 = new Uint16Array([255]);
    var uint8 = new Uint8Array(uint16.buffer);
    var osIsLittleEndian = uint8[0] === 255;
    var PngDecoder = class extends iobuffer_1.IOBuffer {
      constructor(data, options = {}) {
        super(data);
        const { checkCrc = false } = options;
        this._checkCrc = checkCrc;
        this._inflator = new pako_1.Inflate();
        this._png = {
          width: -1,
          height: -1,
          channels: -1,
          data: new Uint8Array(0),
          depth: 1,
          text: {}
        };
        this._end = false;
        this._hasPalette = false;
        this._palette = [];
        this._hasTransparency = false;
        this._transparency = new Uint16Array(0);
        this._compressionMethod = internalTypes_1.CompressionMethod.UNKNOWN;
        this._filterMethod = internalTypes_1.FilterMethod.UNKNOWN;
        this._interlaceMethod = internalTypes_1.InterlaceMethod.UNKNOWN;
        this._colorType = internalTypes_1.ColorType.UNKNOWN;
        this.setBigEndian();
      }
      decode() {
        this.decodeSignature();
        while (!this._end) {
          this.decodeChunk();
        }
        this.decodeImage();
        return this._png;
      }
      // https://www.w3.org/TR/PNG/#5PNG-file-signature
      decodeSignature() {
        for (let i = 0; i < common_1.pngSignature.length; i++) {
          if (this.readUint8() !== common_1.pngSignature[i]) {
            throw new Error(`wrong PNG signature. Byte at ${i} should be ${common_1.pngSignature[i]}.`);
          }
        }
      }
      // https://www.w3.org/TR/PNG/#5Chunk-layout
      decodeChunk() {
        const length = this.readUint32();
        const type = this.readChars(4);
        const offset = this.offset;
        switch (type) {
          case "IHDR":
            this.decodeIHDR();
            break;
          case "PLTE":
            this.decodePLTE(length);
            break;
          case "IDAT":
            this.decodeIDAT(length);
            break;
          case "IEND":
            this._end = true;
            break;
          case "tRNS":
            this.decodetRNS(length);
            break;
          case "iCCP":
            this.decodeiCCP(length);
            break;
          case "tEXt":
            this.decodetEXt(length);
            break;
          case "pHYs":
            this.decodepHYs();
            break;
          default:
            this.skip(length);
            break;
        }
        if (this.offset - offset !== length) {
          throw new Error(`Length mismatch while decoding chunk ${type}`);
        }
        if (this._checkCrc) {
          const expectedCrc = this.readUint32();
          const crcLength = length + 4;
          const actualCrc = (0, common_1.crc)(new Uint8Array(this.buffer, this.byteOffset + this.offset - crcLength - 4, crcLength), crcLength);
          if (actualCrc !== expectedCrc) {
            throw new Error(`CRC mismatch for chunk ${type}. Expected ${expectedCrc}, found ${actualCrc}`);
          }
        } else {
          this.skip(4);
        }
      }
      // https://www.w3.org/TR/PNG/#11IHDR
      decodeIHDR() {
        const image = this._png;
        image.width = this.readUint32();
        image.height = this.readUint32();
        image.depth = checkBitDepth(this.readUint8());
        const colorType = this.readUint8();
        this._colorType = colorType;
        let channels;
        switch (colorType) {
          case internalTypes_1.ColorType.GREYSCALE:
            channels = 1;
            break;
          case internalTypes_1.ColorType.TRUECOLOUR:
            channels = 3;
            break;
          case internalTypes_1.ColorType.INDEXED_COLOUR:
            channels = 1;
            break;
          case internalTypes_1.ColorType.GREYSCALE_ALPHA:
            channels = 2;
            break;
          case internalTypes_1.ColorType.TRUECOLOUR_ALPHA:
            channels = 4;
            break;
          default:
            throw new Error(`Unknown color type: ${colorType}`);
        }
        this._png.channels = channels;
        this._compressionMethod = this.readUint8();
        if (this._compressionMethod !== internalTypes_1.CompressionMethod.DEFLATE) {
          throw new Error(`Unsupported compression method: ${this._compressionMethod}`);
        }
        this._filterMethod = this.readUint8();
        this._interlaceMethod = this.readUint8();
      }
      // https://www.w3.org/TR/PNG/#11PLTE
      decodePLTE(length) {
        if (length % 3 !== 0) {
          throw new RangeError(`PLTE field length must be a multiple of 3. Got ${length}`);
        }
        const l = length / 3;
        this._hasPalette = true;
        const palette = [];
        this._palette = palette;
        for (let i = 0; i < l; i++) {
          palette.push([this.readUint8(), this.readUint8(), this.readUint8()]);
        }
      }
      // https://www.w3.org/TR/PNG/#11IDAT
      decodeIDAT(length) {
        this._inflator.push(new Uint8Array(this.buffer, this.offset + this.byteOffset, length));
        this.skip(length);
      }
      // https://www.w3.org/TR/PNG/#11tRNS
      decodetRNS(length) {
        switch (this._colorType) {
          case internalTypes_1.ColorType.GREYSCALE:
          case internalTypes_1.ColorType.TRUECOLOUR: {
            if (length % 2 !== 0) {
              throw new RangeError(`tRNS chunk length must be a multiple of 2. Got ${length}`);
            }
            if (length / 2 > this._png.width * this._png.height) {
              throw new Error(`tRNS chunk contains more alpha values than there are pixels (${length / 2} vs ${this._png.width * this._png.height})`);
            }
            this._hasTransparency = true;
            this._transparency = new Uint16Array(length / 2);
            for (let i = 0; i < length / 2; i++) {
              this._transparency[i] = this.readUint16();
            }
            break;
          }
          case internalTypes_1.ColorType.INDEXED_COLOUR: {
            if (length > this._palette.length) {
              throw new Error(`tRNS chunk contains more alpha values than there are palette colors (${length} vs ${this._palette.length})`);
            }
            let i = 0;
            for (; i < length; i++) {
              const alpha = this.readByte();
              this._palette[i].push(alpha);
            }
            for (; i < this._palette.length; i++) {
              this._palette[i].push(255);
            }
            break;
          }
          default: {
            throw new Error(`tRNS chunk is not supported for color type ${this._colorType}`);
          }
        }
      }
      // https://www.w3.org/TR/PNG/#11iCCP
      decodeiCCP(length) {
        let name = "";
        let char;
        while ((char = this.readChar()) !== NULL) {
          name += char;
        }
        const compressionMethod = this.readUint8();
        if (compressionMethod !== internalTypes_1.CompressionMethod.DEFLATE) {
          throw new Error(`Unsupported iCCP compression method: ${compressionMethod}`);
        }
        const compressedProfile = this.readBytes(length - name.length - 2);
        this._png.iccEmbeddedProfile = {
          name,
          profile: (0, pako_1.inflate)(compressedProfile)
        };
      }
      // https://www.w3.org/TR/PNG/#11tEXt
      decodetEXt(length) {
        let keyword = "";
        let char;
        while ((char = this.readChar()) !== NULL) {
          keyword += char;
        }
        this._png.text[keyword] = this.readChars(length - keyword.length - 1);
      }
      // https://www.w3.org/TR/PNG/#11pHYs
      decodepHYs() {
        const ppuX = this.readUint32();
        const ppuY = this.readUint32();
        const unitSpecifier = this.readByte();
        this._png.resolution = { x: ppuX, y: ppuY, unit: unitSpecifier };
      }
      decodeImage() {
        if (this._inflator.err) {
          throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
        }
        const data = this._inflator.result;
        if (this._filterMethod !== internalTypes_1.FilterMethod.ADAPTIVE) {
          throw new Error(`Filter method ${this._filterMethod} not supported`);
        }
        if (this._interlaceMethod === internalTypes_1.InterlaceMethod.NO_INTERLACE) {
          this.decodeInterlaceNull(data);
        } else {
          throw new Error(`Interlace method ${this._interlaceMethod} not supported`);
        }
      }
      decodeInterlaceNull(data) {
        const height = this._png.height;
        const bytesPerPixel = this._png.channels * this._png.depth / 8;
        const bytesPerLine = this._png.width * bytesPerPixel;
        const newData = new Uint8Array(this._png.height * bytesPerLine);
        let prevLine = empty;
        let offset = 0;
        let currentLine;
        let newLine;
        for (let i = 0; i < height; i++) {
          currentLine = data.subarray(offset + 1, offset + 1 + bytesPerLine);
          newLine = newData.subarray(i * bytesPerLine, (i + 1) * bytesPerLine);
          switch (data[offset]) {
            case 0:
              unfilterNone(currentLine, newLine, bytesPerLine);
              break;
            case 1:
              unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel);
              break;
            case 2:
              unfilterUp(currentLine, newLine, prevLine, bytesPerLine);
              break;
            case 3:
              unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);
              break;
            case 4:
              unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);
              break;
            default:
              throw new Error(`Unsupported filter: ${data[offset]}`);
          }
          prevLine = newLine;
          offset += bytesPerLine + 1;
        }
        if (this._hasPalette) {
          this._png.palette = this._palette;
        }
        if (this._hasTransparency) {
          this._png.transparency = this._transparency;
        }
        if (this._png.depth === 16) {
          const uint16Data = new Uint16Array(newData.buffer);
          if (osIsLittleEndian) {
            for (let k = 0; k < uint16Data.length; k++) {
              uint16Data[k] = swap16(uint16Data[k]);
            }
          }
          this._png.data = uint16Data;
        } else {
          this._png.data = newData;
        }
      }
    };
    exports2.default = PngDecoder;
    function unfilterNone(currentLine, newLine, bytesPerLine) {
      for (let i = 0; i < bytesPerLine; i++) {
        newLine[i] = currentLine[i];
      }
    }
    function unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel) {
      let i = 0;
      for (; i < bytesPerPixel; i++) {
        newLine[i] = currentLine[i];
      }
      for (; i < bytesPerLine; i++) {
        newLine[i] = currentLine[i] + newLine[i - bytesPerPixel] & 255;
      }
    }
    function unfilterUp(currentLine, newLine, prevLine, bytesPerLine) {
      let i = 0;
      if (prevLine.length === 0) {
        for (; i < bytesPerLine; i++) {
          newLine[i] = currentLine[i];
        }
      } else {
        for (; i < bytesPerLine; i++) {
          newLine[i] = currentLine[i] + prevLine[i] & 255;
        }
      }
    }
    function unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {
      let i = 0;
      if (prevLine.length === 0) {
        for (; i < bytesPerPixel; i++) {
          newLine[i] = currentLine[i];
        }
        for (; i < bytesPerLine; i++) {
          newLine[i] = currentLine[i] + (newLine[i - bytesPerPixel] >> 1) & 255;
        }
      } else {
        for (; i < bytesPerPixel; i++) {
          newLine[i] = currentLine[i] + (prevLine[i] >> 1) & 255;
        }
        for (; i < bytesPerLine; i++) {
          newLine[i] = currentLine[i] + (newLine[i - bytesPerPixel] + prevLine[i] >> 1) & 255;
        }
      }
    }
    function unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {
      let i = 0;
      if (prevLine.length === 0) {
        for (; i < bytesPerPixel; i++) {
          newLine[i] = currentLine[i];
        }
        for (; i < bytesPerLine; i++) {
          newLine[i] = currentLine[i] + newLine[i - bytesPerPixel] & 255;
        }
      } else {
        for (; i < bytesPerPixel; i++) {
          newLine[i] = currentLine[i] + prevLine[i] & 255;
        }
        for (; i < bytesPerLine; i++) {
          newLine[i] = currentLine[i] + paethPredictor(newLine[i - bytesPerPixel], prevLine[i], prevLine[i - bytesPerPixel]) & 255;
        }
      }
    }
    function paethPredictor(a, b, c) {
      const p = a + b - c;
      const pa = Math.abs(p - a);
      const pb = Math.abs(p - b);
      const pc = Math.abs(p - c);
      if (pa <= pb && pa <= pc)
        return a;
      else if (pb <= pc)
        return b;
      else
        return c;
    }
    function swap16(val) {
      return (val & 255) << 8 | val >> 8 & 255;
    }
    function checkBitDepth(value) {
      if (value !== 1 && value !== 2 && value !== 4 && value !== 8 && value !== 16) {
        throw new Error(`invalid bit depth: ${value}`);
      }
      return value;
    }
  }
});

// node_modules/fast-png/lib/PngEncoder.js
var require_PngEncoder = __commonJS({
  "node_modules/fast-png/lib/PngEncoder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var iobuffer_1 = require_IOBuffer();
    var pako_1 = require_pako();
    var common_1 = require_common2();
    var internalTypes_1 = require_internalTypes();
    var defaultZlibOptions = {
      level: 3
    };
    var PngEncoder = class extends iobuffer_1.IOBuffer {
      constructor(data, options = {}) {
        super();
        this._colorType = internalTypes_1.ColorType.UNKNOWN;
        this._zlibOptions = { ...defaultZlibOptions, ...options.zlib };
        this._png = this._checkData(data);
        this.setBigEndian();
      }
      encode() {
        this.encodeSignature();
        this.encodeIHDR();
        this.encodeData();
        this.encodeIEND();
        return this.toArray();
      }
      // https://www.w3.org/TR/PNG/#5PNG-file-signature
      encodeSignature() {
        this.writeBytes(common_1.pngSignature);
      }
      // https://www.w3.org/TR/PNG/#11IHDR
      encodeIHDR() {
        this.writeUint32(13);
        this.writeChars("IHDR");
        this.writeUint32(this._png.width);
        this.writeUint32(this._png.height);
        this.writeByte(this._png.depth);
        this.writeByte(this._colorType);
        this.writeByte(internalTypes_1.CompressionMethod.DEFLATE);
        this.writeByte(internalTypes_1.FilterMethod.ADAPTIVE);
        this.writeByte(internalTypes_1.InterlaceMethod.NO_INTERLACE);
        this.writeCrc(17);
      }
      // https://www.w3.org/TR/PNG/#11IEND
      encodeIEND() {
        this.writeUint32(0);
        this.writeChars("IEND");
        this.writeCrc(4);
      }
      // https://www.w3.org/TR/PNG/#11IDAT
      encodeIDAT(data) {
        this.writeUint32(data.length);
        this.writeChars("IDAT");
        this.writeBytes(data);
        this.writeCrc(data.length + 4);
      }
      encodeData() {
        const { width, height, channels, depth, data } = this._png;
        const slotsPerLine = channels * width;
        const newData = new iobuffer_1.IOBuffer().setBigEndian();
        let offset = 0;
        for (let i = 0; i < height; i++) {
          newData.writeByte(0);
          if (depth === 8) {
            offset = writeDataBytes(data, newData, slotsPerLine, offset);
          } else if (depth === 16) {
            offset = writeDataUint16(data, newData, slotsPerLine, offset);
          } else {
            throw new Error("unreachable");
          }
        }
        const buffer = newData.toArray();
        const compressed = (0, pako_1.deflate)(buffer, this._zlibOptions);
        this.encodeIDAT(compressed);
      }
      _checkData(data) {
        const { colorType, channels, depth } = getColorType(data);
        const png = {
          width: checkInteger(data.width, "width"),
          height: checkInteger(data.height, "height"),
          channels,
          data: data.data,
          depth,
          text: {}
        };
        this._colorType = colorType;
        const expectedSize = png.width * png.height * channels;
        if (png.data.length !== expectedSize) {
          throw new RangeError(`wrong data size. Found ${png.data.length}, expected ${expectedSize}`);
        }
        return png;
      }
      writeCrc(length) {
        this.writeUint32((0, common_1.crc)(new Uint8Array(this.buffer, this.byteOffset + this.offset - length, length), length));
      }
    };
    exports2.default = PngEncoder;
    function checkInteger(value, name) {
      if (Number.isInteger(value) && value > 0) {
        return value;
      }
      throw new TypeError(`${name} must be a positive integer`);
    }
    function getColorType(data) {
      const { channels = 4, depth = 8 } = data;
      if (channels !== 4 && channels !== 3 && channels !== 2 && channels !== 1) {
        throw new RangeError(`unsupported number of channels: ${channels}`);
      }
      if (depth !== 8 && depth !== 16) {
        throw new RangeError(`unsupported bit depth: ${depth}`);
      }
      const returnValue = { channels, depth, colorType: internalTypes_1.ColorType.UNKNOWN };
      switch (channels) {
        case 4:
          returnValue.colorType = internalTypes_1.ColorType.TRUECOLOUR_ALPHA;
          break;
        case 3:
          returnValue.colorType = internalTypes_1.ColorType.TRUECOLOUR;
          break;
        case 1:
          returnValue.colorType = internalTypes_1.ColorType.GREYSCALE;
          break;
        case 2:
          returnValue.colorType = internalTypes_1.ColorType.GREYSCALE_ALPHA;
          break;
        default:
          throw new Error("unsupported number of channels");
      }
      return returnValue;
    }
    function writeDataBytes(data, newData, slotsPerLine, offset) {
      for (let j = 0; j < slotsPerLine; j++) {
        newData.writeByte(data[offset++]);
      }
      return offset;
    }
    function writeDataUint16(data, newData, slotsPerLine, offset) {
      for (let j = 0; j < slotsPerLine; j++) {
        newData.writeUint16(data[offset++]);
      }
      return offset;
    }
  }
});

// node_modules/fast-png/lib/types.js
var require_types = __commonJS({
  "node_modules/fast-png/lib/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ResolutionUnitSpecifier = void 0;
    var ResolutionUnitSpecifier;
    (function(ResolutionUnitSpecifier2) {
      ResolutionUnitSpecifier2[ResolutionUnitSpecifier2["UNKNOWN"] = 0] = "UNKNOWN";
      ResolutionUnitSpecifier2[ResolutionUnitSpecifier2["METRE"] = 1] = "METRE";
    })(ResolutionUnitSpecifier || (exports2.ResolutionUnitSpecifier = ResolutionUnitSpecifier = {}));
  }
});

// node_modules/fast-png/lib/index.js
var require_lib = __commonJS({
  "node_modules/fast-png/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encode = exports2.decode = void 0;
    var PngDecoder_1 = __importDefault(require_PngDecoder());
    var PngEncoder_1 = __importDefault(require_PngEncoder());
    __exportStar(require_types(), exports2);
    function decodePng(data, options) {
      const decoder = new PngDecoder_1.default(data, options);
      return decoder.decode();
    }
    exports2.decode = decodePng;
    function encodePng(png, options) {
      const encoder = new PngEncoder_1.default(png, options);
      return encoder.encode();
    }
    exports2.encode = encodePng;
  }
});

// node_modules/jpeg-js/lib/encoder.js
var require_encoder = __commonJS({
  "node_modules/jpeg-js/lib/encoder.js"(exports2, module2) {
    var btoa2 = btoa2 || function(buf) {
      return Buffer.from(buf).toString("base64");
    };
    function JPEGEncoder(quality) {
      var self2 = this;
      var fround = Math.round;
      var ffloor = Math.floor;
      var YTable = new Array(64);
      var UVTable = new Array(64);
      var fdtbl_Y = new Array(64);
      var fdtbl_UV = new Array(64);
      var YDC_HT;
      var UVDC_HT;
      var YAC_HT;
      var UVAC_HT;
      var bitcode = new Array(65535);
      var category = new Array(65535);
      var outputfDCTQuant = new Array(64);
      var DU = new Array(64);
      var byteout = [];
      var bytenew = 0;
      var bytepos = 7;
      var YDU = new Array(64);
      var UDU = new Array(64);
      var VDU = new Array(64);
      var clt = new Array(256);
      var RGB_YUV_TABLE = new Array(2048);
      var currentQuality;
      var ZigZag = [
        0,
        1,
        5,
        6,
        14,
        15,
        27,
        28,
        2,
        4,
        7,
        13,
        16,
        26,
        29,
        42,
        3,
        8,
        12,
        17,
        25,
        30,
        41,
        43,
        9,
        11,
        18,
        24,
        31,
        40,
        44,
        53,
        10,
        19,
        23,
        32,
        39,
        45,
        52,
        54,
        20,
        22,
        33,
        38,
        46,
        51,
        55,
        60,
        21,
        34,
        37,
        47,
        50,
        56,
        59,
        61,
        35,
        36,
        48,
        49,
        57,
        58,
        62,
        63
      ];
      var std_dc_luminance_nrcodes = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0];
      var std_dc_luminance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
      var std_ac_luminance_nrcodes = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125];
      var std_ac_luminance_values = [
        1,
        2,
        3,
        0,
        4,
        17,
        5,
        18,
        33,
        49,
        65,
        6,
        19,
        81,
        97,
        7,
        34,
        113,
        20,
        50,
        129,
        145,
        161,
        8,
        35,
        66,
        177,
        193,
        21,
        82,
        209,
        240,
        36,
        51,
        98,
        114,
        130,
        9,
        10,
        22,
        23,
        24,
        25,
        26,
        37,
        38,
        39,
        40,
        41,
        42,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        241,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
      ];
      var std_dc_chrominance_nrcodes = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];
      var std_dc_chrominance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
      var std_ac_chrominance_nrcodes = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119];
      var std_ac_chrominance_values = [
        0,
        1,
        2,
        3,
        17,
        4,
        5,
        33,
        49,
        6,
        18,
        65,
        81,
        7,
        97,
        113,
        19,
        34,
        50,
        129,
        8,
        20,
        66,
        145,
        161,
        177,
        193,
        9,
        35,
        51,
        82,
        240,
        21,
        98,
        114,
        209,
        10,
        22,
        36,
        52,
        225,
        37,
        241,
        23,
        24,
        25,
        26,
        38,
        39,
        40,
        41,
        42,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        130,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
      ];
      function initQuantTables(sf) {
        var YQT = [
          16,
          11,
          10,
          16,
          24,
          40,
          51,
          61,
          12,
          12,
          14,
          19,
          26,
          58,
          60,
          55,
          14,
          13,
          16,
          24,
          40,
          57,
          69,
          56,
          14,
          17,
          22,
          29,
          51,
          87,
          80,
          62,
          18,
          22,
          37,
          56,
          68,
          109,
          103,
          77,
          24,
          35,
          55,
          64,
          81,
          104,
          113,
          92,
          49,
          64,
          78,
          87,
          103,
          121,
          120,
          101,
          72,
          92,
          95,
          98,
          112,
          100,
          103,
          99
        ];
        for (var i = 0; i < 64; i++) {
          var t = ffloor((YQT[i] * sf + 50) / 100);
          if (t < 1) {
            t = 1;
          } else if (t > 255) {
            t = 255;
          }
          YTable[ZigZag[i]] = t;
        }
        var UVQT = [
          17,
          18,
          24,
          47,
          99,
          99,
          99,
          99,
          18,
          21,
          26,
          66,
          99,
          99,
          99,
          99,
          24,
          26,
          56,
          99,
          99,
          99,
          99,
          99,
          47,
          66,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99
        ];
        for (var j = 0; j < 64; j++) {
          var u = ffloor((UVQT[j] * sf + 50) / 100);
          if (u < 1) {
            u = 1;
          } else if (u > 255) {
            u = 255;
          }
          UVTable[ZigZag[j]] = u;
        }
        var aasf = [
          1,
          1.387039845,
          1.306562965,
          1.175875602,
          1,
          0.785694958,
          0.5411961,
          0.275899379
        ];
        var k = 0;
        for (var row = 0; row < 8; row++) {
          for (var col = 0; col < 8; col++) {
            fdtbl_Y[k] = 1 / (YTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
            fdtbl_UV[k] = 1 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
            k++;
          }
        }
      }
      function computeHuffmanTbl(nrcodes, std_table) {
        var codevalue = 0;
        var pos_in_table = 0;
        var HT = new Array();
        for (var k = 1; k <= 16; k++) {
          for (var j = 1; j <= nrcodes[k]; j++) {
            HT[std_table[pos_in_table]] = [];
            HT[std_table[pos_in_table]][0] = codevalue;
            HT[std_table[pos_in_table]][1] = k;
            pos_in_table++;
            codevalue++;
          }
          codevalue *= 2;
        }
        return HT;
      }
      function initHuffmanTbl() {
        YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes, std_dc_luminance_values);
        UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes, std_dc_chrominance_values);
        YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes, std_ac_luminance_values);
        UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes, std_ac_chrominance_values);
      }
      function initCategoryNumber() {
        var nrlower = 1;
        var nrupper = 2;
        for (var cat = 1; cat <= 15; cat++) {
          for (var nr = nrlower; nr < nrupper; nr++) {
            category[32767 + nr] = cat;
            bitcode[32767 + nr] = [];
            bitcode[32767 + nr][1] = cat;
            bitcode[32767 + nr][0] = nr;
          }
          for (var nrneg = -(nrupper - 1); nrneg <= -nrlower; nrneg++) {
            category[32767 + nrneg] = cat;
            bitcode[32767 + nrneg] = [];
            bitcode[32767 + nrneg][1] = cat;
            bitcode[32767 + nrneg][0] = nrupper - 1 + nrneg;
          }
          nrlower <<= 1;
          nrupper <<= 1;
        }
      }
      function initRGBYUVTable() {
        for (var i = 0; i < 256; i++) {
          RGB_YUV_TABLE[i] = 19595 * i;
          RGB_YUV_TABLE[i + 256 >> 0] = 38470 * i;
          RGB_YUV_TABLE[i + 512 >> 0] = 7471 * i + 32768;
          RGB_YUV_TABLE[i + 768 >> 0] = -11059 * i;
          RGB_YUV_TABLE[i + 1024 >> 0] = -21709 * i;
          RGB_YUV_TABLE[i + 1280 >> 0] = 32768 * i + 8421375;
          RGB_YUV_TABLE[i + 1536 >> 0] = -27439 * i;
          RGB_YUV_TABLE[i + 1792 >> 0] = -5329 * i;
        }
      }
      function writeBits(bs) {
        var value = bs[0];
        var posval = bs[1] - 1;
        while (posval >= 0) {
          if (value & 1 << posval) {
            bytenew |= 1 << bytepos;
          }
          posval--;
          bytepos--;
          if (bytepos < 0) {
            if (bytenew == 255) {
              writeByte(255);
              writeByte(0);
            } else {
              writeByte(bytenew);
            }
            bytepos = 7;
            bytenew = 0;
          }
        }
      }
      function writeByte(value) {
        byteout.push(value);
      }
      function writeWord(value) {
        writeByte(value >> 8 & 255);
        writeByte(value & 255);
      }
      function fDCTQuant(data, fdtbl) {
        var d0, d1, d2, d3, d4, d5, d6, d7;
        var dataOff = 0;
        var i;
        var I8 = 8;
        var I64 = 64;
        for (i = 0; i < I8; ++i) {
          d0 = data[dataOff];
          d1 = data[dataOff + 1];
          d2 = data[dataOff + 2];
          d3 = data[dataOff + 3];
          d4 = data[dataOff + 4];
          d5 = data[dataOff + 5];
          d6 = data[dataOff + 6];
          d7 = data[dataOff + 7];
          var tmp0 = d0 + d7;
          var tmp7 = d0 - d7;
          var tmp1 = d1 + d6;
          var tmp6 = d1 - d6;
          var tmp2 = d2 + d5;
          var tmp5 = d2 - d5;
          var tmp3 = d3 + d4;
          var tmp4 = d3 - d4;
          var tmp10 = tmp0 + tmp3;
          var tmp13 = tmp0 - tmp3;
          var tmp11 = tmp1 + tmp2;
          var tmp12 = tmp1 - tmp2;
          data[dataOff] = tmp10 + tmp11;
          data[dataOff + 4] = tmp10 - tmp11;
          var z1 = (tmp12 + tmp13) * 0.707106781;
          data[dataOff + 2] = tmp13 + z1;
          data[dataOff + 6] = tmp13 - z1;
          tmp10 = tmp4 + tmp5;
          tmp11 = tmp5 + tmp6;
          tmp12 = tmp6 + tmp7;
          var z5 = (tmp10 - tmp12) * 0.382683433;
          var z2 = 0.5411961 * tmp10 + z5;
          var z4 = 1.306562965 * tmp12 + z5;
          var z3 = tmp11 * 0.707106781;
          var z11 = tmp7 + z3;
          var z13 = tmp7 - z3;
          data[dataOff + 5] = z13 + z2;
          data[dataOff + 3] = z13 - z2;
          data[dataOff + 1] = z11 + z4;
          data[dataOff + 7] = z11 - z4;
          dataOff += 8;
        }
        dataOff = 0;
        for (i = 0; i < I8; ++i) {
          d0 = data[dataOff];
          d1 = data[dataOff + 8];
          d2 = data[dataOff + 16];
          d3 = data[dataOff + 24];
          d4 = data[dataOff + 32];
          d5 = data[dataOff + 40];
          d6 = data[dataOff + 48];
          d7 = data[dataOff + 56];
          var tmp0p2 = d0 + d7;
          var tmp7p2 = d0 - d7;
          var tmp1p2 = d1 + d6;
          var tmp6p2 = d1 - d6;
          var tmp2p2 = d2 + d5;
          var tmp5p2 = d2 - d5;
          var tmp3p2 = d3 + d4;
          var tmp4p2 = d3 - d4;
          var tmp10p2 = tmp0p2 + tmp3p2;
          var tmp13p2 = tmp0p2 - tmp3p2;
          var tmp11p2 = tmp1p2 + tmp2p2;
          var tmp12p2 = tmp1p2 - tmp2p2;
          data[dataOff] = tmp10p2 + tmp11p2;
          data[dataOff + 32] = tmp10p2 - tmp11p2;
          var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781;
          data[dataOff + 16] = tmp13p2 + z1p2;
          data[dataOff + 48] = tmp13p2 - z1p2;
          tmp10p2 = tmp4p2 + tmp5p2;
          tmp11p2 = tmp5p2 + tmp6p2;
          tmp12p2 = tmp6p2 + tmp7p2;
          var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433;
          var z2p2 = 0.5411961 * tmp10p2 + z5p2;
          var z4p2 = 1.306562965 * tmp12p2 + z5p2;
          var z3p2 = tmp11p2 * 0.707106781;
          var z11p2 = tmp7p2 + z3p2;
          var z13p2 = tmp7p2 - z3p2;
          data[dataOff + 40] = z13p2 + z2p2;
          data[dataOff + 24] = z13p2 - z2p2;
          data[dataOff + 8] = z11p2 + z4p2;
          data[dataOff + 56] = z11p2 - z4p2;
          dataOff++;
        }
        var fDCTQuant2;
        for (i = 0; i < I64; ++i) {
          fDCTQuant2 = data[i] * fdtbl[i];
          outputfDCTQuant[i] = fDCTQuant2 > 0 ? fDCTQuant2 + 0.5 | 0 : fDCTQuant2 - 0.5 | 0;
        }
        return outputfDCTQuant;
      }
      function writeAPP0() {
        writeWord(65504);
        writeWord(16);
        writeByte(74);
        writeByte(70);
        writeByte(73);
        writeByte(70);
        writeByte(0);
        writeByte(1);
        writeByte(1);
        writeByte(0);
        writeWord(1);
        writeWord(1);
        writeByte(0);
        writeByte(0);
      }
      function writeAPP1(exifBuffer) {
        if (!exifBuffer)
          return;
        writeWord(65505);
        if (exifBuffer[0] === 69 && exifBuffer[1] === 120 && exifBuffer[2] === 105 && exifBuffer[3] === 102) {
          writeWord(exifBuffer.length + 2);
        } else {
          writeWord(exifBuffer.length + 5 + 2);
          writeByte(69);
          writeByte(120);
          writeByte(105);
          writeByte(102);
          writeByte(0);
        }
        for (var i = 0; i < exifBuffer.length; i++) {
          writeByte(exifBuffer[i]);
        }
      }
      function writeSOF0(width, height) {
        writeWord(65472);
        writeWord(17);
        writeByte(8);
        writeWord(height);
        writeWord(width);
        writeByte(3);
        writeByte(1);
        writeByte(17);
        writeByte(0);
        writeByte(2);
        writeByte(17);
        writeByte(1);
        writeByte(3);
        writeByte(17);
        writeByte(1);
      }
      function writeDQT() {
        writeWord(65499);
        writeWord(132);
        writeByte(0);
        for (var i = 0; i < 64; i++) {
          writeByte(YTable[i]);
        }
        writeByte(1);
        for (var j = 0; j < 64; j++) {
          writeByte(UVTable[j]);
        }
      }
      function writeDHT() {
        writeWord(65476);
        writeWord(418);
        writeByte(0);
        for (var i = 0; i < 16; i++) {
          writeByte(std_dc_luminance_nrcodes[i + 1]);
        }
        for (var j = 0; j <= 11; j++) {
          writeByte(std_dc_luminance_values[j]);
        }
        writeByte(16);
        for (var k = 0; k < 16; k++) {
          writeByte(std_ac_luminance_nrcodes[k + 1]);
        }
        for (var l = 0; l <= 161; l++) {
          writeByte(std_ac_luminance_values[l]);
        }
        writeByte(1);
        for (var m = 0; m < 16; m++) {
          writeByte(std_dc_chrominance_nrcodes[m + 1]);
        }
        for (var n = 0; n <= 11; n++) {
          writeByte(std_dc_chrominance_values[n]);
        }
        writeByte(17);
        for (var o = 0; o < 16; o++) {
          writeByte(std_ac_chrominance_nrcodes[o + 1]);
        }
        for (var p = 0; p <= 161; p++) {
          writeByte(std_ac_chrominance_values[p]);
        }
      }
      function writeCOM(comments) {
        if (typeof comments === "undefined" || comments.constructor !== Array)
          return;
        comments.forEach((e) => {
          if (typeof e !== "string")
            return;
          writeWord(65534);
          var l = e.length;
          writeWord(l + 2);
          var i;
          for (i = 0; i < l; i++)
            writeByte(e.charCodeAt(i));
        });
      }
      function writeSOS() {
        writeWord(65498);
        writeWord(12);
        writeByte(3);
        writeByte(1);
        writeByte(0);
        writeByte(2);
        writeByte(17);
        writeByte(3);
        writeByte(17);
        writeByte(0);
        writeByte(63);
        writeByte(0);
      }
      function processDU(CDU, fdtbl, DC, HTDC, HTAC) {
        var EOB = HTAC[0];
        var M16zeroes = HTAC[240];
        var pos;
        var I16 = 16;
        var I63 = 63;
        var I64 = 64;
        var DU_DCT = fDCTQuant(CDU, fdtbl);
        for (var j = 0; j < I64; ++j) {
          DU[ZigZag[j]] = DU_DCT[j];
        }
        var Diff = DU[0] - DC;
        DC = DU[0];
        if (Diff == 0) {
          writeBits(HTDC[0]);
        } else {
          pos = 32767 + Diff;
          writeBits(HTDC[category[pos]]);
          writeBits(bitcode[pos]);
        }
        var end0pos = 63;
        for (; end0pos > 0 && DU[end0pos] == 0; end0pos--) {
        }
        ;
        if (end0pos == 0) {
          writeBits(EOB);
          return DC;
        }
        var i = 1;
        var lng;
        while (i <= end0pos) {
          var startpos = i;
          for (; DU[i] == 0 && i <= end0pos; ++i) {
          }
          var nrzeroes = i - startpos;
          if (nrzeroes >= I16) {
            lng = nrzeroes >> 4;
            for (var nrmarker = 1; nrmarker <= lng; ++nrmarker)
              writeBits(M16zeroes);
            nrzeroes = nrzeroes & 15;
          }
          pos = 32767 + DU[i];
          writeBits(HTAC[(nrzeroes << 4) + category[pos]]);
          writeBits(bitcode[pos]);
          i++;
        }
        if (end0pos != I63) {
          writeBits(EOB);
        }
        return DC;
      }
      function initCharLookupTable() {
        var sfcc = String.fromCharCode;
        for (var i = 0; i < 256; i++) {
          clt[i] = sfcc(i);
        }
      }
      this.encode = function(image, quality2) {
        var time_start = new Date().getTime();
        if (quality2)
          setQuality(quality2);
        byteout = new Array();
        bytenew = 0;
        bytepos = 7;
        writeWord(65496);
        writeAPP0();
        writeCOM(image.comments);
        writeAPP1(image.exifBuffer);
        writeDQT();
        writeSOF0(image.width, image.height);
        writeDHT();
        writeSOS();
        var DCY = 0;
        var DCU = 0;
        var DCV = 0;
        bytenew = 0;
        bytepos = 7;
        this.encode.displayName = "_encode_";
        var imageData = image.data;
        var width = image.width;
        var height = image.height;
        var quadWidth = width * 4;
        var tripleWidth = width * 3;
        var x, y = 0;
        var r, g, b;
        var start, p, col, row, pos;
        while (y < height) {
          x = 0;
          while (x < quadWidth) {
            start = quadWidth * y + x;
            p = start;
            col = -1;
            row = 0;
            for (pos = 0; pos < 64; pos++) {
              row = pos >> 3;
              col = (pos & 7) * 4;
              p = start + row * quadWidth + col;
              if (y + row >= height) {
                p -= quadWidth * (y + 1 + row - height);
              }
              if (x + col >= quadWidth) {
                p -= x + col - quadWidth + 4;
              }
              r = imageData[p++];
              g = imageData[p++];
              b = imageData[p++];
              YDU[pos] = (RGB_YUV_TABLE[r] + RGB_YUV_TABLE[g + 256 >> 0] + RGB_YUV_TABLE[b + 512 >> 0] >> 16) - 128;
              UDU[pos] = (RGB_YUV_TABLE[r + 768 >> 0] + RGB_YUV_TABLE[g + 1024 >> 0] + RGB_YUV_TABLE[b + 1280 >> 0] >> 16) - 128;
              VDU[pos] = (RGB_YUV_TABLE[r + 1280 >> 0] + RGB_YUV_TABLE[g + 1536 >> 0] + RGB_YUV_TABLE[b + 1792 >> 0] >> 16) - 128;
            }
            DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
            DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
            DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
            x += 32;
          }
          y += 8;
        }
        if (bytepos >= 0) {
          var fillbits = [];
          fillbits[1] = bytepos + 1;
          fillbits[0] = (1 << bytepos + 1) - 1;
          writeBits(fillbits);
        }
        writeWord(65497);
        if (typeof module2 === "undefined")
          return new Uint8Array(byteout);
        return Buffer.from(byteout);
        var jpegDataUri = "data:image/jpeg;base64," + btoa2(byteout.join(""));
        byteout = [];
        var duration = new Date().getTime() - time_start;
        return jpegDataUri;
      };
      function setQuality(quality2) {
        if (quality2 <= 0) {
          quality2 = 1;
        }
        if (quality2 > 100) {
          quality2 = 100;
        }
        if (currentQuality == quality2)
          return;
        var sf = 0;
        if (quality2 < 50) {
          sf = Math.floor(5e3 / quality2);
        } else {
          sf = Math.floor(200 - quality2 * 2);
        }
        initQuantTables(sf);
        currentQuality = quality2;
      }
      function init() {
        var time_start = new Date().getTime();
        if (!quality)
          quality = 50;
        initCharLookupTable();
        initHuffmanTbl();
        initCategoryNumber();
        initRGBYUVTable();
        setQuality(quality);
        var duration = new Date().getTime() - time_start;
      }
      init();
    }
    if (typeof module2 !== "undefined") {
      module2.exports = encode;
    } else if (typeof window !== "undefined") {
      window["jpeg-js"] = window["jpeg-js"] || {};
      window["jpeg-js"].encode = encode;
    }
    function encode(imgData, qu) {
      if (typeof qu === "undefined")
        qu = 50;
      var encoder = new JPEGEncoder(qu);
      var data = encoder.encode(imgData, qu);
      return {
        data,
        width: imgData.width,
        height: imgData.height
      };
    }
  }
});

// node_modules/jpeg-js/lib/decoder.js
var require_decoder = __commonJS({
  "node_modules/jpeg-js/lib/decoder.js"(exports2, module2) {
    var JpegImage = function jpegImage() {
      "use strict";
      var dctZigZag = new Int32Array([
        0,
        1,
        8,
        16,
        9,
        2,
        3,
        10,
        17,
        24,
        32,
        25,
        18,
        11,
        4,
        5,
        12,
        19,
        26,
        33,
        40,
        48,
        41,
        34,
        27,
        20,
        13,
        6,
        7,
        14,
        21,
        28,
        35,
        42,
        49,
        56,
        57,
        50,
        43,
        36,
        29,
        22,
        15,
        23,
        30,
        37,
        44,
        51,
        58,
        59,
        52,
        45,
        38,
        31,
        39,
        46,
        53,
        60,
        61,
        54,
        47,
        55,
        62,
        63
      ]);
      var dctCos1 = 4017;
      var dctSin1 = 799;
      var dctCos3 = 3406;
      var dctSin3 = 2276;
      var dctCos6 = 1567;
      var dctSin6 = 3784;
      var dctSqrt2 = 5793;
      var dctSqrt1d2 = 2896;
      function constructor() {
      }
      function buildHuffmanTable(codeLengths, values) {
        var k = 0, code = [], i, j, length = 16;
        while (length > 0 && !codeLengths[length - 1])
          length--;
        code.push({ children: [], index: 0 });
        var p = code[0], q;
        for (i = 0; i < length; i++) {
          for (j = 0; j < codeLengths[i]; j++) {
            p = code.pop();
            p.children[p.index] = values[k];
            while (p.index > 0) {
              if (code.length === 0)
                throw new Error("Could not recreate Huffman Table");
              p = code.pop();
            }
            p.index++;
            code.push(p);
            while (code.length <= i) {
              code.push(q = { children: [], index: 0 });
              p.children[p.index] = q.children;
              p = q;
            }
            k++;
          }
          if (i + 1 < length) {
            code.push(q = { children: [], index: 0 });
            p.children[p.index] = q.children;
            p = q;
          }
        }
        return code[0].children;
      }
      function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, opts) {
        var precision = frame.precision;
        var samplesPerLine = frame.samplesPerLine;
        var scanLines = frame.scanLines;
        var mcusPerLine = frame.mcusPerLine;
        var progressive = frame.progressive;
        var maxH = frame.maxH, maxV = frame.maxV;
        var startOffset = offset, bitsData = 0, bitsCount = 0;
        function readBit() {
          if (bitsCount > 0) {
            bitsCount--;
            return bitsData >> bitsCount & 1;
          }
          bitsData = data[offset++];
          if (bitsData == 255) {
            var nextByte = data[offset++];
            if (nextByte) {
              throw new Error("unexpected marker: " + (bitsData << 8 | nextByte).toString(16));
            }
          }
          bitsCount = 7;
          return bitsData >>> 7;
        }
        function decodeHuffman(tree) {
          var node = tree, bit;
          while ((bit = readBit()) !== null) {
            node = node[bit];
            if (typeof node === "number")
              return node;
            if (typeof node !== "object")
              throw new Error("invalid huffman sequence");
          }
          return null;
        }
        function receive(length) {
          var n2 = 0;
          while (length > 0) {
            var bit = readBit();
            if (bit === null)
              return;
            n2 = n2 << 1 | bit;
            length--;
          }
          return n2;
        }
        function receiveAndExtend(length) {
          var n2 = receive(length);
          if (n2 >= 1 << length - 1)
            return n2;
          return n2 + (-1 << length) + 1;
        }
        function decodeBaseline(component2, zz) {
          var t = decodeHuffman(component2.huffmanTableDC);
          var diff = t === 0 ? 0 : receiveAndExtend(t);
          zz[0] = component2.pred += diff;
          var k2 = 1;
          while (k2 < 64) {
            var rs = decodeHuffman(component2.huffmanTableAC);
            var s = rs & 15, r = rs >> 4;
            if (s === 0) {
              if (r < 15)
                break;
              k2 += 16;
              continue;
            }
            k2 += r;
            var z = dctZigZag[k2];
            zz[z] = receiveAndExtend(s);
            k2++;
          }
        }
        function decodeDCFirst(component2, zz) {
          var t = decodeHuffman(component2.huffmanTableDC);
          var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
          zz[0] = component2.pred += diff;
        }
        function decodeDCSuccessive(component2, zz) {
          zz[0] |= readBit() << successive;
        }
        var eobrun = 0;
        function decodeACFirst(component2, zz) {
          if (eobrun > 0) {
            eobrun--;
            return;
          }
          var k2 = spectralStart, e = spectralEnd;
          while (k2 <= e) {
            var rs = decodeHuffman(component2.huffmanTableAC);
            var s = rs & 15, r = rs >> 4;
            if (s === 0) {
              if (r < 15) {
                eobrun = receive(r) + (1 << r) - 1;
                break;
              }
              k2 += 16;
              continue;
            }
            k2 += r;
            var z = dctZigZag[k2];
            zz[z] = receiveAndExtend(s) * (1 << successive);
            k2++;
          }
        }
        var successiveACState = 0, successiveACNextValue;
        function decodeACSuccessive(component2, zz) {
          var k2 = spectralStart, e = spectralEnd, r = 0;
          while (k2 <= e) {
            var z = dctZigZag[k2];
            var direction = zz[z] < 0 ? -1 : 1;
            switch (successiveACState) {
              case 0:
                var rs = decodeHuffman(component2.huffmanTableAC);
                var s = rs & 15, r = rs >> 4;
                if (s === 0) {
                  if (r < 15) {
                    eobrun = receive(r) + (1 << r);
                    successiveACState = 4;
                  } else {
                    r = 16;
                    successiveACState = 1;
                  }
                } else {
                  if (s !== 1)
                    throw new Error("invalid ACn encoding");
                  successiveACNextValue = receiveAndExtend(s);
                  successiveACState = r ? 2 : 3;
                }
                continue;
              case 1:
              case 2:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                else {
                  r--;
                  if (r === 0)
                    successiveACState = successiveACState == 2 ? 3 : 0;
                }
                break;
              case 3:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                else {
                  zz[z] = successiveACNextValue << successive;
                  successiveACState = 0;
                }
                break;
              case 4:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                break;
            }
            k2++;
          }
          if (successiveACState === 4) {
            eobrun--;
            if (eobrun === 0)
              successiveACState = 0;
          }
        }
        function decodeMcu(component2, decode2, mcu2, row, col) {
          var mcuRow = mcu2 / mcusPerLine | 0;
          var mcuCol = mcu2 % mcusPerLine;
          var blockRow = mcuRow * component2.v + row;
          var blockCol = mcuCol * component2.h + col;
          if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
            return;
          decode2(component2, component2.blocks[blockRow][blockCol]);
        }
        function decodeBlock(component2, decode2, mcu2) {
          var blockRow = mcu2 / component2.blocksPerLine | 0;
          var blockCol = mcu2 % component2.blocksPerLine;
          if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
            return;
          decode2(component2, component2.blocks[blockRow][blockCol]);
        }
        var componentsLength = components.length;
        var component, i, j, k, n;
        var decodeFn;
        if (progressive) {
          if (spectralStart === 0)
            decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
          else
            decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
        } else {
          decodeFn = decodeBaseline;
        }
        var mcu = 0, marker;
        var mcuExpected;
        if (componentsLength == 1) {
          mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
        } else {
          mcuExpected = mcusPerLine * frame.mcusPerColumn;
        }
        if (!resetInterval)
          resetInterval = mcuExpected;
        var h, v;
        while (mcu < mcuExpected) {
          for (i = 0; i < componentsLength; i++)
            components[i].pred = 0;
          eobrun = 0;
          if (componentsLength == 1) {
            component = components[0];
            for (n = 0; n < resetInterval; n++) {
              decodeBlock(component, decodeFn, mcu);
              mcu++;
            }
          } else {
            for (n = 0; n < resetInterval; n++) {
              for (i = 0; i < componentsLength; i++) {
                component = components[i];
                h = component.h;
                v = component.v;
                for (j = 0; j < v; j++) {
                  for (k = 0; k < h; k++) {
                    decodeMcu(component, decodeFn, mcu, j, k);
                  }
                }
              }
              mcu++;
              if (mcu === mcuExpected)
                break;
            }
          }
          if (mcu === mcuExpected) {
            do {
              if (data[offset] === 255) {
                if (data[offset + 1] !== 0) {
                  break;
                }
              }
              offset += 1;
            } while (offset < data.length - 2);
          }
          bitsCount = 0;
          marker = data[offset] << 8 | data[offset + 1];
          if (marker < 65280) {
            throw new Error("marker was not found");
          }
          if (marker >= 65488 && marker <= 65495) {
            offset += 2;
          } else
            break;
        }
        return offset - startOffset;
      }
      function buildComponentData(frame, component) {
        var lines = [];
        var blocksPerLine = component.blocksPerLine;
        var blocksPerColumn = component.blocksPerColumn;
        var samplesPerLine = blocksPerLine << 3;
        var R = new Int32Array(64), r = new Uint8Array(64);
        function quantizeAndInverse(zz, dataOut, dataIn) {
          var qt = component.quantizationTable;
          var v0, v1, v2, v3, v4, v5, v6, v7, t;
          var p = dataIn;
          var i2;
          for (i2 = 0; i2 < 64; i2++)
            p[i2] = zz[i2] * qt[i2];
          for (i2 = 0; i2 < 8; ++i2) {
            var row = 8 * i2;
            if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 && p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 && p[7 + row] == 0) {
              t = dctSqrt2 * p[0 + row] + 512 >> 10;
              p[0 + row] = t;
              p[1 + row] = t;
              p[2 + row] = t;
              p[3 + row] = t;
              p[4 + row] = t;
              p[5 + row] = t;
              p[6 + row] = t;
              p[7 + row] = t;
              continue;
            }
            v0 = dctSqrt2 * p[0 + row] + 128 >> 8;
            v1 = dctSqrt2 * p[4 + row] + 128 >> 8;
            v2 = p[2 + row];
            v3 = p[6 + row];
            v4 = dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128 >> 8;
            v7 = dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128 >> 8;
            v5 = p[3 + row] << 4;
            v6 = p[5 + row] << 4;
            t = v0 - v1 + 1 >> 1;
            v0 = v0 + v1 + 1 >> 1;
            v1 = t;
            t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
            v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
            v3 = t;
            t = v4 - v6 + 1 >> 1;
            v4 = v4 + v6 + 1 >> 1;
            v6 = t;
            t = v7 + v5 + 1 >> 1;
            v5 = v7 - v5 + 1 >> 1;
            v7 = t;
            t = v0 - v3 + 1 >> 1;
            v0 = v0 + v3 + 1 >> 1;
            v3 = t;
            t = v1 - v2 + 1 >> 1;
            v1 = v1 + v2 + 1 >> 1;
            v2 = t;
            t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
            v7 = t;
            t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
            v6 = t;
            p[0 + row] = v0 + v7;
            p[7 + row] = v0 - v7;
            p[1 + row] = v1 + v6;
            p[6 + row] = v1 - v6;
            p[2 + row] = v2 + v5;
            p[5 + row] = v2 - v5;
            p[3 + row] = v3 + v4;
            p[4 + row] = v3 - v4;
          }
          for (i2 = 0; i2 < 8; ++i2) {
            var col = i2;
            if (p[1 * 8 + col] == 0 && p[2 * 8 + col] == 0 && p[3 * 8 + col] == 0 && p[4 * 8 + col] == 0 && p[5 * 8 + col] == 0 && p[6 * 8 + col] == 0 && p[7 * 8 + col] == 0) {
              t = dctSqrt2 * dataIn[i2 + 0] + 8192 >> 14;
              p[0 * 8 + col] = t;
              p[1 * 8 + col] = t;
              p[2 * 8 + col] = t;
              p[3 * 8 + col] = t;
              p[4 * 8 + col] = t;
              p[5 * 8 + col] = t;
              p[6 * 8 + col] = t;
              p[7 * 8 + col] = t;
              continue;
            }
            v0 = dctSqrt2 * p[0 * 8 + col] + 2048 >> 12;
            v1 = dctSqrt2 * p[4 * 8 + col] + 2048 >> 12;
            v2 = p[2 * 8 + col];
            v3 = p[6 * 8 + col];
            v4 = dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048 >> 12;
            v7 = dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048 >> 12;
            v5 = p[3 * 8 + col];
            v6 = p[5 * 8 + col];
            t = v0 - v1 + 1 >> 1;
            v0 = v0 + v1 + 1 >> 1;
            v1 = t;
            t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
            v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
            v3 = t;
            t = v4 - v6 + 1 >> 1;
            v4 = v4 + v6 + 1 >> 1;
            v6 = t;
            t = v7 + v5 + 1 >> 1;
            v5 = v7 - v5 + 1 >> 1;
            v7 = t;
            t = v0 - v3 + 1 >> 1;
            v0 = v0 + v3 + 1 >> 1;
            v3 = t;
            t = v1 - v2 + 1 >> 1;
            v1 = v1 + v2 + 1 >> 1;
            v2 = t;
            t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
            v7 = t;
            t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
            v6 = t;
            p[0 * 8 + col] = v0 + v7;
            p[7 * 8 + col] = v0 - v7;
            p[1 * 8 + col] = v1 + v6;
            p[6 * 8 + col] = v1 - v6;
            p[2 * 8 + col] = v2 + v5;
            p[5 * 8 + col] = v2 - v5;
            p[3 * 8 + col] = v3 + v4;
            p[4 * 8 + col] = v3 - v4;
          }
          for (i2 = 0; i2 < 64; ++i2) {
            var sample2 = 128 + (p[i2] + 8 >> 4);
            dataOut[i2] = sample2 < 0 ? 0 : sample2 > 255 ? 255 : sample2;
          }
        }
        requestMemoryAllocation(samplesPerLine * blocksPerColumn * 8);
        var i, j;
        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
          var scanLine = blockRow << 3;
          for (i = 0; i < 8; i++)
            lines.push(new Uint8Array(samplesPerLine));
          for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
            quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);
            var offset = 0, sample = blockCol << 3;
            for (j = 0; j < 8; j++) {
              var line = lines[scanLine + j];
              for (i = 0; i < 8; i++)
                line[sample + i] = r[offset++];
            }
          }
        }
        return lines;
      }
      function clampTo8bit(a) {
        return a < 0 ? 0 : a > 255 ? 255 : a;
      }
      constructor.prototype = {
        load: function load(path) {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", path, true);
          xhr.responseType = "arraybuffer";
          xhr.onload = function() {
            var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
            this.parse(data);
            if (this.onload)
              this.onload();
          }.bind(this);
          xhr.send(null);
        },
        parse: function parse(data) {
          var maxResolutionInPixels = this.opts.maxResolutionInMP * 1e3 * 1e3;
          var offset = 0, length = data.length;
          function readUint16() {
            var value = data[offset] << 8 | data[offset + 1];
            offset += 2;
            return value;
          }
          function readDataBlock() {
            var length2 = readUint16();
            var array = data.subarray(offset, offset + length2 - 2);
            offset += array.length;
            return array;
          }
          function prepareComponents(frame2) {
            var maxH2 = 1, maxV2 = 1;
            var component2, componentId2;
            for (componentId2 in frame2.components) {
              if (frame2.components.hasOwnProperty(componentId2)) {
                component2 = frame2.components[componentId2];
                if (maxH2 < component2.h)
                  maxH2 = component2.h;
                if (maxV2 < component2.v)
                  maxV2 = component2.v;
              }
            }
            var mcusPerLine = Math.ceil(frame2.samplesPerLine / 8 / maxH2);
            var mcusPerColumn = Math.ceil(frame2.scanLines / 8 / maxV2);
            for (componentId2 in frame2.components) {
              if (frame2.components.hasOwnProperty(componentId2)) {
                component2 = frame2.components[componentId2];
                var blocksPerLine = Math.ceil(Math.ceil(frame2.samplesPerLine / 8) * component2.h / maxH2);
                var blocksPerColumn = Math.ceil(Math.ceil(frame2.scanLines / 8) * component2.v / maxV2);
                var blocksPerLineForMcu = mcusPerLine * component2.h;
                var blocksPerColumnForMcu = mcusPerColumn * component2.v;
                var blocksToAllocate = blocksPerColumnForMcu * blocksPerLineForMcu;
                var blocks = [];
                requestMemoryAllocation(blocksToAllocate * 256);
                for (var i2 = 0; i2 < blocksPerColumnForMcu; i2++) {
                  var row = [];
                  for (var j2 = 0; j2 < blocksPerLineForMcu; j2++)
                    row.push(new Int32Array(64));
                  blocks.push(row);
                }
                component2.blocksPerLine = blocksPerLine;
                component2.blocksPerColumn = blocksPerColumn;
                component2.blocks = blocks;
              }
            }
            frame2.maxH = maxH2;
            frame2.maxV = maxV2;
            frame2.mcusPerLine = mcusPerLine;
            frame2.mcusPerColumn = mcusPerColumn;
          }
          var jfif = null;
          var adobe = null;
          var pixels = null;
          var frame, resetInterval;
          var quantizationTables = [], frames = [];
          var huffmanTablesAC = [], huffmanTablesDC = [];
          var fileMarker = readUint16();
          var malformedDataOffset = -1;
          this.comments = [];
          if (fileMarker != 65496) {
            throw new Error("SOI not found");
          }
          fileMarker = readUint16();
          while (fileMarker != 65497) {
            var i, j, l;
            switch (fileMarker) {
              case 65280:
                break;
              case 65504:
              case 65505:
              case 65506:
              case 65507:
              case 65508:
              case 65509:
              case 65510:
              case 65511:
              case 65512:
              case 65513:
              case 65514:
              case 65515:
              case 65516:
              case 65517:
              case 65518:
              case 65519:
              case 65534:
                var appData = readDataBlock();
                if (fileMarker === 65534) {
                  var comment = String.fromCharCode.apply(null, appData);
                  this.comments.push(comment);
                }
                if (fileMarker === 65504) {
                  if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
                    jfif = {
                      version: { major: appData[5], minor: appData[6] },
                      densityUnits: appData[7],
                      xDensity: appData[8] << 8 | appData[9],
                      yDensity: appData[10] << 8 | appData[11],
                      thumbWidth: appData[12],
                      thumbHeight: appData[13],
                      thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                    };
                  }
                }
                if (fileMarker === 65505) {
                  if (appData[0] === 69 && appData[1] === 120 && appData[2] === 105 && appData[3] === 102 && appData[4] === 0) {
                    this.exifBuffer = appData.subarray(5, appData.length);
                  }
                }
                if (fileMarker === 65518) {
                  if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101 && appData[5] === 0) {
                    adobe = {
                      version: appData[6],
                      flags0: appData[7] << 8 | appData[8],
                      flags1: appData[9] << 8 | appData[10],
                      transformCode: appData[11]
                    };
                  }
                }
                break;
              case 65499:
                var quantizationTablesLength = readUint16();
                var quantizationTablesEnd = quantizationTablesLength + offset - 2;
                while (offset < quantizationTablesEnd) {
                  var quantizationTableSpec = data[offset++];
                  requestMemoryAllocation(64 * 4);
                  var tableData = new Int32Array(64);
                  if (quantizationTableSpec >> 4 === 0) {
                    for (j = 0; j < 64; j++) {
                      var z = dctZigZag[j];
                      tableData[z] = data[offset++];
                    }
                  } else if (quantizationTableSpec >> 4 === 1) {
                    for (j = 0; j < 64; j++) {
                      var z = dctZigZag[j];
                      tableData[z] = readUint16();
                    }
                  } else
                    throw new Error("DQT: invalid table spec");
                  quantizationTables[quantizationTableSpec & 15] = tableData;
                }
                break;
              case 65472:
              case 65473:
              case 65474:
                readUint16();
                frame = {};
                frame.extended = fileMarker === 65473;
                frame.progressive = fileMarker === 65474;
                frame.precision = data[offset++];
                frame.scanLines = readUint16();
                frame.samplesPerLine = readUint16();
                frame.components = {};
                frame.componentsOrder = [];
                var pixelsInFrame = frame.scanLines * frame.samplesPerLine;
                if (pixelsInFrame > maxResolutionInPixels) {
                  var exceededAmount = Math.ceil((pixelsInFrame - maxResolutionInPixels) / 1e6);
                  throw new Error(`maxResolutionInMP limit exceeded by ${exceededAmount}MP`);
                }
                var componentsCount = data[offset++], componentId;
                var maxH = 0, maxV = 0;
                for (i = 0; i < componentsCount; i++) {
                  componentId = data[offset];
                  var h = data[offset + 1] >> 4;
                  var v = data[offset + 1] & 15;
                  var qId = data[offset + 2];
                  if (h <= 0 || v <= 0) {
                    throw new Error("Invalid sampling factor, expected values above 0");
                  }
                  frame.componentsOrder.push(componentId);
                  frame.components[componentId] = {
                    h,
                    v,
                    quantizationIdx: qId
                  };
                  offset += 3;
                }
                prepareComponents(frame);
                frames.push(frame);
                break;
              case 65476:
                var huffmanLength = readUint16();
                for (i = 2; i < huffmanLength; ) {
                  var huffmanTableSpec = data[offset++];
                  var codeLengths = new Uint8Array(16);
                  var codeLengthSum = 0;
                  for (j = 0; j < 16; j++, offset++) {
                    codeLengthSum += codeLengths[j] = data[offset];
                  }
                  requestMemoryAllocation(16 + codeLengthSum);
                  var huffmanValues = new Uint8Array(codeLengthSum);
                  for (j = 0; j < codeLengthSum; j++, offset++)
                    huffmanValues[j] = data[offset];
                  i += 17 + codeLengthSum;
                  (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
                }
                break;
              case 65501:
                readUint16();
                resetInterval = readUint16();
                break;
              case 65500:
                readUint16();
                readUint16();
                break;
              case 65498:
                var scanLength = readUint16();
                var selectorsCount = data[offset++];
                var components = [], component;
                for (i = 0; i < selectorsCount; i++) {
                  component = frame.components[data[offset++]];
                  var tableSpec = data[offset++];
                  component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
                  component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
                  components.push(component);
                }
                var spectralStart = data[offset++];
                var spectralEnd = data[offset++];
                var successiveApproximation = data[offset++];
                var processed = decodeScan(
                  data,
                  offset,
                  frame,
                  components,
                  resetInterval,
                  spectralStart,
                  spectralEnd,
                  successiveApproximation >> 4,
                  successiveApproximation & 15,
                  this.opts
                );
                offset += processed;
                break;
              case 65535:
                if (data[offset] !== 255) {
                  offset--;
                }
                break;
              default:
                if (data[offset - 3] == 255 && data[offset - 2] >= 192 && data[offset - 2] <= 254) {
                  offset -= 3;
                  break;
                } else if (fileMarker === 224 || fileMarker == 225) {
                  if (malformedDataOffset !== -1) {
                    throw new Error(`first unknown JPEG marker at offset ${malformedDataOffset.toString(16)}, second unknown JPEG marker ${fileMarker.toString(16)} at offset ${(offset - 1).toString(16)}`);
                  }
                  malformedDataOffset = offset - 1;
                  const nextOffset = readUint16();
                  if (data[offset + nextOffset - 2] === 255) {
                    offset += nextOffset - 2;
                    break;
                  }
                }
                throw new Error("unknown JPEG marker " + fileMarker.toString(16));
            }
            fileMarker = readUint16();
          }
          if (frames.length != 1)
            throw new Error("only single frame JPEGs supported");
          for (var i = 0; i < frames.length; i++) {
            var cp = frames[i].components;
            for (var j in cp) {
              cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];
              delete cp[j].quantizationIdx;
            }
          }
          this.width = frame.samplesPerLine;
          this.height = frame.scanLines;
          this.jfif = jfif;
          this.adobe = adobe;
          this.components = [];
          for (var i = 0; i < frame.componentsOrder.length; i++) {
            var component = frame.components[frame.componentsOrder[i]];
            this.components.push({
              lines: buildComponentData(frame, component),
              scaleX: component.h / frame.maxH,
              scaleY: component.v / frame.maxV
            });
          }
        },
        getData: function getData(width, height) {
          var scaleX = this.width / width, scaleY = this.height / height;
          var component1, component2, component3, component4;
          var component1Line, component2Line, component3Line, component4Line;
          var x, y;
          var offset = 0;
          var Y, Cb, Cr, K, C, M, Ye, R, G, B;
          var colorTransform;
          var dataLength = width * height * this.components.length;
          requestMemoryAllocation(dataLength);
          var data = new Uint8Array(dataLength);
          switch (this.components.length) {
            case 1:
              component1 = this.components[0];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  data[offset++] = Y;
                }
              }
              break;
            case 2:
              component1 = this.components[0];
              component2 = this.components[1];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  data[offset++] = Y;
                  Y = component2Line[0 | x * component2.scaleX * scaleX];
                  data[offset++] = Y;
                }
              }
              break;
            case 3:
              colorTransform = true;
              if (this.adobe && this.adobe.transformCode)
                colorTransform = true;
              else if (typeof this.opts.colorTransform !== "undefined")
                colorTransform = !!this.opts.colorTransform;
              component1 = this.components[0];
              component2 = this.components[1];
              component3 = this.components[2];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  if (!colorTransform) {
                    R = component1Line[0 | x * component1.scaleX * scaleX];
                    G = component2Line[0 | x * component2.scaleX * scaleX];
                    B = component3Line[0 | x * component3.scaleX * scaleX];
                  } else {
                    Y = component1Line[0 | x * component1.scaleX * scaleX];
                    Cb = component2Line[0 | x * component2.scaleX * scaleX];
                    Cr = component3Line[0 | x * component3.scaleX * scaleX];
                    R = clampTo8bit(Y + 1.402 * (Cr - 128));
                    G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                    B = clampTo8bit(Y + 1.772 * (Cb - 128));
                  }
                  data[offset++] = R;
                  data[offset++] = G;
                  data[offset++] = B;
                }
              }
              break;
            case 4:
              if (!this.adobe)
                throw new Error("Unsupported color mode (4 components)");
              colorTransform = false;
              if (this.adobe && this.adobe.transformCode)
                colorTransform = true;
              else if (typeof this.opts.colorTransform !== "undefined")
                colorTransform = !!this.opts.colorTransform;
              component1 = this.components[0];
              component2 = this.components[1];
              component3 = this.components[2];
              component4 = this.components[3];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                component4Line = component4.lines[0 | y * component4.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  if (!colorTransform) {
                    C = component1Line[0 | x * component1.scaleX * scaleX];
                    M = component2Line[0 | x * component2.scaleX * scaleX];
                    Ye = component3Line[0 | x * component3.scaleX * scaleX];
                    K = component4Line[0 | x * component4.scaleX * scaleX];
                  } else {
                    Y = component1Line[0 | x * component1.scaleX * scaleX];
                    Cb = component2Line[0 | x * component2.scaleX * scaleX];
                    Cr = component3Line[0 | x * component3.scaleX * scaleX];
                    K = component4Line[0 | x * component4.scaleX * scaleX];
                    C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));
                    M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                    Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));
                  }
                  data[offset++] = 255 - C;
                  data[offset++] = 255 - M;
                  data[offset++] = 255 - Ye;
                  data[offset++] = 255 - K;
                }
              }
              break;
            default:
              throw new Error("Unsupported color mode");
          }
          return data;
        },
        copyToImageData: function copyToImageData(imageData, formatAsRGBA) {
          var width = imageData.width, height = imageData.height;
          var imageDataArray = imageData.data;
          var data = this.getData(width, height);
          var i = 0, j = 0, x, y;
          var Y, K, C, M, R, G, B;
          switch (this.components.length) {
            case 1:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  Y = data[i++];
                  imageDataArray[j++] = Y;
                  imageDataArray[j++] = Y;
                  imageDataArray[j++] = Y;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            case 3:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  R = data[i++];
                  G = data[i++];
                  B = data[i++];
                  imageDataArray[j++] = R;
                  imageDataArray[j++] = G;
                  imageDataArray[j++] = B;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            case 4:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  C = data[i++];
                  M = data[i++];
                  Y = data[i++];
                  K = data[i++];
                  R = 255 - clampTo8bit(C * (1 - K / 255) + K);
                  G = 255 - clampTo8bit(M * (1 - K / 255) + K);
                  B = 255 - clampTo8bit(Y * (1 - K / 255) + K);
                  imageDataArray[j++] = R;
                  imageDataArray[j++] = G;
                  imageDataArray[j++] = B;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            default:
              throw new Error("Unsupported color mode");
          }
        }
      };
      var totalBytesAllocated = 0;
      var maxMemoryUsageBytes = 0;
      function requestMemoryAllocation(increaseAmount = 0) {
        var totalMemoryImpactBytes = totalBytesAllocated + increaseAmount;
        if (totalMemoryImpactBytes > maxMemoryUsageBytes) {
          var exceededAmount = Math.ceil((totalMemoryImpactBytes - maxMemoryUsageBytes) / 1024 / 1024);
          throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${exceededAmount}MB`);
        }
        totalBytesAllocated = totalMemoryImpactBytes;
      }
      constructor.resetMaxMemoryUsage = function(maxMemoryUsageBytes_) {
        totalBytesAllocated = 0;
        maxMemoryUsageBytes = maxMemoryUsageBytes_;
      };
      constructor.getBytesAllocated = function() {
        return totalBytesAllocated;
      };
      constructor.requestMemoryAllocation = requestMemoryAllocation;
      return constructor;
    }();
    if (typeof module2 !== "undefined") {
      module2.exports = decode;
    } else if (typeof window !== "undefined") {
      window["jpeg-js"] = window["jpeg-js"] || {};
      window["jpeg-js"].decode = decode;
    }
    function decode(jpegData, userOpts = {}) {
      var defaultOpts = {
        // "undefined" means "Choose whether to transform colors based on the images color model."
        colorTransform: void 0,
        useTArray: false,
        formatAsRGBA: true,
        tolerantDecoding: true,
        maxResolutionInMP: 100,
        // Don't decode more than 100 megapixels
        maxMemoryUsageInMB: 512
        // Don't decode if memory footprint is more than 512MB
      };
      var opts = { ...defaultOpts, ...userOpts };
      var arr = new Uint8Array(jpegData);
      var decoder = new JpegImage();
      decoder.opts = opts;
      JpegImage.resetMaxMemoryUsage(opts.maxMemoryUsageInMB * 1024 * 1024);
      decoder.parse(arr);
      var channels = opts.formatAsRGBA ? 4 : 3;
      var bytesNeeded = decoder.width * decoder.height * channels;
      try {
        JpegImage.requestMemoryAllocation(bytesNeeded);
        var image = {
          width: decoder.width,
          height: decoder.height,
          exifBuffer: decoder.exifBuffer,
          data: opts.useTArray ? new Uint8Array(bytesNeeded) : Buffer.alloc(bytesNeeded)
        };
        if (decoder.comments.length > 0) {
          image["comments"] = decoder.comments;
        }
      } catch (err) {
        if (err instanceof RangeError) {
          throw new Error("Could not allocate enough memory for the image. Required: " + bytesNeeded);
        }
        if (err instanceof ReferenceError) {
          if (err.message === "Buffer is not defined") {
            throw new Error("Buffer is not globally defined in this environment. Consider setting useTArray to true");
          }
        }
        throw err;
      }
      decoder.copyToImageData(image, opts.formatAsRGBA);
      return image;
    }
  }
});

// node_modules/jpeg-js/index.js
var require_jpeg_js = __commonJS({
  "node_modules/jpeg-js/index.js"(exports2, module2) {
    var encode = require_encoder();
    var decode = require_decoder();
    module2.exports = {
      encode,
      decode
    };
  }
});

// node_modules/image-js/lib/util/base64.js
var require_base64 = __commonJS({
  "node_modules/image-js/lib/util/base64.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.decode = decode;
    exports2.encode = encode;
    exports2.toBase64URL = toBase64URL;
    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var lookup = new Uint8Array(256);
    for (let i = 0; i < chars.length; i++) {
      lookup[chars.charCodeAt(i)] = i;
    }
    function encode(bytes) {
      let i;
      let len = bytes.length;
      let base64 = "";
      for (i = 0; i < len; i += 3) {
        base64 += chars[bytes[i] >> 2];
        base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
        base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
        base64 += chars[bytes[i + 2] & 63];
      }
      if (len % 3 === 2) {
        base64 = `${base64.substring(0, base64.length - 1)}=`;
      } else if (len % 3 === 1) {
        base64 = `${base64.substring(0, base64.length - 2)}==`;
      }
      return base64;
    }
    function decode(base64) {
      let bufferLength = base64.length * 0.75;
      let len = base64.length;
      let p = 0;
      let encoded1, encoded2, encoded3, encoded4;
      if (base64[base64.length - 1] === "=") {
        bufferLength--;
        if (base64[base64.length - 2] === "=") {
          bufferLength--;
        }
      }
      const bytes = new Uint8Array(bufferLength);
      for (let i = 0; i < len; i += 4) {
        encoded1 = lookup[base64.charCodeAt(i)];
        encoded2 = lookup[base64.charCodeAt(i + 1)];
        encoded3 = lookup[base64.charCodeAt(i + 2)];
        encoded4 = lookup[base64.charCodeAt(i + 3)];
        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }
      return bytes;
    }
    function toBase64URL(u8, type) {
      const base64 = encode(u8);
      return `data:${type};base64,${base64}`;
    }
  }
});

// node_modules/image-js/lib/image/core/environment.js
var require_environment = __commonJS({
  "node_modules/image-js/lib/image/core/environment.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createCanvas = exports2.ImageData = exports2.DOMImage = void 0;
    Object.defineProperty(exports2, "createWriteStream", {
      enumerable: true,
      get: function() {
        return _fs.createWriteStream;
      }
    });
    exports2.env = void 0;
    exports2.fetchBinary = fetchBinary;
    Object.defineProperty(exports2, "writeFile", {
      enumerable: true,
      get: function() {
        return _fs.writeFile;
      }
    });
    var _fs = require("fs");
    var message = "requires the canvas library. Install it with `npm install canvas@next`.";
    var createCanvas = exports2.createCanvas = void 0;
    var DOMImage = exports2.DOMImage = void 0;
    var ImageData = exports2.ImageData = void 0;
    try {
      const canvas = require("canvas");
      exports2.createCanvas = createCanvas = canvas.createCanvas;
      exports2.DOMImage = DOMImage = canvas.Image;
      exports2.ImageData = ImageData = canvas.ImageData;
    } catch (e) {
      exports2.createCanvas = createCanvas = function() {
        throw new Error(`createCanvas ${message}`);
      };
      exports2.DOMImage = DOMImage = function() {
        throw new Error(`DOMImage ${message}`);
      };
      exports2.ImageData = ImageData = function() {
        throw new Error(`ImageData ${message}`);
      };
    }
    var env = exports2.env = "node";
    function fetchBinary(path) {
      return new Promise(function(resolve2, reject2) {
        (0, _fs.readFile)(path, function(err, data) {
          if (err)
            reject2(err);
          else
            resolve2(data.buffer);
        });
      });
    }
  }
});

// node_modules/image-js/lib/image/core/mediaTypes.js
var require_mediaTypes = __commonJS({
  "node_modules/image-js/lib/image/core/mediaTypes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getType = getType;
    function getType(type) {
      if (!type.includes("/")) {
        type = `image/${type}`;
      }
      return type;
    }
  }
});

// node_modules/image-js/lib/image/core/export.js
var require_export = __commonJS({
  "node_modules/image-js/lib/image/core/export.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = setExportMethods;
    var _blobUtil = require_blob_util_cjs();
    var _fastBmp = require_src();
    var _fastPng = require_lib();
    var _jpegJs = require_jpeg_js();
    var _base = require_base64();
    var _environment = require_environment();
    var _mediaTypes = require_mediaTypes();
    function encodeJpeg(image, options = {}) {
      const data = {
        width: image.width,
        height: image.height,
        data: image.getRGBAData()
      };
      return (0, _jpegJs.encode)(data, options.quality).data;
    }
    function encodePng(image, options) {
      const data = {
        width: image.width,
        height: image.height,
        channels: image.channels,
        depth: image.bitDepth,
        data: image.data
      };
      if (data.depth === 1 || data.depth === 32) {
        data.depth = 8;
        data.channels = 4;
        data.data = image.getRGBAData();
      }
      return (0, _fastPng.encode)(data, options);
    }
    var exportMethods = {
      /**
       * Save the image to disk (Node.js only)
       * @memberof Image
       * @instance
       * @param {string} path
       * @param {object} [options]
       * @param {string} [options.format] - One of: png, jpg, bmp (limited support for bmp). If not specified will try to infer from filename
       * @param {boolean} [options.useCanvas=false] - Force use of the canvas API to save the image instead of a JavaScript implementation
       * @param {object} [options.encoder] - Specify options for the encoder if applicable.
       * @return {Promise} - Resolves when the file is fully written
       */
      save(path, options = {}) {
        const {
          useCanvas = false,
          encoder: encoderOptions = void 0
        } = options;
        let {
          format
        } = options;
        if (!format) {
          const m = /\.(?<format>[a-zA-Z]+)$/.exec(path);
          if (m) {
            format = m.groups.format.toLowerCase();
          }
        }
        if (!format) {
          throw new Error("file format not provided");
        }
        return new Promise((resolve2, reject2) => {
          let stream2, buffer;
          switch (format.toLowerCase()) {
            case "png": {
              if (useCanvas) {
                stream2 = this.getCanvas().pngStream();
              } else {
                buffer = encodePng(this, encoderOptions);
              }
              break;
            }
            case "jpg":
            case "jpeg":
              if (useCanvas) {
                stream2 = this.getCanvas().jpegStream();
              } else {
                buffer = encodeJpeg(this, encoderOptions);
              }
              break;
            case "bmp":
              buffer = (0, _fastBmp.encode)(this, encoderOptions);
              break;
            default:
              throw new RangeError(`invalid output format: ${format}`);
          }
          if (stream2) {
            let out = (0, _environment.createWriteStream)(path);
            out.on("finish", resolve2);
            out.on("error", reject2);
            stream2.pipe(out);
          } else if (buffer) {
            (0, _environment.writeFile)(path, buffer, (err) => {
              if (err) {
                reject2(err);
                return;
              }
              resolve2();
            });
          }
        });
      },
      /**
       * Creates a dataURL string from the image.
       * @memberof Image
       * @instance
       * @param {string} [type='image/png']
       * @param {object} [options]
       * @param {boolean} [options.useCanvas=false] - Force use of the canvas API to save the image instead of JavaScript implementation.
       * @param {object} [options.encoder] - Specify options for the encoder if applicable.
       * @return {string|Promise<string>}
       */
      toDataURL(type = "image/png", options = {}) {
        if (typeof type === "object") {
          options = type;
          type = "image/png";
        }
        const {
          useCanvas = false,
          encoder: encoderOptions = void 0
        } = options;
        type = (0, _mediaTypes.getType)(type);
        function dataUrl(encoder, ctx) {
          const u8 = encoder(ctx, encoderOptions);
          return (0, _base.toBase64URL)(u8, type);
        }
        if (type === "image/bmp") {
          return dataUrl(_fastBmp.encode, this);
        } else if (type === "image/png" && !useCanvas) {
          return dataUrl(encodePng, this);
        } else if (type === "image/jpeg" && !useCanvas) {
          return dataUrl(encodeJpeg, this);
        } else {
          return this.getCanvas().toDataURL(type);
        }
      },
      /**
       * Encodes the image and returns a buffer
       * @memberof Image
       * @instance
       * @param {object} [options]
       * @param {string} [options.format='png']
       * @param {object} [options.encoder] - Specify options for the encoder if applicable.
       * @return {Uint8Array}
       */
      toBuffer(options = {}) {
        const {
          format = "png",
          encoder: encoderOptions = void 0
        } = options;
        switch (format.toLowerCase()) {
          case "png":
            return encodePng(this, encoderOptions);
          case "jpeg":
          case "jpg":
            return encodeJpeg(this, encoderOptions);
          case "bmp":
            return (0, _fastBmp.encode)(this, encoderOptions);
          default:
            throw new RangeError(`invalid output format: ${format}`);
        }
      },
      /**
       * Creates a base64 string from the image.
       * @memberof Image
       * @instance
       * @param {string} [type='image/png']
       * @param {object} [options] - Same options as toDataURL
       * @return {string|Promise<string>}
       */
      toBase64(type = "image/png", options = {}) {
        if (options.async) {
          return this.toDataURL(type, options).then(function(dataURL) {
            return dataURL.substring(dataURL.indexOf(",") + 1);
          });
        } else {
          const dataURL = this.toDataURL(type, options);
          return dataURL.substring(dataURL.indexOf(",") + 1);
        }
      },
      /**
       * Creates a blob from the image and return a Promise.
       * This function is only available in the browser.
       * @memberof Image
       * @instance
       * @param {string} [type='image/png'] A String indicating the image format. The default type is image/png.
       * @param {string} [quality=0.8] A Number between 0 and 1 indicating image quality if the requested type is image/jpeg or image/webp. If this argument is anything else, the default value for image quality is used. Other arguments are ignored.
       * @return {Promise}
       */
      toBlob(type = "image/png", quality = 0.8) {
        return (0, _blobUtil.canvasToBlob)(this.getCanvas(), type, quality);
      },
      /**
       * Creates a new canvas element and draw the image inside it
       * @memberof Image
       * @instance
       * @return {Canvas}
       */
      getCanvas() {
        const data = new _environment.ImageData(this.getRGBAData({
          clamped: true
        }), this.width, this.height);
        let canvas = (0, _environment.createCanvas)(this.width, this.height);
        let ctx = canvas.getContext("2d");
        ctx.putImageData(data, 0, 0);
        return canvas;
      }
    };
    function setExportMethods(Image2) {
      for (const i in exportMethods) {
        Image2.prototype[i] = exportMethods[i];
      }
    }
  }
});

// node_modules/has-own/package.json
var require_package = __commonJS({
  "node_modules/has-own/package.json"(exports2, module2) {
    module2.exports = {
      name: "has-own",
      version: "1.0.1",
      description: "A safer .hasOwnProperty() - hasOwn(name, obj)",
      main: "index.js",
      scripts: {
        test: "make test"
      },
      author: "Aaron Heckmann <aaron.heckmann+github@gmail.com>",
      license: "MIT",
      repository: {
        type: "git",
        url: "git://github.com/aheckmann/has-own.git"
      },
      homepage: "https://github.com/aheckmann/has-own/",
      devDependencies: {
        mocha: "^6.2.2"
      }
    };
  }
});

// node_modules/has-own/index.js
var require_has_own = __commonJS({
  "node_modules/has-own/index.js"(exports2, module2) {
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    module2.exports = exports2 = function hasOwn(prop, obj) {
      return hasOwnProperty.call(obj, prop);
    };
    exports2.version = require_package().version;
  }
});

// node_modules/image-js/lib/image/core/extend.js
var require_extend = __commonJS({
  "node_modules/image-js/lib/image/core/extend.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.extendMethod = extendMethod;
    exports2.extendProperty = extendProperty;
    var _hasOwn = _interopRequireDefault(require_has_own());
    var _Image = _interopRequireDefault(require_Image());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var computedPropertyDescriptor = {
      configurable: true,
      enumerable: false,
      get: void 0
    };
    function extendMethod(name, method, options = {}) {
      let {
        inPlace = false,
        returnThis = true,
        partialArgs = []
      } = options;
      if (inPlace) {
        _Image.default.prototype[name] = function(...args) {
          this.computed = null;
          let result = method.apply(this, [...partialArgs, ...args]);
          if (returnThis) {
            return this;
          }
          return result;
        };
      } else {
        _Image.default.prototype[name] = function(...args) {
          return method.apply(this, [...partialArgs, ...args]);
        };
      }
      return _Image.default;
    }
    function extendProperty(name, method, options = {}) {
      let {
        partialArgs = []
      } = options;
      computedPropertyDescriptor.get = function() {
        if (this.computed === null) {
          this.computed = {};
        } else if ((0, _hasOwn.default)(name, this.computed)) {
          return this.computed[name];
        }
        let result = method.apply(this, partialArgs);
        this.computed[name] = result;
        return result;
      };
      Object.defineProperty(_Image.default.prototype, name, computedPropertyDescriptor);
      return _Image.default;
    }
  }
});

// node_modules/image-js/lib/image/model/model.js
var require_model = __commonJS({
  "node_modules/image-js/lib/image/model/model.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.RGB = exports2.HSV = exports2.HSL = exports2.GREY = exports2.CMYK = void 0;
    var GREY = exports2.GREY = "GREY";
    var RGB = exports2.RGB = "RGB";
    var HSL = exports2.HSL = "HSL";
    var HSV = exports2.HSV = "HSV";
    var CMYK = exports2.CMYK = "CMYK";
  }
});

// node_modules/image-js/lib/image/core/getRGBAData.js
var require_getRGBAData = __commonJS({
  "node_modules/image-js/lib/image/core/getRGBAData.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = getRGBAData;
    var _model = require_model();
    function getRGBAData(options = {}) {
      const {
        clamped
      } = options;
      this.checkProcessable("getRGBAData", {
        components: [1, 3],
        bitDepth: [1, 8, 16, 32]
      });
      const arrayLength = this.width * this.height * 4;
      let newData = clamped ? new Uint8ClampedArray(arrayLength) : new Uint8Array(arrayLength);
      if (this.bitDepth === 1) {
        fillDataFromBinary(this, newData);
      } else if (this.bitDepth === 32) {
        this.checkProcessable("getRGBAData", {
          alpha: 0
        });
        if (this.components === 1) {
          fillDataFromGrey32(this, newData);
        } else if (this.components === 3) {
          this.checkProcessable("getRGBAData", {
            colorModel: [_model.RGB]
          });
          fillDataFromRGB32(this, newData);
        }
      } else {
        if (this.components === 1) {
          fillDataFromGrey(this, newData);
        } else if (this.components === 3) {
          this.checkProcessable("getRGBAData", {
            colorModel: [_model.RGB]
          });
          fillDataFromRGB(this, newData);
        }
      }
      if (this.alpha === 1) {
        this.checkProcessable("getRGBAData", {
          bitDepth: [8, 16]
        });
        copyAlpha(this, newData);
      } else {
        fillAlpha(this, newData);
      }
      return newData;
    }
    function fillDataFromBinary(image, newData) {
      for (let i = 0; i < image.size; i++) {
        const value = image.getBit(i);
        newData[i * 4] = value * 255;
        newData[i * 4 + 1] = value * 255;
        newData[i * 4 + 2] = value * 255;
      }
    }
    function fillDataFromGrey32(image, newData) {
      const min = image.min[0];
      const max = image.max[0];
      const range = max - min;
      for (let i = 0; i < image.size; i++) {
        const val = Math.floor(255 * (image.data[i] - min) / range);
        newData[i * 4] = val;
        newData[i * 4 + 1] = val;
        newData[i * 4 + 2] = val;
      }
    }
    function fillDataFromRGB32(image, newData) {
      const min = Math.min(...image.min);
      const max = Math.max(...image.max);
      const range = max - min;
      for (let i = 0; i < image.size; i++) {
        const val1 = Math.floor(255 * (image.data[i * 3] - min) / range);
        const val2 = Math.floor(255 * (image.data[i * 3 + 1] - min) / range);
        const val3 = Math.floor(255 * (image.data[i * 3 + 2] - min) / range);
        newData[i * 4] = val1;
        newData[i * 4 + 1] = val2;
        newData[i * 4 + 2] = val3;
      }
    }
    function fillDataFromGrey(image, newData) {
      for (let i = 0; i < image.size; i++) {
        newData[i * 4] = image.data[i * image.channels] >>> image.bitDepth - 8;
        newData[i * 4 + 1] = image.data[i * image.channels] >>> image.bitDepth - 8;
        newData[i * 4 + 2] = image.data[i * image.channels] >>> image.bitDepth - 8;
      }
    }
    function fillDataFromRGB(image, newData) {
      for (let i = 0; i < image.size; i++) {
        newData[i * 4] = image.data[i * image.channels] >>> image.bitDepth - 8;
        newData[i * 4 + 1] = image.data[i * image.channels + 1] >>> image.bitDepth - 8;
        newData[i * 4 + 2] = image.data[i * image.channels + 2] >>> image.bitDepth - 8;
      }
    }
    function copyAlpha(image, newData) {
      for (let i = 0; i < image.size; i++) {
        newData[i * 4 + 3] = image.data[i * image.channels + image.components] >> image.bitDepth - 8;
      }
    }
    function fillAlpha(image, newData) {
      for (let i = 0; i < image.size; i++) {
        newData[i * 4 + 3] = 255;
      }
    }
  }
});

// node_modules/image-js/lib/image/core/kindNames.js
var require_kindNames = __commonJS({
  "node_modules/image-js/lib/image/core/kindNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.RGBA = exports2.RGB = exports2.GREYA = exports2.GREY = exports2.CMYKA = exports2.CMYK = exports2.BINARY = void 0;
    var BINARY = exports2.BINARY = "BINARY";
    var GREY = exports2.GREY = "GREY";
    var GREYA = exports2.GREYA = "GREYA";
    var RGB = exports2.RGB = "RGB";
    var RGBA = exports2.RGBA = "RGBA";
    var CMYK = exports2.CMYK = "CMYK";
    var CMYKA = exports2.CMYKA = "CMYKA";
  }
});

// node_modules/image-js/lib/image/core/kind.js
var require_kind = __commonJS({
  "node_modules/image-js/lib/image/core/kind.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createPixelArray = createPixelArray;
    exports2.getKind = getKind;
    exports2.getTheoreticalPixelArraySize = getTheoreticalPixelArraySize;
    exports2.verifyKindDefinition = verifyKindDefinition;
    var ColorModel = _interopRequireWildcard(require_model());
    var Kind = _interopRequireWildcard(require_kindNames());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != typeof e && "function" != typeof e)
        return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n.default = e, t && t.set(e, n), n;
    }
    var kinds = {};
    kinds[Kind.BINARY] = {
      components: 1,
      alpha: 0,
      bitDepth: 1,
      colorModel: ColorModel.GREY
    };
    kinds[Kind.GREYA] = {
      components: 1,
      alpha: 1,
      bitDepth: 8,
      colorModel: ColorModel.GREY
    };
    kinds[Kind.GREY] = {
      components: 1,
      alpha: 0,
      bitDepth: 8,
      colorModel: ColorModel.GREY
    };
    kinds[Kind.RGBA] = {
      components: 3,
      alpha: 1,
      bitDepth: 8,
      colorModel: ColorModel.RGB
    };
    kinds[Kind.RGB] = {
      components: 3,
      alpha: 0,
      bitDepth: 8,
      colorModel: ColorModel.RGB
    };
    kinds[Kind.CMYK] = {
      components: 4,
      alpha: 0,
      bitDepth: 8,
      colorModel: ColorModel.CMYK
    };
    kinds[Kind.CMYKA] = {
      components: 4,
      alpha: 1,
      bitDepth: 8,
      colorModel: ColorModel.CMYK
    };
    function getKind(kind) {
      const result = kinds[kind];
      if (!result) {
        throw new RangeError(`invalid image kind: ${kind}`);
      }
      return result;
    }
    var validBitDepth = [1, 8, 16, 32];
    function verifyKindDefinition(definition) {
      const {
        components,
        alpha,
        bitDepth,
        colorModel
      } = definition;
      if (!Number.isInteger(components) || components <= 0) {
        throw new RangeError(`invalid components: ${components}. Must be a positive integer`);
      }
      if (alpha !== 0 && alpha !== 1 && typeof alpha !== "boolean") {
        throw new TypeError(`invalid alpha: ${alpha}: must be a boolean, 0 or 1`);
      }
      if (!validBitDepth.includes(bitDepth)) {
        throw new RangeError(`invalid bitDepth: ${bitDepth}. Must be one of ${validBitDepth.join(", ")}`);
      }
      if (!ColorModel[colorModel]) {
        throw new RangeError(`invalid colorModel: ${colorModel}. Must be one of ${Object.keys(ColorModel).join(", ")}`);
      }
    }
    function getTheoreticalPixelArraySize(size, channels, bitDepth) {
      let length = channels * size;
      if (bitDepth === 1) {
        length = Math.ceil(length / 8);
      }
      return length;
    }
    function createPixelArray(size, components, alpha, channels, bitDepth, maxValue) {
      const length = channels * size;
      let arr;
      switch (bitDepth) {
        case 1:
          arr = new Uint8Array(Math.ceil(length / 8));
          break;
        case 8:
          arr = new Uint8Array(length);
          break;
        case 16:
          arr = new Uint16Array(length);
          break;
        case 32:
          arr = new Float32Array(length);
          break;
        default:
          throw new Error(`Cannot create pixel array for bit depth ${bitDepth}`);
      }
      if (alpha) {
        for (let i = components; i < arr.length; i += channels) {
          arr[i] = maxValue;
        }
      }
      return arr;
    }
  }
});

// node_modules/fast-jpeg/node_modules/iobuffer/IOBuffer.js
var require_IOBuffer2 = __commonJS({
  "node_modules/fast-jpeg/node_modules/iobuffer/IOBuffer.js"(exports2, module2) {
    "use strict";
    var defaultByteLength = 1024 * 8;
    var charArray = [];
    var IOBuffer = class {
      constructor(data, options) {
        options = options || {};
        if (data === void 0) {
          data = defaultByteLength;
        }
        if (typeof data === "number") {
          data = new ArrayBuffer(data);
        }
        let length = data.byteLength;
        const offset = options.offset ? options.offset >>> 0 : 0;
        if (data.buffer) {
          length = data.byteLength - offset;
          if (data.byteLength !== data.buffer.byteLength) {
            data = data.buffer.slice(data.byteOffset + offset, data.byteOffset + data.byteLength);
          } else if (offset) {
            data = data.buffer.slice(offset);
          } else {
            data = data.buffer;
          }
        }
        this.buffer = data;
        this.length = length;
        this.byteLength = length;
        this.byteOffset = 0;
        this.offset = 0;
        this.littleEndian = true;
        this._data = new DataView(this.buffer);
        this._increment = length || defaultByteLength;
        this._mark = 0;
      }
      available(byteLength) {
        if (byteLength === void 0)
          byteLength = 1;
        return this.offset + byteLength <= this.length;
      }
      isLittleEndian() {
        return this.littleEndian;
      }
      setLittleEndian() {
        this.littleEndian = true;
      }
      isBigEndian() {
        return !this.littleEndian;
      }
      setBigEndian() {
        this.littleEndian = false;
      }
      skip(n) {
        if (n === void 0)
          n = 1;
        this.offset += n;
      }
      seek(offset) {
        this.offset = offset;
      }
      mark() {
        this._mark = this.offset;
      }
      reset() {
        this.offset = this._mark;
      }
      rewind() {
        this.offset = 0;
      }
      ensureAvailable(byteLength) {
        if (byteLength === void 0)
          byteLength = 1;
        if (!this.available(byteLength)) {
          const newIncrement = this._increment + this._increment;
          this._increment = newIncrement;
          const newLength = this.length + newIncrement;
          const newArray = new Uint8Array(newLength);
          newArray.set(new Uint8Array(this.buffer));
          this.buffer = newArray.buffer;
          this.length = newLength;
          this._data = new DataView(this.buffer);
        }
      }
      readBoolean() {
        return this.readUint8() !== 0;
      }
      readInt8() {
        return this._data.getInt8(this.offset++);
      }
      readUint8() {
        return this._data.getUint8(this.offset++);
      }
      readByte() {
        return this.readUint8();
      }
      readBytes(n) {
        if (n === void 0)
          n = 1;
        var bytes = new Uint8Array(n);
        for (var i = 0; i < n; i++) {
          bytes[i] = this.readByte();
        }
        return bytes;
      }
      readInt16() {
        var value = this._data.getInt16(this.offset, this.littleEndian);
        this.offset += 2;
        return value;
      }
      readUint16() {
        var value = this._data.getUint16(this.offset, this.littleEndian);
        this.offset += 2;
        return value;
      }
      readInt32() {
        var value = this._data.getInt32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      }
      readUint32() {
        var value = this._data.getUint32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      }
      readFloat32() {
        var value = this._data.getFloat32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      }
      readFloat64() {
        var value = this._data.getFloat64(this.offset, this.littleEndian);
        this.offset += 8;
        return value;
      }
      readChar() {
        return String.fromCharCode(this.readInt8());
      }
      readChars(n) {
        if (n === void 0)
          n = 1;
        charArray.length = n;
        for (var i = 0; i < n; i++) {
          charArray[i] = this.readChar();
        }
        return charArray.join("");
      }
      writeBoolean(bool) {
        this.writeUint8(bool ? 255 : 0);
      }
      writeInt8(value) {
        this.ensureAvailable(1);
        this._data.setInt8(this.offset++, value);
      }
      writeUint8(value) {
        this.ensureAvailable(1);
        this._data.setUint8(this.offset++, value);
      }
      writeByte(value) {
        this.writeUint8(value);
      }
      writeBytes(bytes) {
        this.ensureAvailable(bytes.length);
        for (var i = 0; i < bytes.length; i++) {
          this._data.setUint8(this.offset++, bytes[i]);
        }
      }
      writeInt16(value) {
        this.ensureAvailable(2);
        this._data.setInt16(this.offset, value, this.littleEndian);
        this.offset += 2;
      }
      writeUint16(value) {
        this.ensureAvailable(2);
        this._data.setUint16(this.offset, value, this.littleEndian);
        this.offset += 2;
      }
      writeInt32(value) {
        this.ensureAvailable(4);
        this._data.setInt32(this.offset, value, this.littleEndian);
        this.offset += 4;
      }
      writeUint32(value) {
        this.ensureAvailable(4);
        this._data.setUint32(this.offset, value, this.littleEndian);
        this.offset += 4;
      }
      writeFloat32(value) {
        this.ensureAvailable(4);
        this._data.setFloat32(this.offset, value, this.littleEndian);
        this.offset += 4;
      }
      writeFloat64(value) {
        this.ensureAvailable(8);
        this._data.setFloat64(this.offset, value, this.littleEndian);
        this.offset += 8;
      }
      writeChar(str) {
        this.writeUint8(str.charCodeAt(0));
      }
      writeChars(str) {
        for (var i = 0; i < str.length; i++) {
          this.writeUint8(str.charCodeAt(i));
        }
      }
      toArray() {
        return new Uint8Array(this.buffer, 0, this.offset);
      }
    };
    module2.exports = IOBuffer;
  }
});

// node_modules/fast-jpeg/node_modules/tiff/src/tags/standard.js
var require_standard = __commonJS({
  "node_modules/fast-jpeg/node_modules/tiff/src/tags/standard.js"(exports2, module2) {
    "use strict";
    var tagsById = {
      // Baseline tags
      254: "NewSubfileType",
      255: "SubfileType",
      256: "ImageWidth",
      257: "ImageLength",
      258: "BitsPerSample",
      259: "Compression",
      262: "PhotometricInterpretation",
      263: "Threshholding",
      264: "CellWidth",
      265: "CellLength",
      266: "FillOrder",
      270: "ImageDescription",
      271: "Make",
      272: "Model",
      273: "StripOffsets",
      274: "Orientation",
      277: "SamplesPerPixel",
      278: "RowsPerStrip",
      279: "StripByteCounts",
      280: "MinSampleValue",
      281: "MaxSampleValue",
      282: "XResolution",
      283: "YResolution",
      284: "PlanarConfiguration",
      288: "FreeOffsets",
      289: "FreeByteCounts",
      290: "GrayResponseUnit",
      291: "GrayResponseCurve",
      296: "ResolutionUnit",
      305: "Software",
      306: "DateTime",
      315: "Artist",
      316: "HostComputer",
      320: "ColorMap",
      338: "ExtraSamples",
      33432: "Copyright",
      // Extension tags
      269: "DocumentName",
      285: "PageName",
      286: "XPosition",
      287: "YPosition",
      292: "T4Options",
      293: "T6Options",
      297: "PageNumber",
      301: "TransferFunction",
      317: "Predictor",
      318: "WhitePoint",
      319: "PrimaryChromaticities",
      321: "HalftoneHints",
      322: "TileWidth",
      323: "TileLength",
      324: "TileOffsets",
      325: "TileByteCounts",
      326: "BadFaxLines",
      327: "CleanFaxData",
      328: "ConsecutiveBadFaxLines",
      330: "SubIFDs",
      332: "InkSet",
      333: "InkNames",
      334: "NumberOfInks",
      336: "DotRange",
      337: "TargetPrinter",
      339: "SampleFormat",
      340: "SMinSampleValue",
      341: "SMaxSampleValue",
      342: "TransferRange",
      343: "ClipPath",
      344: "XClipPathUnits",
      345: "YClipPathUnits",
      346: "Indexed",
      347: "JPEGTables",
      351: "OPIProxy",
      400: "GlobalParametersIFD",
      401: "ProfileType",
      402: "FaxProfile",
      403: "CodingMethods",
      404: "VersionYear",
      405: "ModeNumber",
      433: "Decode",
      434: "DefaultImageColor",
      512: "JPEGProc",
      513: "JPEGInterchangeFormat",
      514: "JPEGInterchangeFormatLength",
      515: "JPEGRestartInterval",
      517: "JPEGLosslessPredictors",
      518: "JPEGPointTransforms",
      519: "JPEGQTables",
      520: "JPEGDCTables",
      521: "JPEGACTables",
      529: "YCbCrCoefficients",
      530: "YCbCrSubSampling",
      531: "YCbCrPositioning",
      532: "ReferenceBlackWhite",
      559: "StripRowCounts",
      700: "XMP",
      32781: "ImageID",
      34732: "ImageLayer",
      // Private tags
      32932: "WangAnnotatio",
      33445: "MDFileTag",
      33446: "MDScalePixel",
      33447: "MDColorTable",
      33448: "MDLabName",
      33449: "MDSampleInfo",
      33450: "MDPrepDate",
      33451: "MDPrepTime",
      33452: "MDFileUnits",
      33550: "ModelPixelScaleTag",
      33723: "IPTC",
      33918: "INGRPacketDataTag",
      33919: "INGRFlagRegisters",
      33920: "IrasBTransformationMatrix",
      33922: "ModelTiepointTag",
      34264: "ModelTransformationTag",
      34377: "Photoshop",
      34665: "ExifIFD",
      34675: "ICCProfile",
      34735: "GeoKeyDirectoryTag",
      34736: "GeoDoubleParamsTag",
      34737: "GeoAsciiParamsTag",
      34853: "GPSIFD",
      34908: "HylaFAXFaxRecvParams",
      34909: "HylaFAXFaxSubAddress",
      34910: "HylaFAXFaxRecvTime",
      37724: "ImageSourceData",
      40965: "InteroperabilityIFD",
      42112: "GDAL_METADATA",
      42113: "GDAL_NODATA",
      50215: "OceScanjobDescription",
      50216: "OceApplicationSelector",
      50217: "OceIdentificationNumber",
      50218: "OceImageLogicCharacteristics",
      50706: "DNGVersion",
      50707: "DNGBackwardVersion",
      50708: "UniqueCameraModel",
      50709: "LocalizedCameraModel",
      50710: "CFAPlaneColor",
      50711: "CFALayout",
      50712: "LinearizationTable",
      50713: "BlackLevelRepeatDim",
      50714: "BlackLevel",
      50715: "BlackLevelDeltaH",
      50716: "BlackLevelDeltaV",
      50717: "WhiteLevel",
      50718: "DefaultScale",
      50719: "DefaultCropOrigin",
      50720: "DefaultCropSize",
      50721: "ColorMatrix1",
      50722: "ColorMatrix2",
      50723: "CameraCalibration1",
      50724: "CameraCalibration2",
      50725: "ReductionMatrix1",
      50726: "ReductionMatrix2",
      50727: "AnalogBalance",
      50728: "AsShotNeutral",
      50729: "AsShotWhiteXY",
      50730: "BaselineExposure",
      50731: "BaselineNoise",
      50732: "BaselineSharpness",
      50733: "BayerGreenSplit",
      50734: "LinearResponseLimit",
      50735: "CameraSerialNumber",
      50736: "LensInfo",
      50737: "ChromaBlurRadius",
      50738: "AntiAliasStrength",
      50740: "DNGPrivateData",
      50741: "MakerNoteSafety",
      50778: "CalibrationIlluminant1",
      50779: "CalibrationIlluminant2",
      50780: "BestQualityScale",
      50784: "AliasLayerMetadata"
    };
    var tagsByName = {};
    for (i in tagsById) {
      tagsByName[tagsById[i]] = i;
    }
    var i;
    module2.exports = {
      tagsById,
      tagsByName
    };
  }
});

// node_modules/fast-jpeg/node_modules/tiff/src/tags/exif.js
var require_exif = __commonJS({
  "node_modules/fast-jpeg/node_modules/tiff/src/tags/exif.js"(exports2, module2) {
    "use strict";
    var tagsById = {
      33434: "ExposureTime",
      33437: "FNumber",
      34850: "ExposureProgram",
      34852: "SpectralSensitivity",
      34855: "ISOSpeedRatings",
      34856: "OECF",
      34864: "SensitivityType",
      34865: "StandardOutputSensitivity",
      34866: "RecommendedExposureIndex",
      34867: "ISOSpeed",
      34868: "ISOSpeedLatitudeyyy",
      34869: "ISOSpeedLatitudezzz",
      36864: "ExifVersion",
      36867: "DateTimeOriginal",
      36868: "DateTimeDigitized",
      37121: "ComponentsConfiguration",
      37122: "CompressedBitsPerPixel",
      37377: "ShutterSpeedValue",
      37378: "ApertureValue",
      37379: "BrightnessValue",
      37380: "ExposureBiasValue",
      37381: "MaxApertureValue",
      37382: "SubjectDistance",
      37383: "MeteringMode",
      37384: "LightSource",
      37385: "Flash",
      37386: "FocalLength",
      37396: "SubjectArea",
      37500: "MakerNote",
      37510: "UserComment",
      37520: "SubsecTime",
      37521: "SubsecTimeOriginal",
      37522: "SubsecTimeDigitized",
      40960: "FlashpixVersion",
      40961: "ColorSpace",
      40962: "PixelXDimension",
      40963: "PixelYDimension",
      40964: "RelatedSoundFile",
      41483: "FlashEnergy",
      41484: "SpatialFrequencyResponse",
      41486: "FocalPlaneXResolution",
      41487: "FocalPlaneYResolution",
      41488: "FocalPlaneResolutionUnit",
      41492: "SubjectLocation",
      41493: "ExposureIndex",
      41495: "SensingMethod",
      41728: "FileSource",
      41729: "SceneType",
      41730: "CFAPattern",
      41985: "CustomRendered",
      41986: "ExposureMode",
      41987: "WhiteBalance",
      41988: "DigitalZoomRatio",
      41989: "FocalLengthIn35mmFilm",
      41990: "SceneCaptureType",
      41991: "GainControl",
      41992: "Contrast",
      41993: "Saturation",
      41994: "Sharpness",
      41995: "DeviceSettingDescription",
      41996: "SubjectDistanceRange",
      42016: "ImageUniqueID",
      42032: "CameraOwnerName",
      42033: "BodySerialNumber",
      42034: "LensSpecification",
      42035: "LensMake",
      42036: "LensModel",
      42037: "LensSerialNumber",
      42240: "Gamma"
    };
    var tagsByName = {};
    for (i in tagsById) {
      tagsByName[tagsById[i]] = i;
    }
    var i;
    module2.exports = {
      tagsById,
      tagsByName
    };
  }
});

// node_modules/fast-jpeg/node_modules/tiff/src/tags/gps.js
var require_gps = __commonJS({
  "node_modules/fast-jpeg/node_modules/tiff/src/tags/gps.js"(exports2, module2) {
    "use strict";
    var tagsById = {
      0: "GPSVersionID",
      1: "GPSLatitudeRef",
      2: "GPSLatitude",
      3: "GPSLongitudeRef",
      4: "GPSLongitude",
      5: "GPSAltitudeRef",
      6: "GPSAltitude",
      7: "GPSTimeStamp",
      8: "GPSSatellites",
      9: "GPSStatus",
      10: "GPSMeasureMode",
      11: "GPSDOP",
      12: "GPSSpeedRef",
      13: "GPSSpeed",
      14: "GPSTrackRef",
      15: "GPSTrack",
      16: "GPSImgDirectionRef",
      17: "GPSImgDirection",
      18: "GPSMapDatum",
      19: "GPSDestLatitudeRef",
      20: "GPSDestLatitude",
      21: "GPSDestLongitudeRef",
      22: "GPSDestLongitude",
      23: "GPSDestBearingRef",
      24: "GPSDestBearing",
      25: "GPSDestDistanceRef",
      26: "GPSDestDistance",
      27: "GPSProcessingMethod",
      28: "GPSAreaInformation",
      29: "GPSDateStamp",
      30: "GPSDifferential",
      31: "GPSHPositioningError"
    };
    var tagsByName = {};
    for (i in tagsById) {
      tagsByName[tagsById[i]] = i;
    }
    var i;
    module2.exports = {
      tagsById,
      tagsByName
    };
  }
});

// node_modules/fast-jpeg/node_modules/tiff/src/ifd.js
var require_ifd = __commonJS({
  "node_modules/fast-jpeg/node_modules/tiff/src/ifd.js"(exports2, module2) {
    "use strict";
    var tags = {
      standard: require_standard(),
      exif: require_exif(),
      gps: require_gps()
    };
    var IFD = class {
      constructor(kind) {
        if (!kind) {
          throw new Error("missing kind");
        }
        this.data = null;
        this.fields = /* @__PURE__ */ new Map();
        this.kind = kind;
        this._map = null;
      }
      get(tag) {
        if (typeof tag === "number") {
          return this.fields.get(tag);
        } else if (typeof tag === "string") {
          return this.fields.get(tags[this.kind].tagsByName[tag]);
        } else {
          throw new Error("expected a number or string");
        }
      }
      get map() {
        if (!this._map) {
          this._map = {};
          const taglist = tags[this.kind].tagsById;
          for (var key of this.fields.keys()) {
            if (taglist[key]) {
              this._map[taglist[key]] = this.fields.get(key);
            }
          }
        }
        return this._map;
      }
    };
    module2.exports = IFD;
  }
});

// node_modules/fast-jpeg/node_modules/tiff/src/tiffIfd.js
var require_tiffIfd = __commonJS({
  "node_modules/fast-jpeg/node_modules/tiff/src/tiffIfd.js"(exports2, module2) {
    "use strict";
    var Ifd = require_ifd();
    var dateTimeRegex = /^(\d{4}):(\d{2}):(\d{2}) (\d{2}):(\d{2}):(\d{2})$/;
    var TiffIfd = class extends Ifd {
      constructor() {
        super("standard");
      }
      // Custom fields
      get size() {
        return this.width * this.height;
      }
      get width() {
        return this.imageWidth;
      }
      get height() {
        return this.imageLength;
      }
      get components() {
        return this.samplesPerPixel;
      }
      get date() {
        var date = new Date();
        var result = dateTimeRegex.exec(this.dateTime);
        date.setFullYear(result[1], result[2] - 1, result[3]);
        date.setHours(result[4], result[5], result[6]);
        return date;
      }
      // IFD fields
      get newSubfileType() {
        return this.get(254);
      }
      get imageWidth() {
        return this.get(256);
      }
      get imageLength() {
        return this.get(257);
      }
      get bitsPerSample() {
        return this.get(258);
      }
      get compression() {
        return this.get(259) || 1;
      }
      get type() {
        return this.get(262);
      }
      get fillOrder() {
        return this.get(266) || 1;
      }
      get documentName() {
        return this.get(269);
      }
      get imageDescription() {
        return this.get(270);
      }
      get stripOffsets() {
        return alwaysArray(this.get(273));
      }
      get orientation() {
        return this.get(274);
      }
      get samplesPerPixel() {
        return this.get(277);
      }
      get rowsPerStrip() {
        return this.get(278);
      }
      get stripByteCounts() {
        return alwaysArray(this.get(279));
      }
      get minSampleValue() {
        return this.get(280) || 0;
      }
      get maxSampleValue() {
        return this.get(281) || Math.pow(2, this.bitsPerSample) - 1;
      }
      get xResolution() {
        return this.get(282);
      }
      get yResolution() {
        return this.get(283);
      }
      get planarConfiguration() {
        return this.get(284) || 1;
      }
      get resolutionUnit() {
        return this.get(296) || 2;
      }
      get dateTime() {
        return this.get(306);
      }
      get predictor() {
        return this.get(317) || 1;
      }
      get sampleFormat() {
        return this.get(339) || 1;
      }
      get sMinSampleValue() {
        return this.get(340) || this.minSampleValue;
      }
      get sMaxSampleValue() {
        return this.get(341) || this.maxSampleValue;
      }
    };
    function alwaysArray(value) {
      if (typeof value === "number")
        return [value];
      return value;
    }
    module2.exports = TiffIfd;
  }
});

// node_modules/fast-jpeg/node_modules/tiff/src/ifdValue.js
var require_ifdValue = __commonJS({
  "node_modules/fast-jpeg/node_modules/tiff/src/ifdValue.js"(exports2) {
    "use strict";
    var types = /* @__PURE__ */ new Map([
      [1, [1, readByte]],
      // BYTE
      [2, [1, readASCII]],
      // ASCII
      [3, [2, readShort]],
      // SHORT
      [4, [4, readLong]],
      // LONG
      [5, [8, readRational]],
      // RATIONAL
      [6, [1, readSByte]],
      // SBYTE
      [7, [1, readByte]],
      // UNDEFINED
      [8, [2, readSShort]],
      // SSHORT
      [9, [4, readSLong]],
      // SLONG
      [10, [8, readSRational]],
      // SRATIONAL
      [11, [4, readFloat]],
      // FLOAT
      [12, [8, readDouble]]
      // DOUBLE
    ]);
    exports2.getByteLength = function(type, count) {
      return types.get(type)[0] * count;
    };
    exports2.readData = function(decoder, type, count) {
      return types.get(type)[1](decoder, count);
    };
    function readByte(decoder, count) {
      if (count === 1)
        return decoder.readUint8();
      var array = new Uint8Array(count);
      for (var i = 0; i < count; i++) {
        array[i] = decoder.readUint8();
      }
      return array;
    }
    function readASCII(decoder, count) {
      var strings = [];
      var currentString = "";
      for (var i = 0; i < count; i++) {
        var char = String.fromCharCode(decoder.readUint8());
        if (char === "\0") {
          strings.push(currentString);
          currentString = "";
        } else {
          currentString += char;
        }
      }
      if (strings.length === 1) {
        return strings[0];
      } else {
        return strings;
      }
    }
    function readShort(decoder, count) {
      if (count === 1)
        return decoder.readUint16();
      var array = new Uint16Array(count);
      for (var i = 0; i < count; i++) {
        array[i] = decoder.readUint16();
      }
      return array;
    }
    function readLong(decoder, count) {
      if (count === 1)
        return decoder.readUint32();
      var array = new Uint32Array(count);
      for (var i = 0; i < count; i++) {
        array[i] = decoder.readUint32();
      }
      return array;
    }
    function readRational(decoder, count) {
      if (count === 1) {
        return decoder.readUint32() / decoder.readUint32();
      }
      var rationals = new Array(count);
      for (var i = 0; i < count; i++) {
        rationals[i] = decoder.readUint32() / decoder.readUint32();
      }
      return rationals;
    }
    function readSByte(decoder, count) {
      if (count === 1)
        return decoder.readInt8();
      var array = new Int8Array(count);
      for (var i = 0; i < count; i++) {
        array[i] = decoder.readInt8();
      }
      return array;
    }
    function readSShort(decoder, count) {
      if (count === 1)
        return decoder.readInt16();
      var array = new Int16Array(count);
      for (var i = 0; i < count; i++) {
        array[i] = decoder.readInt16();
      }
      return array;
    }
    function readSLong(decoder, count) {
      if (count === 1)
        return decoder.readInt32();
      var array = new Int32Array(count);
      for (var i = 0; i < count; i++) {
        array[i] = decoder.readInt32();
      }
      return array;
    }
    function readSRational(decoder, count) {
      if (count === 1) {
        return decoder.readInt32() / decoder.readInt32();
      }
      var rationals = new Array(count);
      for (var i = 0; i < count; i++) {
        rationals[i] = decoder.readInt32() / decoder.readInt32();
      }
      return rationals;
    }
    function readFloat(decoder, count) {
      if (count === 1)
        return decoder.readFloat32();
      var array = new Float32Array(count);
      for (var i = 0; i < count; i++) {
        array[i] = decoder.readFloat32();
      }
      return array;
    }
    function readDouble(decoder, count) {
      if (count === 1)
        return decoder.readFloat64();
      var array = new Float64Array(count);
      for (var i = 0; i < count; i++) {
        array[i] = decoder.readFloat64();
      }
      return array;
    }
  }
});

// node_modules/fast-jpeg/node_modules/tiff/src/tiffDecoder.js
var require_tiffDecoder = __commonJS({
  "node_modules/fast-jpeg/node_modules/tiff/src/tiffDecoder.js"(exports2, module2) {
    "use strict";
    var IOBuffer = require_IOBuffer2();
    var IFD = require_ifd();
    var TiffIFD = require_tiffIfd();
    var IFDValue = require_ifdValue();
    var defaultOptions = {
      ignoreImageData: false,
      onlyFirst: false
    };
    var TIFFDecoder = class extends IOBuffer {
      constructor(data, options) {
        super(data, options);
        this._nextIFD = 0;
      }
      decode(options) {
        options = Object.assign({}, defaultOptions, options);
        const result = [];
        this.decodeHeader();
        while (this._nextIFD) {
          result.push(this.decodeIFD(options));
          if (options.onlyFirst) {
            return result[0];
          }
        }
        return result;
      }
      decodeHeader() {
        let value = this.readUint16();
        if (value === 18761) {
          this.setLittleEndian();
        } else if (value === 19789) {
          this.setBigEndian();
        } else {
          throw new Error("invalid byte order: 0x" + value.toString(16));
        }
        value = this.readUint16();
        if (value !== 42) {
          throw new Error("not a TIFF file");
        }
        this._nextIFD = this.readUint32();
      }
      decodeIFD(options) {
        this.seek(this._nextIFD);
        var ifd;
        if (!options.kind) {
          ifd = new TiffIFD();
        } else {
          ifd = new IFD(options.kind);
        }
        const numEntries = this.readUint16();
        for (var i = 0; i < numEntries; i++) {
          this.decodeIFDEntry(ifd);
        }
        if (!options.ignoreImageData) {
          this.decodeImageData(ifd);
        }
        this._nextIFD = this.readUint32();
        return ifd;
      }
      decodeIFDEntry(ifd) {
        const offset = this.offset;
        const tag = this.readUint16();
        const type = this.readUint16();
        const numValues = this.readUint32();
        if (type < 1 || type > 12) {
          this.skip(4);
          return;
        }
        const valueByteLength = IFDValue.getByteLength(type, numValues);
        if (valueByteLength > 4) {
          this.seek(this.readUint32());
        }
        const value = IFDValue.readData(this, type, numValues);
        ifd.fields.set(tag, value);
        if (tag === 34665 || tag === 34853) {
          let currentOffset = this.offset;
          let kind;
          if (tag === 34665) {
            kind = "exif";
          } else if (tag === 34853) {
            kind = "gps";
          }
          this._nextIFD = value;
          ifd[kind] = this.decodeIFD({
            kind,
            ignoreImageData: true
          });
          this.offset = currentOffset;
        }
        this.seek(offset);
        this.skip(12);
      }
      decodeImageData(ifd) {
        const orientation = ifd.orientation;
        if (orientation && orientation !== 1) {
          unsupported("orientation", orientation);
        }
        switch (ifd.type) {
          case 1:
          case 2:
            this.readStripData(ifd);
            break;
          default:
            unsupported("image type", ifd.type);
            break;
        }
      }
      readStripData(ifd) {
        const width = ifd.width;
        const height = ifd.height;
        const bitDepth = validateBitDepth(ifd.bitsPerSample);
        const sampleFormat = ifd.sampleFormat;
        let size = width * height;
        const data = getDataArray(size, 1, bitDepth, sampleFormat);
        const compression = ifd.compression;
        const rowsPerStrip = ifd.rowsPerStrip;
        const maxPixels = rowsPerStrip * width;
        const stripOffsets = ifd.stripOffsets;
        const stripByteCounts = ifd.stripByteCounts;
        var pixel = 0;
        for (var i = 0; i < stripOffsets.length; i++) {
          var stripData = this.getStripData(compression, stripOffsets[i], stripByteCounts[i]);
          var length = size > maxPixels ? maxPixels : size;
          size -= length;
          if (bitDepth === 8) {
            pixel = fill8bit(data, stripData, pixel, length);
          } else if (bitDepth === 16) {
            pixel = fill16bit(data, stripData, pixel, length, this.isLittleEndian());
          } else if (bitDepth === 32 && sampleFormat === 3) {
            pixel = fillFloat32(data, stripData, pixel, length, this.isLittleEndian());
          } else {
            unsupported("bitDepth", bitDepth);
          }
        }
        ifd.data = data;
      }
      getStripData(compression, offset, byteCounts) {
        switch (compression) {
          case 1:
            return new DataView(this.buffer, offset, byteCounts);
          case 2:
          case 32773:
            return unsupported("Compression", compression);
          default:
            throw new Error("invalid compression: " + compression);
        }
      }
    };
    module2.exports = TIFFDecoder;
    function getDataArray(size, channels, bitDepth, sampleFormat) {
      if (bitDepth === 8) {
        return new Uint8Array(size * channels);
      } else if (bitDepth === 16) {
        return new Uint16Array(size * channels);
      } else if (bitDepth === 32 && sampleFormat === 3) {
        return new Float32Array(size * channels);
      } else {
        return unsupported("bit depth / sample format", bitDepth + " / " + sampleFormat);
      }
    }
    function fill8bit(dataTo, dataFrom, index, length) {
      for (var i = 0; i < length; i++) {
        dataTo[index++] = dataFrom.getUint8(i);
      }
      return index;
    }
    function fill16bit(dataTo, dataFrom, index, length, littleEndian) {
      for (var i = 0; i < length * 2; i += 2) {
        dataTo[index++] = dataFrom.getUint16(i, littleEndian);
      }
      return index;
    }
    function fillFloat32(dataTo, dataFrom, index, length, littleEndian) {
      for (var i = 0; i < length * 4; i += 4) {
        dataTo[index++] = dataFrom.getFloat32(i, littleEndian);
      }
      return index;
    }
    function unsupported(type, value) {
      throw new Error("Unsupported " + type + ": " + value);
    }
    function validateBitDepth(bitDepth) {
      if (bitDepth.length) {
        const bitDepthArray = bitDepth;
        bitDepth = bitDepthArray[0];
        for (var i = 0; i < bitDepthArray.length; i++) {
          if (bitDepthArray[i] !== bitDepth) {
            unsupported("bit depth", bitDepthArray);
          }
        }
      }
      return bitDepth;
    }
  }
});

// node_modules/fast-jpeg/node_modules/tiff/src/decode.js
var require_decode = __commonJS({
  "node_modules/fast-jpeg/node_modules/tiff/src/decode.js"(exports2, module2) {
    "use strict";
    var TIFFDecoder = require_tiffDecoder();
    module2.exports = function decodeTIFF(data, options) {
      const decoder = new TIFFDecoder(data, options);
      return decoder.decode(options);
    };
  }
});

// node_modules/fast-jpeg/node_modules/tiff/src/index.js
var require_src2 = __commonJS({
  "node_modules/fast-jpeg/node_modules/tiff/src/index.js"(exports2) {
    "use strict";
    exports2.decode = require_decode();
  }
});

// node_modules/fast-jpeg/src/decode.js
var require_decode2 = __commonJS({
  "node_modules/fast-jpeg/src/decode.js"(exports2, module2) {
    "use strict";
    var IOBuffer = require_IOBuffer2();
    var tiff = require_src2();
    function decode(data) {
      const buffer = new IOBuffer(data);
      const result = {};
      buffer.setBigEndian();
      const val = buffer.readUint16();
      if (val !== 65496) {
        throw new Error("SOI marker not found. Not a valid JPEG file");
      }
      const next = buffer.readUint16();
      if (next === 65505) {
        const length = buffer.readUint16();
        const header = buffer.readBytes(6);
        if (header[0] === 69 && // E
        header[1] === 120 && // x
        header[2] === 105 && // i
        header[3] === 102 && // f
        header[4] === 0 && header[5] === 0) {
          const exif = tiff.decode(buffer, {
            onlyFirst: true,
            ignoreImageData: true,
            offset: buffer.offset
          });
          result.exif = exif;
        }
      }
      return result;
    }
    module2.exports = decode;
  }
});

// node_modules/fast-jpeg/src/index.js
var require_src3 = __commonJS({
  "node_modules/fast-jpeg/src/index.js"(exports2) {
    "use strict";
    exports2.decode = require_decode2();
  }
});

// node_modules/file-type/index.js
var require_file_type = __commonJS({
  "node_modules/file-type/index.js"(exports, module) {
    "use strict";
    var toBytes = (s) => [...s].map((c) => c.charCodeAt(0));
    var xpiZipFilename = toBytes("META-INF/mozilla.rsa");
    var oxmlContentTypes = toBytes("[Content_Types].xml");
    var oxmlRels = toBytes("_rels/.rels");
    function readUInt64LE(buf, offset = 0) {
      let n = buf[offset];
      let mul = 1;
      let i = 0;
      while (++i < 8) {
        mul *= 256;
        n += buf[offset + i] * mul;
      }
      return n;
    }
    var fileType = (input) => {
      if (!(input instanceof Uint8Array || input instanceof ArrayBuffer || Buffer.isBuffer(input))) {
        throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof input}\``);
      }
      const buf = input instanceof Uint8Array ? input : new Uint8Array(input);
      if (!(buf && buf.length > 1)) {
        return null;
      }
      const check = (header, options) => {
        options = Object.assign({
          offset: 0
        }, options);
        for (let i = 0; i < header.length; i++) {
          if (options.mask) {
            if (header[i] !== (options.mask[i] & buf[i + options.offset])) {
              return false;
            }
          } else if (header[i] !== buf[i + options.offset]) {
            return false;
          }
        }
        return true;
      };
      const checkString = (header, options) => check(toBytes(header), options);
      if (check([255, 216, 255])) {
        return {
          ext: "jpg",
          mime: "image/jpeg"
        };
      }
      if (check([137, 80, 78, 71, 13, 10, 26, 10])) {
        return {
          ext: "png",
          mime: "image/png"
        };
      }
      if (check([71, 73, 70])) {
        return {
          ext: "gif",
          mime: "image/gif"
        };
      }
      if (check([87, 69, 66, 80], { offset: 8 })) {
        return {
          ext: "webp",
          mime: "image/webp"
        };
      }
      if (check([70, 76, 73, 70])) {
        return {
          ext: "flif",
          mime: "image/flif"
        };
      }
      if ((check([73, 73, 42, 0]) || check([77, 77, 0, 42])) && check([67, 82], { offset: 8 })) {
        return {
          ext: "cr2",
          mime: "image/x-canon-cr2"
        };
      }
      if (check([73, 73, 42, 0]) || check([77, 77, 0, 42])) {
        return {
          ext: "tif",
          mime: "image/tiff"
        };
      }
      if (check([66, 77])) {
        return {
          ext: "bmp",
          mime: "image/bmp"
        };
      }
      if (check([73, 73, 188])) {
        return {
          ext: "jxr",
          mime: "image/vnd.ms-photo"
        };
      }
      if (check([56, 66, 80, 83])) {
        return {
          ext: "psd",
          mime: "image/vnd.adobe.photoshop"
        };
      }
      if (check([80, 75, 3, 4])) {
        if (check([109, 105, 109, 101, 116, 121, 112, 101, 97, 112, 112, 108, 105, 99, 97, 116, 105, 111, 110, 47, 101, 112, 117, 98, 43, 122, 105, 112], { offset: 30 })) {
          return {
            ext: "epub",
            mime: "application/epub+zip"
          };
        }
        if (check(xpiZipFilename, { offset: 30 })) {
          return {
            ext: "xpi",
            mime: "application/x-xpinstall"
          };
        }
        if (checkString("mimetypeapplication/vnd.oasis.opendocument.text", { offset: 30 })) {
          return {
            ext: "odt",
            mime: "application/vnd.oasis.opendocument.text"
          };
        }
        if (checkString("mimetypeapplication/vnd.oasis.opendocument.spreadsheet", { offset: 30 })) {
          return {
            ext: "ods",
            mime: "application/vnd.oasis.opendocument.spreadsheet"
          };
        }
        if (checkString("mimetypeapplication/vnd.oasis.opendocument.presentation", { offset: 30 })) {
          return {
            ext: "odp",
            mime: "application/vnd.oasis.opendocument.presentation"
          };
        }
        const findNextZipHeaderIndex = (arr, startAt = 0) => arr.findIndex((el, i, arr2) => i >= startAt && arr2[i] === 80 && arr2[i + 1] === 75 && arr2[i + 2] === 3 && arr2[i + 3] === 4);
        let zipHeaderIndex = 0;
        let oxmlFound = false;
        let type = null;
        do {
          const offset = zipHeaderIndex + 30;
          if (!oxmlFound) {
            oxmlFound = check(oxmlContentTypes, { offset }) || check(oxmlRels, { offset });
          }
          if (!type) {
            if (checkString("word/", { offset })) {
              type = {
                ext: "docx",
                mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
              };
            } else if (checkString("ppt/", { offset })) {
              type = {
                ext: "pptx",
                mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
              };
            } else if (checkString("xl/", { offset })) {
              type = {
                ext: "xlsx",
                mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
              };
            }
          }
          if (oxmlFound && type) {
            return type;
          }
          zipHeaderIndex = findNextZipHeaderIndex(buf, offset);
        } while (zipHeaderIndex >= 0);
        if (type) {
          return type;
        }
      }
      if (check([80, 75]) && (buf[2] === 3 || buf[2] === 5 || buf[2] === 7) && (buf[3] === 4 || buf[3] === 6 || buf[3] === 8)) {
        return {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (check([117, 115, 116, 97, 114], { offset: 257 })) {
        return {
          ext: "tar",
          mime: "application/x-tar"
        };
      }
      if (check([82, 97, 114, 33, 26, 7]) && (buf[6] === 0 || buf[6] === 1)) {
        return {
          ext: "rar",
          mime: "application/x-rar-compressed"
        };
      }
      if (check([31, 139, 8])) {
        return {
          ext: "gz",
          mime: "application/gzip"
        };
      }
      if (check([66, 90, 104])) {
        return {
          ext: "bz2",
          mime: "application/x-bzip2"
        };
      }
      if (check([55, 122, 188, 175, 39, 28])) {
        return {
          ext: "7z",
          mime: "application/x-7z-compressed"
        };
      }
      if (check([120, 1])) {
        return {
          ext: "dmg",
          mime: "application/x-apple-diskimage"
        };
      }
      if (check([51, 103, 112, 53]) || // 3gp5
      check([0, 0, 0]) && check([102, 116, 121, 112], { offset: 4 }) && (check([109, 112, 52, 49], { offset: 8 }) || // MP41
      check([109, 112, 52, 50], { offset: 8 }) || // MP42
      check([105, 115, 111, 109], { offset: 8 }) || // ISOM
      check([105, 115, 111, 50], { offset: 8 }) || // ISO2
      check([109, 109, 112, 52], { offset: 8 }) || // MMP4
      check([77, 52, 86], { offset: 8 }) || // M4V
      check([100, 97, 115, 104], { offset: 8 }))) {
        return {
          ext: "mp4",
          mime: "video/mp4"
        };
      }
      if (check([77, 84, 104, 100])) {
        return {
          ext: "mid",
          mime: "audio/midi"
        };
      }
      if (check([26, 69, 223, 163])) {
        const sliced = buf.subarray(4, 4 + 4096);
        const idPos = sliced.findIndex((el, i, arr) => arr[i] === 66 && arr[i + 1] === 130);
        if (idPos !== -1) {
          const docTypePos = idPos + 3;
          const findDocType = (type) => [...type].every((c, i) => sliced[docTypePos + i] === c.charCodeAt(0));
          if (findDocType("matroska")) {
            return {
              ext: "mkv",
              mime: "video/x-matroska"
            };
          }
          if (findDocType("webm")) {
            return {
              ext: "webm",
              mime: "video/webm"
            };
          }
        }
      }
      if (check([0, 0, 0, 20, 102, 116, 121, 112, 113, 116, 32, 32]) || check([102, 114, 101, 101], { offset: 4 }) || // Type: `free`
      check([102, 116, 121, 112, 113, 116, 32, 32], { offset: 4 }) || check([109, 100, 97, 116], { offset: 4 }) || // MJPEG
      check([109, 111, 111, 118], { offset: 4 }) || // Type: `moov`
      check([119, 105, 100, 101], { offset: 4 })) {
        return {
          ext: "mov",
          mime: "video/quicktime"
        };
      }
      if (check([82, 73, 70, 70])) {
        if (check([65, 86, 73], { offset: 8 })) {
          return {
            ext: "avi",
            mime: "video/vnd.avi"
          };
        }
        if (check([87, 65, 86, 69], { offset: 8 })) {
          return {
            ext: "wav",
            mime: "audio/vnd.wave"
          };
        }
        if (check([81, 76, 67, 77], { offset: 8 })) {
          return {
            ext: "qcp",
            mime: "audio/qcelp"
          };
        }
      }
      if (check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
        let offset = 30;
        do {
          const objectSize = readUInt64LE(buf, offset + 16);
          if (check([145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101], { offset })) {
            if (check([64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43], { offset: offset + 24 })) {
              return {
                ext: "wma",
                mime: "audio/x-ms-wma"
              };
            }
            if (check([192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43], { offset: offset + 24 })) {
              return {
                ext: "wmv",
                mime: "video/x-ms-asf"
              };
            }
            break;
          }
          offset += objectSize;
        } while (offset + 24 <= buf.length);
        return {
          ext: "asf",
          mime: "application/vnd.ms-asf"
        };
      }
      if (check([0, 0, 1, 186]) || check([0, 0, 1, 179])) {
        return {
          ext: "mpg",
          mime: "video/mpeg"
        };
      }
      if (check([102, 116, 121, 112, 51, 103], { offset: 4 })) {
        return {
          ext: "3gp",
          mime: "video/3gpp"
        };
      }
      for (let start = 0; start < 2 && start < buf.length - 16; start++) {
        if (check([73, 68, 51], { offset: start }) || // ID3 header
        check([255, 226], { offset: start, mask: [255, 226] })) {
          return {
            ext: "mp3",
            mime: "audio/mpeg"
          };
        }
        if (check([255, 228], { offset: start, mask: [255, 228] })) {
          return {
            ext: "mp2",
            mime: "audio/mpeg"
          };
        }
        if (check([255, 248], { offset: start, mask: [255, 252] })) {
          return {
            ext: "mp2",
            mime: "audio/mpeg"
          };
        }
        if (check([255, 240], { offset: start, mask: [255, 252] })) {
          return {
            ext: "mp4",
            mime: "audio/mpeg"
          };
        }
      }
      if (check([102, 116, 121, 112, 77, 52, 65], { offset: 4 })) {
        return {
          // MPEG-4 layer 3 (audio)
          ext: "m4a",
          mime: "audio/mp4"
          // RFC 4337
        };
      }
      if (check([79, 112, 117, 115, 72, 101, 97, 100], { offset: 28 })) {
        return {
          ext: "opus",
          mime: "audio/opus"
        };
      }
      if (check([79, 103, 103, 83])) {
        if (check([128, 116, 104, 101, 111, 114, 97], { offset: 28 })) {
          return {
            ext: "ogv",
            mime: "video/ogg"
          };
        }
        if (check([1, 118, 105, 100, 101, 111, 0], { offset: 28 })) {
          return {
            ext: "ogm",
            mime: "video/ogg"
          };
        }
        if (check([127, 70, 76, 65, 67], { offset: 28 })) {
          return {
            ext: "oga",
            mime: "audio/ogg"
          };
        }
        if (check([83, 112, 101, 101, 120, 32, 32], { offset: 28 })) {
          return {
            ext: "spx",
            mime: "audio/ogg"
          };
        }
        if (check([1, 118, 111, 114, 98, 105, 115], { offset: 28 })) {
          return {
            ext: "ogg",
            mime: "audio/ogg"
          };
        }
        return {
          ext: "ogx",
          mime: "application/ogg"
        };
      }
      if (check([102, 76, 97, 67])) {
        return {
          ext: "flac",
          mime: "audio/x-flac"
        };
      }
      if (check([77, 65, 67, 32])) {
        return {
          ext: "ape",
          mime: "audio/ape"
        };
      }
      if (check([119, 118, 112, 107])) {
        return {
          ext: "wv",
          mime: "audio/wavpack"
        };
      }
      if (check([35, 33, 65, 77, 82, 10])) {
        return {
          ext: "amr",
          mime: "audio/amr"
        };
      }
      if (check([37, 80, 68, 70])) {
        return {
          ext: "pdf",
          mime: "application/pdf"
        };
      }
      if (check([77, 90])) {
        return {
          ext: "exe",
          mime: "application/x-msdownload"
        };
      }
      if ((buf[0] === 67 || buf[0] === 70) && check([87, 83], { offset: 1 })) {
        return {
          ext: "swf",
          mime: "application/x-shockwave-flash"
        };
      }
      if (check([123, 92, 114, 116, 102])) {
        return {
          ext: "rtf",
          mime: "application/rtf"
        };
      }
      if (check([0, 97, 115, 109])) {
        return {
          ext: "wasm",
          mime: "application/wasm"
        };
      }
      if (check([119, 79, 70, 70]) && (check([0, 1, 0, 0], { offset: 4 }) || check([79, 84, 84, 79], { offset: 4 }))) {
        return {
          ext: "woff",
          mime: "font/woff"
        };
      }
      if (check([119, 79, 70, 50]) && (check([0, 1, 0, 0], { offset: 4 }) || check([79, 84, 84, 79], { offset: 4 }))) {
        return {
          ext: "woff2",
          mime: "font/woff2"
        };
      }
      if (check([76, 80], { offset: 34 }) && (check([0, 0, 1], { offset: 8 }) || check([1, 0, 2], { offset: 8 }) || check([2, 0, 2], { offset: 8 }))) {
        return {
          ext: "eot",
          mime: "application/vnd.ms-fontobject"
        };
      }
      if (check([0, 1, 0, 0, 0])) {
        return {
          ext: "ttf",
          mime: "font/ttf"
        };
      }
      if (check([79, 84, 84, 79, 0])) {
        return {
          ext: "otf",
          mime: "font/otf"
        };
      }
      if (check([0, 0, 1, 0])) {
        return {
          ext: "ico",
          mime: "image/x-icon"
        };
      }
      if (check([0, 0, 2, 0])) {
        return {
          ext: "cur",
          mime: "image/x-icon"
        };
      }
      if (check([70, 76, 86, 1])) {
        return {
          ext: "flv",
          mime: "video/x-flv"
        };
      }
      if (check([37, 33])) {
        return {
          ext: "ps",
          mime: "application/postscript"
        };
      }
      if (check([253, 55, 122, 88, 90, 0])) {
        return {
          ext: "xz",
          mime: "application/x-xz"
        };
      }
      if (check([83, 81, 76, 105])) {
        return {
          ext: "sqlite",
          mime: "application/x-sqlite3"
        };
      }
      if (check([78, 69, 83, 26])) {
        return {
          ext: "nes",
          mime: "application/x-nintendo-nes-rom"
        };
      }
      if (check([67, 114, 50, 52])) {
        return {
          ext: "crx",
          mime: "application/x-google-chrome-extension"
        };
      }
      if (check([77, 83, 67, 70]) || check([73, 83, 99, 40])) {
        return {
          ext: "cab",
          mime: "application/vnd.ms-cab-compressed"
        };
      }
      if (check([33, 60, 97, 114, 99, 104, 62, 10, 100, 101, 98, 105, 97, 110, 45, 98, 105, 110, 97, 114, 121])) {
        return {
          ext: "deb",
          mime: "application/x-deb"
        };
      }
      if (check([33, 60, 97, 114, 99, 104, 62])) {
        return {
          ext: "ar",
          mime: "application/x-unix-archive"
        };
      }
      if (check([237, 171, 238, 219])) {
        return {
          ext: "rpm",
          mime: "application/x-rpm"
        };
      }
      if (check([31, 160]) || check([31, 157])) {
        return {
          ext: "Z",
          mime: "application/x-compress"
        };
      }
      if (check([76, 90, 73, 80])) {
        return {
          ext: "lz",
          mime: "application/x-lzip"
        };
      }
      if (check([208, 207, 17, 224, 161, 177, 26, 225])) {
        return {
          ext: "msi",
          mime: "application/x-msi"
        };
      }
      if (check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
        return {
          ext: "mxf",
          mime: "application/mxf"
        };
      }
      if (check([71], { offset: 4 }) && (check([71], { offset: 192 }) || check([71], { offset: 196 }))) {
        return {
          ext: "mts",
          mime: "video/mp2t"
        };
      }
      if (check([66, 76, 69, 78, 68, 69, 82])) {
        return {
          ext: "blend",
          mime: "application/x-blender"
        };
      }
      if (check([66, 80, 71, 251])) {
        return {
          ext: "bpg",
          mime: "image/bpg"
        };
      }
      if (check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
        if (check([106, 112, 50, 32], { offset: 20 })) {
          return {
            ext: "jp2",
            mime: "image/jp2"
          };
        }
        if (check([106, 112, 120, 32], { offset: 20 })) {
          return {
            ext: "jpx",
            mime: "image/jpx"
          };
        }
        if (check([106, 112, 109, 32], { offset: 20 })) {
          return {
            ext: "jpm",
            mime: "image/jpm"
          };
        }
        if (check([109, 106, 112, 50], { offset: 20 })) {
          return {
            ext: "mj2",
            mime: "image/mj2"
          };
        }
      }
      if (check([70, 79, 82, 77])) {
        return {
          ext: "aif",
          mime: "audio/aiff"
        };
      }
      if (checkString("<?xml ")) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      if (check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
        return {
          ext: "mobi",
          mime: "application/x-mobipocket-ebook"
        };
      }
      if (check([102, 116, 121, 112], { offset: 4 })) {
        if (check([109, 105, 102, 49], { offset: 8 })) {
          return {
            ext: "heic",
            mime: "image/heif"
          };
        }
        if (check([109, 115, 102, 49], { offset: 8 })) {
          return {
            ext: "heic",
            mime: "image/heif-sequence"
          };
        }
        if (check([104, 101, 105, 99], { offset: 8 }) || check([104, 101, 105, 120], { offset: 8 })) {
          return {
            ext: "heic",
            mime: "image/heic"
          };
        }
        if (check([104, 101, 118, 99], { offset: 8 }) || check([104, 101, 118, 120], { offset: 8 })) {
          return {
            ext: "heic",
            mime: "image/heic-sequence"
          };
        }
      }
      if (check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
        return {
          ext: "ktx",
          mime: "image/ktx"
        };
      }
      if (check([68, 73, 67, 77], { offset: 128 })) {
        return {
          ext: "dcm",
          mime: "application/dicom"
        };
      }
      if (check([77, 80, 43])) {
        return {
          ext: "mpc",
          mime: "audio/x-musepack"
        };
      }
      if (check([77, 80, 67, 75])) {
        return {
          ext: "mpc",
          mime: "audio/x-musepack"
        };
      }
      if (check([66, 69, 71, 73, 78, 58])) {
        return {
          ext: "ics",
          mime: "text/calendar"
        };
      }
      if (check([103, 108, 84, 70, 2, 0, 0, 0])) {
        return {
          ext: "glb",
          mime: "model/gltf-binary"
        };
      }
      if (check([212, 195, 178, 161]) || check([161, 178, 195, 212])) {
        return {
          ext: "pcap",
          mime: "application/vnd.tcpdump.pcap"
        };
      }
      return null;
    };
    module.exports = fileType;
    module.exports.default = fileType;
    Object.defineProperty(fileType, "minimumBytes", { value: 4100 });
    module.exports.stream = (readableStream) => new Promise((resolve, reject) => {
      const stream = eval("require")("stream");
      readableStream.once("readable", () => {
        const pass = new stream.PassThrough();
        const chunk = readableStream.read(module.exports.minimumBytes) || readableStream.read();
        try {
          pass.fileType = fileType(chunk);
        } catch (error) {
          reject(error);
        }
        readableStream.unshift(chunk);
        if (stream.pipeline) {
          resolve(stream.pipeline(readableStream, pass, () => {
          }));
        } else {
          resolve(readableStream.pipe(pass));
        }
      });
    });
  }
});

// node_modules/image-type/index.js
var require_image_type = __commonJS({
  "node_modules/image-type/index.js"(exports2, module2) {
    "use strict";
    var fileType2 = require_file_type();
    var imageExts = /* @__PURE__ */ new Set([
      "jpg",
      "png",
      "gif",
      "webp",
      "flif",
      "cr2",
      "tif",
      "bmp",
      "jxr",
      "psd",
      "ico",
      "bpg",
      "jp2",
      "jpm",
      "jpx",
      "heic",
      "cur",
      "dcm"
    ]);
    var imageType = (input) => {
      const ret = fileType2(input);
      return imageExts.has(ret && ret.ext) ? ret : null;
    };
    module2.exports = imageType;
    module2.exports.default = imageType;
    Object.defineProperty(imageType, "minimumBytes", { value: fileType2.minimumBytes });
  }
});

// node_modules/tiff/lib/hacks.js
var require_hacks = __commonJS({
  "node_modules/tiff/lib/hacks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.guessStripByteCounts = void 0;
    function guessStripByteCounts(ifd) {
      if (ifd.compression !== 1) {
        throw new Error("missing mandatory StripByteCounts field in compressed image");
      }
      const bytesPerStrip = ifd.rowsPerStrip * ifd.width * ifd.samplesPerPixel * (ifd.bitsPerSample / 8);
      return new Array(ifd.stripOffsets.length).fill(bytesPerStrip);
    }
    exports2.guessStripByteCounts = guessStripByteCounts;
  }
});

// node_modules/tiff/lib/horizontalDifferencing.js
var require_horizontalDifferencing = __commonJS({
  "node_modules/tiff/lib/horizontalDifferencing.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.applyHorizontalDifferencing16Bit = exports2.applyHorizontalDifferencing8Bit = void 0;
    function applyHorizontalDifferencing8Bit(data, width, components) {
      let i = 0;
      while (i < data.length) {
        for (let j = components; j < width * components; j += components) {
          for (let k = 0; k < components; k++) {
            data[i + j + k] = data[i + j + k] + data[i + j - (components - k)] & 255;
          }
        }
        i += width * components;
      }
    }
    exports2.applyHorizontalDifferencing8Bit = applyHorizontalDifferencing8Bit;
    function applyHorizontalDifferencing16Bit(data, width, components) {
      let i = 0;
      while (i < data.length) {
        for (let j = components; j < width * components; j += components) {
          for (let k = 0; k < components; k++) {
            data[i + j + k] = data[i + j + k] + data[i + j - (components - k)] & 65535;
          }
        }
        i += width * components;
      }
    }
    exports2.applyHorizontalDifferencing16Bit = applyHorizontalDifferencing16Bit;
  }
});

// node_modules/tiff/lib/tags/exif.js
var require_exif2 = __commonJS({
  "node_modules/tiff/lib/tags/exif.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tagsByName = exports2.tagsById = void 0;
    var tagsById = {
      33434: "ExposureTime",
      33437: "FNumber",
      34850: "ExposureProgram",
      34852: "SpectralSensitivity",
      34855: "ISOSpeedRatings",
      34856: "OECF",
      34864: "SensitivityType",
      34865: "StandardOutputSensitivity",
      34866: "RecommendedExposureIndex",
      34867: "ISOSpeed",
      34868: "ISOSpeedLatitudeyyy",
      34869: "ISOSpeedLatitudezzz",
      36864: "ExifVersion",
      36867: "DateTimeOriginal",
      36868: "DateTimeDigitized",
      37121: "ComponentsConfiguration",
      37122: "CompressedBitsPerPixel",
      37377: "ShutterSpeedValue",
      37378: "ApertureValue",
      37379: "BrightnessValue",
      37380: "ExposureBiasValue",
      37381: "MaxApertureValue",
      37382: "SubjectDistance",
      37383: "MeteringMode",
      37384: "LightSource",
      37385: "Flash",
      37386: "FocalLength",
      37396: "SubjectArea",
      37500: "MakerNote",
      37510: "UserComment",
      37520: "SubsecTime",
      37521: "SubsecTimeOriginal",
      37522: "SubsecTimeDigitized",
      40960: "FlashpixVersion",
      40961: "ColorSpace",
      40962: "PixelXDimension",
      40963: "PixelYDimension",
      40964: "RelatedSoundFile",
      41483: "FlashEnergy",
      41484: "SpatialFrequencyResponse",
      41486: "FocalPlaneXResolution",
      41487: "FocalPlaneYResolution",
      41488: "FocalPlaneResolutionUnit",
      41492: "SubjectLocation",
      41493: "ExposureIndex",
      41495: "SensingMethod",
      41728: "FileSource",
      41729: "SceneType",
      41730: "CFAPattern",
      41985: "CustomRendered",
      41986: "ExposureMode",
      41987: "WhiteBalance",
      41988: "DigitalZoomRatio",
      41989: "FocalLengthIn35mmFilm",
      41990: "SceneCaptureType",
      41991: "GainControl",
      41992: "Contrast",
      41993: "Saturation",
      41994: "Sharpness",
      41995: "DeviceSettingDescription",
      41996: "SubjectDistanceRange",
      42016: "ImageUniqueID",
      42032: "CameraOwnerName",
      42033: "BodySerialNumber",
      42034: "LensSpecification",
      42035: "LensMake",
      42036: "LensModel",
      42037: "LensSerialNumber",
      42240: "Gamma"
    };
    exports2.tagsById = tagsById;
    var tagsByName = {};
    exports2.tagsByName = tagsByName;
    for (let i in tagsById) {
      tagsByName[tagsById[i]] = Number(i);
    }
  }
});

// node_modules/tiff/lib/tags/gps.js
var require_gps2 = __commonJS({
  "node_modules/tiff/lib/tags/gps.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tagsByName = exports2.tagsById = void 0;
    var tagsById = {
      0: "GPSVersionID",
      1: "GPSLatitudeRef",
      2: "GPSLatitude",
      3: "GPSLongitudeRef",
      4: "GPSLongitude",
      5: "GPSAltitudeRef",
      6: "GPSAltitude",
      7: "GPSTimeStamp",
      8: "GPSSatellites",
      9: "GPSStatus",
      10: "GPSMeasureMode",
      11: "GPSDOP",
      12: "GPSSpeedRef",
      13: "GPSSpeed",
      14: "GPSTrackRef",
      15: "GPSTrack",
      16: "GPSImgDirectionRef",
      17: "GPSImgDirection",
      18: "GPSMapDatum",
      19: "GPSDestLatitudeRef",
      20: "GPSDestLatitude",
      21: "GPSDestLongitudeRef",
      22: "GPSDestLongitude",
      23: "GPSDestBearingRef",
      24: "GPSDestBearing",
      25: "GPSDestDistanceRef",
      26: "GPSDestDistance",
      27: "GPSProcessingMethod",
      28: "GPSAreaInformation",
      29: "GPSDateStamp",
      30: "GPSDifferential",
      31: "GPSHPositioningError"
    };
    exports2.tagsById = tagsById;
    var tagsByName = {};
    exports2.tagsByName = tagsByName;
    for (let i in tagsById) {
      tagsByName[tagsById[i]] = Number(i);
    }
  }
});

// node_modules/tiff/lib/tags/standard.js
var require_standard2 = __commonJS({
  "node_modules/tiff/lib/tags/standard.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tagsByName = exports2.tagsById = void 0;
    var tagsById = {
      // Baseline tags
      254: "NewSubfileType",
      255: "SubfileType",
      256: "ImageWidth",
      257: "ImageLength",
      258: "BitsPerSample",
      259: "Compression",
      262: "PhotometricInterpretation",
      263: "Threshholding",
      264: "CellWidth",
      265: "CellLength",
      266: "FillOrder",
      270: "ImageDescription",
      271: "Make",
      272: "Model",
      273: "StripOffsets",
      274: "Orientation",
      277: "SamplesPerPixel",
      278: "RowsPerStrip",
      279: "StripByteCounts",
      280: "MinSampleValue",
      281: "MaxSampleValue",
      282: "XResolution",
      283: "YResolution",
      284: "PlanarConfiguration",
      288: "FreeOffsets",
      289: "FreeByteCounts",
      290: "GrayResponseUnit",
      291: "GrayResponseCurve",
      296: "ResolutionUnit",
      305: "Software",
      306: "DateTime",
      315: "Artist",
      316: "HostComputer",
      320: "ColorMap",
      338: "ExtraSamples",
      33432: "Copyright",
      // Extension tags
      269: "DocumentName",
      285: "PageName",
      286: "XPosition",
      287: "YPosition",
      292: "T4Options",
      293: "T6Options",
      297: "PageNumber",
      301: "TransferFunction",
      317: "Predictor",
      318: "WhitePoint",
      319: "PrimaryChromaticities",
      321: "HalftoneHints",
      322: "TileWidth",
      323: "TileLength",
      324: "TileOffsets",
      325: "TileByteCounts",
      326: "BadFaxLines",
      327: "CleanFaxData",
      328: "ConsecutiveBadFaxLines",
      330: "SubIFDs",
      332: "InkSet",
      333: "InkNames",
      334: "NumberOfInks",
      336: "DotRange",
      337: "TargetPrinter",
      339: "SampleFormat",
      340: "SMinSampleValue",
      341: "SMaxSampleValue",
      342: "TransferRange",
      343: "ClipPath",
      344: "XClipPathUnits",
      345: "YClipPathUnits",
      346: "Indexed",
      347: "JPEGTables",
      351: "OPIProxy",
      400: "GlobalParametersIFD",
      401: "ProfileType",
      402: "FaxProfile",
      403: "CodingMethods",
      404: "VersionYear",
      405: "ModeNumber",
      433: "Decode",
      434: "DefaultImageColor",
      512: "JPEGProc",
      513: "JPEGInterchangeFormat",
      514: "JPEGInterchangeFormatLength",
      515: "JPEGRestartInterval",
      517: "JPEGLosslessPredictors",
      518: "JPEGPointTransforms",
      519: "JPEGQTables",
      520: "JPEGDCTables",
      521: "JPEGACTables",
      529: "YCbCrCoefficients",
      530: "YCbCrSubSampling",
      531: "YCbCrPositioning",
      532: "ReferenceBlackWhite",
      559: "StripRowCounts",
      700: "XMP",
      32781: "ImageID",
      34732: "ImageLayer",
      // Private tags
      32932: "WangAnnotatio",
      33445: "MDFileTag",
      33446: "MDScalePixel",
      33447: "MDColorTable",
      33448: "MDLabName",
      33449: "MDSampleInfo",
      33450: "MDPrepDate",
      33451: "MDPrepTime",
      33452: "MDFileUnits",
      33550: "ModelPixelScaleTag",
      33723: "IPTC",
      33918: "INGRPacketDataTag",
      33919: "INGRFlagRegisters",
      33920: "IrasBTransformationMatrix",
      33922: "ModelTiepointTag",
      34264: "ModelTransformationTag",
      34377: "Photoshop",
      34665: "ExifIFD",
      34675: "ICCProfile",
      34735: "GeoKeyDirectoryTag",
      34736: "GeoDoubleParamsTag",
      34737: "GeoAsciiParamsTag",
      34853: "GPSIFD",
      34908: "HylaFAXFaxRecvParams",
      34909: "HylaFAXFaxSubAddress",
      34910: "HylaFAXFaxRecvTime",
      37724: "ImageSourceData",
      40965: "InteroperabilityIFD",
      42112: "GDAL_METADATA",
      42113: "GDAL_NODATA",
      50215: "OceScanjobDescription",
      50216: "OceApplicationSelector",
      50217: "OceIdentificationNumber",
      50218: "OceImageLogicCharacteristics",
      50706: "DNGVersion",
      50707: "DNGBackwardVersion",
      50708: "UniqueCameraModel",
      50709: "LocalizedCameraModel",
      50710: "CFAPlaneColor",
      50711: "CFALayout",
      50712: "LinearizationTable",
      50713: "BlackLevelRepeatDim",
      50714: "BlackLevel",
      50715: "BlackLevelDeltaH",
      50716: "BlackLevelDeltaV",
      50717: "WhiteLevel",
      50718: "DefaultScale",
      50719: "DefaultCropOrigin",
      50720: "DefaultCropSize",
      50721: "ColorMatrix1",
      50722: "ColorMatrix2",
      50723: "CameraCalibration1",
      50724: "CameraCalibration2",
      50725: "ReductionMatrix1",
      50726: "ReductionMatrix2",
      50727: "AnalogBalance",
      50728: "AsShotNeutral",
      50729: "AsShotWhiteXY",
      50730: "BaselineExposure",
      50731: "BaselineNoise",
      50732: "BaselineSharpness",
      50733: "BayerGreenSplit",
      50734: "LinearResponseLimit",
      50735: "CameraSerialNumber",
      50736: "LensInfo",
      50737: "ChromaBlurRadius",
      50738: "AntiAliasStrength",
      50740: "DNGPrivateData",
      50741: "MakerNoteSafety",
      50778: "CalibrationIlluminant1",
      50779: "CalibrationIlluminant2",
      50780: "BestQualityScale",
      50784: "AliasLayerMetadata"
    };
    exports2.tagsById = tagsById;
    var tagsByName = {};
    exports2.tagsByName = tagsByName;
    for (let i in tagsById) {
      tagsByName[tagsById[i]] = Number(i);
    }
  }
});

// node_modules/tiff/lib/ifd.js
var require_ifd2 = __commonJS({
  "node_modules/tiff/lib/ifd.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var exif = __importStar(require_exif2());
    var gps = __importStar(require_gps2());
    var standard = __importStar(require_standard2());
    var tags = {
      standard,
      exif,
      gps
    };
    var IFD = class {
      constructor(kind) {
        if (!kind) {
          throw new Error("missing kind");
        }
        this.data = new Uint8Array();
        this.fields = /* @__PURE__ */ new Map();
        this.kind = kind;
        this._hasMap = false;
        this._map = {};
      }
      get(tag) {
        if (typeof tag === "number") {
          return this.fields.get(tag);
        } else if (typeof tag === "string") {
          return this.fields.get(tags[this.kind].tagsByName[tag]);
        } else {
          throw new Error("expected a number or string");
        }
      }
      get map() {
        if (!this._hasMap) {
          const taglist = tags[this.kind].tagsById;
          for (let key of this.fields.keys()) {
            if (taglist[key]) {
              this._map[taglist[key]] = this.fields.get(key);
            }
          }
          this._hasMap = true;
        }
        return this._map;
      }
    };
    exports2.default = IFD;
  }
});

// node_modules/tiff/lib/ifdValue.js
var require_ifdValue2 = __commonJS({
  "node_modules/tiff/lib/ifdValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.readData = exports2.getByteLength = void 0;
    var types = /* @__PURE__ */ new Map([
      [1, [1, readByte]],
      [2, [1, readASCII]],
      [3, [2, readShort]],
      [4, [4, readLong]],
      [5, [8, readRational]],
      [6, [1, readSByte]],
      [7, [1, readByte]],
      [8, [2, readSShort]],
      [9, [4, readSLong]],
      [10, [8, readSRational]],
      [11, [4, readFloat]],
      [12, [8, readDouble]]
      // DOUBLE
    ]);
    function getByteLength(type, count) {
      const val = types.get(type);
      if (!val)
        throw new Error(`type not found: ${type}`);
      return val[0] * count;
    }
    exports2.getByteLength = getByteLength;
    function readData(decoder, type, count) {
      const val = types.get(type);
      if (!val)
        throw new Error(`type not found: ${type}`);
      return val[1](decoder, count);
    }
    exports2.readData = readData;
    function readByte(decoder, count) {
      if (count === 1)
        return decoder.readUint8();
      let array = new Uint8Array(count);
      for (let i = 0; i < count; i++) {
        array[i] = decoder.readUint8();
      }
      return array;
    }
    function readASCII(decoder, count) {
      let strings = [];
      let currentString = "";
      for (let i = 0; i < count; i++) {
        let char = String.fromCharCode(decoder.readUint8());
        if (char === "\0") {
          strings.push(currentString);
          currentString = "";
        } else {
          currentString += char;
        }
      }
      if (strings.length === 1) {
        return strings[0];
      } else {
        return strings;
      }
    }
    function readShort(decoder, count) {
      if (count === 1)
        return decoder.readUint16();
      let array = new Uint16Array(count);
      for (let i = 0; i < count; i++) {
        array[i] = decoder.readUint16();
      }
      return array;
    }
    function readLong(decoder, count) {
      if (count === 1)
        return decoder.readUint32();
      let array = new Uint32Array(count);
      for (let i = 0; i < count; i++) {
        array[i] = decoder.readUint32();
      }
      return array;
    }
    function readRational(decoder, count) {
      if (count === 1) {
        return decoder.readUint32() / decoder.readUint32();
      }
      let rationals = new Array(count);
      for (let i = 0; i < count; i++) {
        rationals[i] = decoder.readUint32() / decoder.readUint32();
      }
      return rationals;
    }
    function readSByte(decoder, count) {
      if (count === 1)
        return decoder.readInt8();
      let array = new Int8Array(count);
      for (let i = 0; i < count; i++) {
        array[i] = decoder.readInt8();
      }
      return array;
    }
    function readSShort(decoder, count) {
      if (count === 1)
        return decoder.readInt16();
      let array = new Int16Array(count);
      for (let i = 0; i < count; i++) {
        array[i] = decoder.readInt16();
      }
      return array;
    }
    function readSLong(decoder, count) {
      if (count === 1)
        return decoder.readInt32();
      let array = new Int32Array(count);
      for (let i = 0; i < count; i++) {
        array[i] = decoder.readInt32();
      }
      return array;
    }
    function readSRational(decoder, count) {
      if (count === 1) {
        return decoder.readInt32() / decoder.readInt32();
      }
      let rationals = new Array(count);
      for (let i = 0; i < count; i++) {
        rationals[i] = decoder.readInt32() / decoder.readInt32();
      }
      return rationals;
    }
    function readFloat(decoder, count) {
      if (count === 1)
        return decoder.readFloat32();
      let array = new Float32Array(count);
      for (let i = 0; i < count; i++) {
        array[i] = decoder.readFloat32();
      }
      return array;
    }
    function readDouble(decoder, count) {
      if (count === 1)
        return decoder.readFloat64();
      let array = new Float64Array(count);
      for (let i = 0; i < count; i++) {
        array[i] = decoder.readFloat64();
      }
      return array;
    }
  }
});

// node_modules/tiff/lib/lzw.js
var require_lzw = __commonJS({
  "node_modules/tiff/lib/lzw.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decompressLzw = void 0;
    var iobuffer_1 = require_IOBuffer();
    var CLEAR_CODE = 256;
    var EOI_CODE = 257;
    var TABLE_START = 258;
    var MIN_BIT_LENGTH = 9;
    var stringTable = [];
    function initializeStringTable() {
      if (stringTable.length === 0) {
        for (let i = 0; i < 256; i++) {
          stringTable.push([i]);
        }
        const dummyString = [];
        for (let i = 256; i < 4096; i++) {
          stringTable.push(dummyString);
        }
      }
    }
    var andTable = [511, 1023, 2047, 4095];
    var bitJumps = [0, 0, 0, 0, 0, 0, 0, 0, 0, 511, 1023, 2047, 4095];
    var LzwDecoder = class {
      constructor(data) {
        this.nextData = 0;
        this.nextBits = 0;
        this.bytePointer = 0;
        this.tableLength = TABLE_START;
        this.currentBitLength = MIN_BIT_LENGTH;
        this.stripArray = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
        this.outData = new iobuffer_1.IOBuffer(data.byteLength);
        this.initializeTable();
      }
      decode() {
        let code = 0;
        let oldCode = 0;
        while ((code = this.getNextCode()) !== EOI_CODE) {
          if (code === CLEAR_CODE) {
            this.initializeTable();
            code = this.getNextCode();
            if (code === EOI_CODE) {
              break;
            }
            this.writeString(this.stringFromCode(code));
            oldCode = code;
          } else if (this.isInTable(code)) {
            this.writeString(this.stringFromCode(code));
            this.addStringToTable(this.stringFromCode(oldCode).concat(this.stringFromCode(code)[0]));
            oldCode = code;
          } else {
            const outString = this.stringFromCode(oldCode).concat(this.stringFromCode(oldCode)[0]);
            this.writeString(outString);
            this.addStringToTable(outString);
            oldCode = code;
          }
        }
        const outArray = this.outData.toArray();
        return new DataView(outArray.buffer, outArray.byteOffset, outArray.byteLength);
      }
      initializeTable() {
        initializeStringTable();
        this.tableLength = TABLE_START;
        this.currentBitLength = MIN_BIT_LENGTH;
      }
      writeString(string) {
        this.outData.writeBytes(string);
      }
      stringFromCode(code) {
        return stringTable[code];
      }
      isInTable(code) {
        return code < this.tableLength;
      }
      addStringToTable(string) {
        stringTable[this.tableLength++] = string;
        if (stringTable.length > 4096) {
          stringTable = [];
          throw new Error("LZW decoding error. Please open an issue at https://github.com/image-js/tiff/issues/new/choose (include a test image).");
        }
        if (this.tableLength === bitJumps[this.currentBitLength]) {
          this.currentBitLength++;
        }
      }
      getNextCode() {
        this.nextData = this.nextData << 8 | this.stripArray[this.bytePointer++] & 255;
        this.nextBits += 8;
        if (this.nextBits < this.currentBitLength) {
          this.nextData = this.nextData << 8 | this.stripArray[this.bytePointer++] & 255;
          this.nextBits += 8;
        }
        const code = this.nextData >> this.nextBits - this.currentBitLength & andTable[this.currentBitLength - 9];
        this.nextBits -= this.currentBitLength;
        if (this.bytePointer > this.stripArray.length) {
          return 257;
        }
        return code;
      }
    };
    function decompressLzw(stripData) {
      return new LzwDecoder(stripData).decode();
    }
    exports2.decompressLzw = decompressLzw;
  }
});

// node_modules/tiff/lib/tiffIfd.js
var require_tiffIfd2 = __commonJS({
  "node_modules/tiff/lib/tiffIfd.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ifd_1 = __importDefault(require_ifd2());
    var dateTimeRegex = /^(\d{4}):(\d{2}):(\d{2}) (\d{2}):(\d{2}):(\d{2})$/;
    var TiffIfd = class extends ifd_1.default {
      constructor() {
        super("standard");
      }
      // Custom fields
      get size() {
        return this.width * this.height;
      }
      get width() {
        return this.imageWidth;
      }
      get height() {
        return this.imageLength;
      }
      get components() {
        return this.samplesPerPixel;
      }
      get date() {
        let date = new Date();
        let result = dateTimeRegex.exec(this.dateTime);
        if (result === null) {
          throw new Error(`invalid dateTime: ${this.dateTime}`);
        }
        date.setFullYear(Number(result[1]), Number(result[2]) - 1, Number(result[3]));
        date.setHours(Number(result[4]), Number(result[5]), Number(result[6]));
        return date;
      }
      // IFD fields
      get newSubfileType() {
        return this.get("NewSubfileType");
      }
      get imageWidth() {
        return this.get("ImageWidth");
      }
      get imageLength() {
        return this.get("ImageLength");
      }
      get bitsPerSample() {
        const data = this.get("BitsPerSample");
        if (data && typeof data !== "number") {
          return data[0];
        }
        return data;
      }
      get alpha() {
        const extraSamples = this.extraSamples;
        if (!extraSamples)
          return false;
        return extraSamples[0] !== 0;
      }
      get associatedAlpha() {
        const extraSamples = this.extraSamples;
        if (!extraSamples)
          return false;
        return extraSamples[0] === 1;
      }
      get extraSamples() {
        return alwaysArray(this.get("ExtraSamples"));
      }
      get compression() {
        return this.get("Compression") || 1;
      }
      get type() {
        return this.get("PhotometricInterpretation");
      }
      get fillOrder() {
        return this.get("FillOrder") || 1;
      }
      get documentName() {
        return this.get("DocumentName");
      }
      get imageDescription() {
        return this.get("ImageDescription");
      }
      get stripOffsets() {
        return alwaysArray(this.get("StripOffsets"));
      }
      get orientation() {
        return this.get("Orientation");
      }
      get samplesPerPixel() {
        return this.get("SamplesPerPixel") || 1;
      }
      get rowsPerStrip() {
        return this.get("RowsPerStrip");
      }
      get stripByteCounts() {
        return alwaysArray(this.get("StripByteCounts"));
      }
      get minSampleValue() {
        return this.get("MinSampleValue") || 0;
      }
      get maxSampleValue() {
        return this.get("MaxSampleValue") || Math.pow(2, this.bitsPerSample) - 1;
      }
      get xResolution() {
        return this.get("XResolution");
      }
      get yResolution() {
        return this.get("YResolution");
      }
      get planarConfiguration() {
        return this.get("PlanarConfiguration") || 1;
      }
      get resolutionUnit() {
        return this.get("ResolutionUnit") || 2;
      }
      get dateTime() {
        return this.get("DateTime");
      }
      get predictor() {
        return this.get("Predictor") || 1;
      }
      get sampleFormat() {
        return this.get("SampleFormat") || 1;
      }
      get sMinSampleValue() {
        return this.get("SMinSampleValue") || this.minSampleValue;
      }
      get sMaxSampleValue() {
        return this.get("SMaxSampleValue") || this.maxSampleValue;
      }
      get palette() {
        const totalColors = 2 ** this.bitsPerSample;
        const colorMap = this.get("ColorMap");
        if (!colorMap)
          return void 0;
        if (colorMap.length !== 3 * totalColors) {
          throw new Error(`ColorMap size must be ${totalColors}`);
        }
        const palette = [];
        for (let i = 0; i < totalColors; i++) {
          palette.push([
            colorMap[i],
            colorMap[i + totalColors],
            colorMap[i + 2 * totalColors]
          ]);
        }
        return palette;
      }
    };
    exports2.default = TiffIfd;
    function alwaysArray(value) {
      if (typeof value === "number")
        return [value];
      return value;
    }
  }
});

// node_modules/tiff/lib/zlib.js
var require_zlib = __commonJS({
  "node_modules/tiff/lib/zlib.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decompressZlib = void 0;
    var pako_1 = require_pako();
    function decompressZlib(stripData) {
      const stripUint8 = new Uint8Array(stripData.buffer, stripData.byteOffset, stripData.byteLength);
      const inflated = (0, pako_1.inflate)(stripUint8);
      return new DataView(inflated.buffer, inflated.byteOffset, inflated.byteLength);
    }
    exports2.decompressZlib = decompressZlib;
  }
});

// node_modules/tiff/lib/tiffDecoder.js
var require_tiffDecoder2 = __commonJS({
  "node_modules/tiff/lib/tiffDecoder.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var iobuffer_1 = require_IOBuffer();
    var hacks_1 = require_hacks();
    var horizontalDifferencing_1 = require_horizontalDifferencing();
    var ifd_1 = __importDefault(require_ifd2());
    var ifdValue_1 = require_ifdValue2();
    var lzw_1 = require_lzw();
    var tiffIfd_1 = __importDefault(require_tiffIfd2());
    var zlib_1 = require_zlib();
    var defaultOptions = {
      ignoreImageData: false,
      onlyFirst: false
    };
    var TIFFDecoder = class extends iobuffer_1.IOBuffer {
      constructor(data) {
        super(data);
        this._nextIFD = 0;
      }
      get isMultiPage() {
        let c = 0;
        this.decodeHeader();
        while (this._nextIFD) {
          c++;
          this.decodeIFD({ ignoreImageData: true }, true);
          if (c === 2) {
            return true;
          }
        }
        if (c === 1) {
          return false;
        }
        throw unsupported("ifdCount", c);
      }
      get pageCount() {
        let c = 0;
        this.decodeHeader();
        while (this._nextIFD) {
          c++;
          this.decodeIFD({ ignoreImageData: true }, true);
        }
        if (c > 0) {
          return c;
        }
        throw unsupported("ifdCount", c);
      }
      decode(options = {}) {
        options = Object.assign({}, defaultOptions, options);
        const result = [];
        this.decodeHeader();
        while (this._nextIFD) {
          result.push(this.decodeIFD(options, true));
          if (options.onlyFirst) {
            return [result[0]];
          }
        }
        return result;
      }
      decodeHeader() {
        const value = this.readUint16();
        if (value === 18761) {
          this.setLittleEndian();
        } else if (value === 19789) {
          this.setBigEndian();
        } else {
          throw new Error(`invalid byte order: 0x${value.toString(16)}`);
        }
        if (this.readUint16() !== 42) {
          throw new Error("not a TIFF file");
        }
        this._nextIFD = this.readUint32();
      }
      decodeIFD(options, tiff) {
        this.seek(this._nextIFD);
        let ifd;
        if (tiff) {
          ifd = new tiffIfd_1.default();
        } else {
          if (!options.kind) {
            throw new Error(`kind is missing`);
          }
          ifd = new ifd_1.default(options.kind);
        }
        const numEntries = this.readUint16();
        for (let i = 0; i < numEntries; i++) {
          this.decodeIFDEntry(ifd);
        }
        if (!options.ignoreImageData) {
          if (!(ifd instanceof tiffIfd_1.default)) {
            throw new Error("must be a tiff ifd");
          }
          this.decodeImageData(ifd);
        }
        this._nextIFD = this.readUint32();
        return ifd;
      }
      decodeIFDEntry(ifd) {
        const offset = this.offset;
        const tag = this.readUint16();
        const type = this.readUint16();
        const numValues = this.readUint32();
        if (type < 1 || type > 12) {
          this.skip(4);
          return;
        }
        const valueByteLength = (0, ifdValue_1.getByteLength)(type, numValues);
        if (valueByteLength > 4) {
          this.seek(this.readUint32());
        }
        const value = (0, ifdValue_1.readData)(this, type, numValues);
        ifd.fields.set(tag, value);
        if (tag === 34665 || tag === 34853) {
          let currentOffset = this.offset;
          let kind = "exif";
          if (tag === 34665) {
            kind = "exif";
          } else if (tag === 34853) {
            kind = "gps";
          }
          this._nextIFD = value;
          ifd[kind] = this.decodeIFD({
            kind,
            ignoreImageData: true
          }, false);
          this.offset = currentOffset;
        }
        this.seek(offset);
        this.skip(12);
      }
      decodeImageData(ifd) {
        const orientation = ifd.orientation;
        if (orientation && orientation !== 1) {
          throw unsupported("orientation", orientation);
        }
        switch (ifd.type) {
          case 0:
          case 1:
          case 2:
          case 3:
            this.readStripData(ifd);
            break;
          default:
            throw unsupported("image type", ifd.type);
        }
        this.applyPredictor(ifd);
        this.convertAlpha(ifd);
        if (ifd.type === 0) {
          const bitDepth = ifd.bitsPerSample;
          const maxValue = Math.pow(2, bitDepth) - 1;
          for (let i = 0; i < ifd.data.length; i++) {
            ifd.data[i] = maxValue - ifd.data[i];
          }
        }
      }
      readStripData(ifd) {
        const width = ifd.width;
        const height = ifd.height;
        const bitDepth = ifd.bitsPerSample;
        const sampleFormat = ifd.sampleFormat;
        const size = width * height * ifd.samplesPerPixel;
        const data = getDataArray(size, bitDepth, sampleFormat);
        const rowsPerStrip = ifd.rowsPerStrip;
        const maxPixels = rowsPerStrip * width * ifd.samplesPerPixel;
        const stripOffsets = ifd.stripOffsets;
        const stripByteCounts = ifd.stripByteCounts || (0, hacks_1.guessStripByteCounts)(ifd);
        let remainingPixels = size;
        let pixel = 0;
        for (let i = 0; i < stripOffsets.length; i++) {
          let stripData = new DataView(this.buffer, this.byteOffset + stripOffsets[i], stripByteCounts[i]);
          let length = remainingPixels > maxPixels ? maxPixels : remainingPixels;
          remainingPixels -= length;
          let dataToFill = stripData;
          switch (ifd.compression) {
            case 1: {
              break;
            }
            case 5: {
              dataToFill = (0, lzw_1.decompressLzw)(stripData);
              break;
            }
            case 8: {
              dataToFill = (0, zlib_1.decompressZlib)(stripData);
              break;
            }
            case 2:
              throw unsupported("Compression", "CCITT Group 3");
            case 32773:
              throw unsupported("Compression", "PackBits");
            default:
              throw unsupported("Compression", ifd.compression);
          }
          pixel = this.fillUncompressed(bitDepth, sampleFormat, data, dataToFill, pixel, length);
        }
        ifd.data = data;
      }
      fillUncompressed(bitDepth, sampleFormat, data, stripData, pixel, length) {
        if (bitDepth === 8) {
          return fill8bit(data, stripData, pixel, length);
        } else if (bitDepth === 16) {
          return fill16bit(data, stripData, pixel, length, this.isLittleEndian());
        } else if (bitDepth === 32 && sampleFormat === 3) {
          return fillFloat32(data, stripData, pixel, length, this.isLittleEndian());
        } else {
          throw unsupported("bitDepth", bitDepth);
        }
      }
      applyPredictor(ifd) {
        const bitDepth = ifd.bitsPerSample;
        switch (ifd.predictor) {
          case 1: {
            break;
          }
          case 2: {
            if (bitDepth === 8) {
              (0, horizontalDifferencing_1.applyHorizontalDifferencing8Bit)(ifd.data, ifd.width, ifd.components);
            } else if (bitDepth === 16) {
              (0, horizontalDifferencing_1.applyHorizontalDifferencing16Bit)(ifd.data, ifd.width, ifd.components);
            } else {
              throw new Error(`Horizontal differencing is only supported for images with a bit depth of ${bitDepth}`);
            }
            break;
          }
          default:
            throw new Error(`invalid predictor: ${ifd.predictor}`);
        }
      }
      convertAlpha(ifd) {
        if (ifd.alpha && ifd.associatedAlpha) {
          const { data, components, maxSampleValue } = ifd;
          for (let i = 0; i < data.length; i += components) {
            const alphaValue = data[i + components - 1];
            for (let j = 0; j < components - 1; j++) {
              data[i + j] = Math.round(data[i + j] * maxSampleValue / alphaValue);
            }
          }
        }
      }
    };
    exports2.default = TIFFDecoder;
    function getDataArray(size, bitDepth, sampleFormat) {
      if (bitDepth === 8) {
        return new Uint8Array(size);
      } else if (bitDepth === 16) {
        return new Uint16Array(size);
      } else if (bitDepth === 32 && sampleFormat === 3) {
        return new Float32Array(size);
      } else {
        throw unsupported("bit depth / sample format", `${bitDepth} / ${sampleFormat}`);
      }
    }
    function fill8bit(dataTo, dataFrom, index, length) {
      for (let i = 0; i < length; i++) {
        dataTo[index++] = dataFrom.getUint8(i);
      }
      return index;
    }
    function fill16bit(dataTo, dataFrom, index, length, littleEndian) {
      for (let i = 0; i < length * 2; i += 2) {
        dataTo[index++] = dataFrom.getUint16(i, littleEndian);
      }
      return index;
    }
    function fillFloat32(dataTo, dataFrom, index, length, littleEndian) {
      for (let i = 0; i < length * 4; i += 4) {
        dataTo[index++] = dataFrom.getFloat32(i, littleEndian);
      }
      return index;
    }
    function unsupported(type, value) {
      return new Error(`Unsupported ${type}: ${value}`);
    }
  }
});

// node_modules/tiff/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/tiff/lib/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pageCount = exports2.isMultiPage = exports2.decode = void 0;
    var tiffDecoder_1 = __importDefault(require_tiffDecoder2());
    function decodeTIFF(data, options) {
      const decoder = new tiffDecoder_1.default(data);
      return decoder.decode(options);
    }
    exports2.decode = decodeTIFF;
    function isMultiPage(data) {
      const decoder = new tiffDecoder_1.default(data);
      return decoder.isMultiPage;
    }
    exports2.isMultiPage = isMultiPage;
    function pageCount(data) {
      const decoder = new tiffDecoder_1.default(data);
      return decoder.pageCount;
    }
    exports2.pageCount = pageCount;
  }
});

// node_modules/image-js/lib/stack/transform/matchAndCrop.js
var require_matchAndCrop = __commonJS({
  "node_modules/image-js/lib/stack/transform/matchAndCrop.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = matchAndCrop;
    var _Stack = _interopRequireDefault(require_Stack());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function matchAndCrop(options = {}) {
      let {
        algorithm = "matchToPrevious",
        ignoreBorder = [0, 0]
      } = options;
      this.checkProcessable("matchAndCrop", {
        bitDepth: [8, 16]
      });
      let matchToPrevious = algorithm === "matchToPrevious";
      let parent = this[0];
      let results = [];
      results[0] = {
        position: [0, 0],
        image: this[0]
      };
      let relativePosition = [0, 0];
      for (let i = 1; i < this.length; i++) {
        let position = parent.getBestMatch(this[i], {
          border: ignoreBorder
        });
        results[i] = {
          position: [position[0] + relativePosition[0], position[1] + relativePosition[1]],
          image: this[i]
        };
        if (matchToPrevious) {
          relativePosition[0] += position[0];
          relativePosition[1] += position[1];
          parent = this[i];
        }
      }
      let leftShift = 0;
      let rightShift = 0;
      let topShift = 0;
      let bottomShift = 0;
      for (let i = 0; i < results.length; i++) {
        let result = results[i];
        if (result.position[0] > leftShift) {
          leftShift = result.position[0];
        }
        if (result.position[0] < rightShift) {
          rightShift = result.position[0];
        }
        if (result.position[1] > topShift) {
          topShift = result.position[1];
        }
        if (result.position[1] < bottomShift) {
          bottomShift = result.position[1];
        }
      }
      rightShift = 0 - rightShift;
      bottomShift = 0 - bottomShift;
      for (let i = 0; i < results.length; i++) {
        let result = results[i];
        result.crop = result.image.crop({
          x: leftShift - result.position[0],
          y: topShift - result.position[1],
          width: parent.width - rightShift - leftShift,
          height: parent.height - bottomShift - topShift
        });
      }
      let newImages = [];
      for (let i = 0; i < results.length; i++) {
        newImages[i] = results[i].crop;
      }
      return new _Stack.default(newImages);
    }
  }
});

// node_modules/image-js/lib/stack/compute/min.js
var require_min = __commonJS({
  "node_modules/image-js/lib/stack/compute/min.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = min;
    function min() {
      this.checkProcessable("min", {
        bitDepth: [8, 16]
      });
      let min2 = this[0].min;
      for (let i = 1; i < this.length; i++) {
        for (let j = 0; j < min2.length; j++) {
          min2[j] = Math.min(min2[j], this[i].min[j]);
        }
      }
      return min2;
    }
  }
});

// node_modules/image-js/lib/stack/compute/max.js
var require_max = __commonJS({
  "node_modules/image-js/lib/stack/compute/max.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = max;
    function max() {
      this.checkProcessable("min", {
        bitDepth: [8, 16]
      });
      let max2 = this[0].max;
      for (let i = 1; i < this.length; i++) {
        for (let j = 0; j < max2.length; j++) {
          max2[j] = Math.max(max2[j], this[i].max[j]);
        }
      }
      return max2;
    }
  }
});

// node_modules/image-js/lib/util/histogram.js
var require_histogram = __commonJS({
  "node_modules/image-js/lib/util/histogram.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.mean = mean;
    exports2.median = median;
    function median(histogram) {
      let total = histogram.reduce((sum, x) => sum + x);
      if (total === 0) {
        throw new Error("unreachable");
      }
      let position = 0;
      let currentTotal = 0;
      let middle = total / 2;
      let previous;
      while (true) {
        if (histogram[position] > 0) {
          if (previous !== void 0) {
            return (previous + position) / 2;
          }
          currentTotal += histogram[position];
          if (currentTotal > middle) {
            return position;
          } else if (currentTotal === middle) {
            previous = position;
          }
        }
        position++;
      }
    }
    function mean(histogram) {
      let total = 0;
      let sum = 0;
      for (let i = 0; i < histogram.length; i++) {
        total += histogram[i];
        sum += histogram[i] * i;
      }
      if (total === 0) {
        return 0;
      }
      return sum / total;
    }
  }
});

// node_modules/image-js/lib/stack/compute/median.js
var require_median = __commonJS({
  "node_modules/image-js/lib/stack/compute/median.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = median;
    var _histogram = require_histogram();
    function median() {
      this.checkProcessable("median", {
        bitDepth: [8, 16]
      });
      let histograms = this.getHistograms({
        maxSlots: this[0].maxValue + 1
      });
      let result = new Array(histograms.length);
      for (let c = 0; c < histograms.length; c++) {
        let histogram = histograms[c];
        result[c] = (0, _histogram.median)(histogram);
      }
      return result;
    }
  }
});

// node_modules/image-js/lib/stack/compute/histogram.js
var require_histogram2 = __commonJS({
  "node_modules/image-js/lib/stack/compute/histogram.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = histogram;
    function histogram(options) {
      this.checkProcessable("min", {
        bitDepth: [8, 16]
      });
      let histogram2 = this[0].getHistogram(options);
      for (let i = 1; i < this.length; i++) {
        let secondHistogram = this[i].getHistogram(options);
        for (let j = 0; j < histogram2.length; j++) {
          histogram2[j] += secondHistogram[j];
        }
      }
      return histogram2;
    }
  }
});

// node_modules/image-js/lib/stack/compute/histograms.js
var require_histograms = __commonJS({
  "node_modules/image-js/lib/stack/compute/histograms.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = histograms;
    function histograms(options) {
      this.checkProcessable("min", {
        bitDepth: [8, 16]
      });
      let histograms2 = this[0].getHistograms(options);
      let histogramLength = histograms2[0].length;
      for (let i = 1; i < this.length; i++) {
        let secondHistograms = this[i].getHistograms(options);
        for (let c = 0; c < histograms2.length; c++) {
          for (let j = 0; j < histogramLength; j++) {
            histograms2[c][j] += secondHistograms[c][j];
          }
        }
      }
      return histograms2;
    }
  }
});

// node_modules/image-js/lib/stack/utility/averageImage.js
var require_averageImage = __commonJS({
  "node_modules/image-js/lib/stack/utility/averageImage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = averageImage;
    var _Image = _interopRequireDefault(require_Image());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function averageImage() {
      this.checkProcessable("averageImage", {
        bitDepth: [8, 16]
      });
      let data = new Uint32Array(this[0].data.length);
      for (let i = 0; i < this.length; i++) {
        let current = this[i];
        for (let j = 0; j < this[0].data.length; j++) {
          data[j] += current.data[j];
        }
      }
      let image = _Image.default.createFrom(this[0]);
      let newData = image.data;
      for (let i = 0; i < this[0].data.length; i++) {
        newData[i] = data[i] / this.length;
      }
      return image;
    }
  }
});

// node_modules/image-js/lib/stack/utility/maxImage.js
var require_maxImage = __commonJS({
  "node_modules/image-js/lib/stack/utility/maxImage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = maxImage;
    var _Image = _interopRequireDefault(require_Image());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function maxImage() {
      this.checkProcessable("max", {
        bitDepth: [8, 16]
      });
      let image = _Image.default.createFrom(this[0]);
      image.data.fill(0);
      for (const current of this) {
        for (let j = 0; j < image.data.length; j++) {
          image.data[j] = Math.max(current.data[j], image.data[j]);
        }
      }
      return image;
    }
  }
});

// node_modules/image-js/lib/stack/utility/minImage.js
var require_minImage = __commonJS({
  "node_modules/image-js/lib/stack/utility/minImage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = minImage;
    var _Image = _interopRequireDefault(require_Image());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function minImage() {
      this.checkProcessable("max", {
        bitDepth: [8, 16]
      });
      let image = _Image.default.createFrom(this[0]);
      image.data.fill(image.maxValue);
      for (const current of this) {
        for (let j = 0; j < image.data.length; j++) {
          image.data[j] = Math.min(current.data[j], image.data[j]);
        }
      }
      return image;
    }
  }
});

// node_modules/image-js/lib/stack/extend.js
var require_extend2 = __commonJS({
  "node_modules/image-js/lib/stack/extend.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = extend;
    var _matchAndCrop = _interopRequireDefault(require_matchAndCrop());
    var _min = _interopRequireDefault(require_min());
    var _max = _interopRequireDefault(require_max());
    var _median = _interopRequireDefault(require_median());
    var _histogram = _interopRequireDefault(require_histogram2());
    var _histograms = _interopRequireDefault(require_histograms());
    var _averageImage = _interopRequireDefault(require_averageImage());
    var _maxImage = _interopRequireDefault(require_maxImage());
    var _minImage = _interopRequireDefault(require_minImage());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function extend(Stack) {
      Stack.extendMethod("matchAndCrop", _matchAndCrop.default);
      Stack.extendMethod("getMin", _min.default);
      Stack.extendMethod("getMax", _max.default);
      Stack.extendMethod("getMedian", _median.default);
      Stack.extendMethod("getHistogram", _histogram.default);
      Stack.extendMethod("getHistograms", _histograms.default);
      Stack.extendMethod("getAverage", _averageImage.default);
      Stack.extendMethod("getAverageImage", _averageImage.default);
      Stack.extendMethod("getMaxImage", _maxImage.default);
      Stack.extendMethod("getMinImage", _minImage.default);
    }
  }
});

// node_modules/image-js/lib/stack/Stack.js
var require_Stack = __commonJS({
  "node_modules/image-js/lib/stack/Stack.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _hasOwn = _interopRequireDefault(require_has_own());
    var _Image = _interopRequireDefault(require_Image());
    var _extend = _interopRequireDefault(require_extend2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var computedPropertyDescriptor = {
      configurable: true,
      enumerable: false,
      get: void 0
    };
    var Stack = class extends Array {
      constructor(images) {
        if (Array.isArray(images)) {
          super(images.length);
          for (let i = 0; i < images.length; i++) {
            this[i] = images[i];
          }
        } else if (typeof images === "number") {
          super(images);
        } else {
          super();
        }
        this.computed = null;
      }
      static load(urls) {
        return Promise.all(urls.map(_Image.default.load)).then((images) => new Stack(images));
      }
      static extendMethod(name, method, options = {}) {
        let {
          inPlace = false,
          returnThis = true,
          partialArgs = []
        } = options;
        if (inPlace) {
          Stack.prototype[name] = function(...args) {
            this.computed = null;
            let result = method.apply(this, [...partialArgs, ...args]);
            if (returnThis) {
              return this;
            }
            return result;
          };
        } else {
          Stack.prototype[name] = function(...args) {
            return method.apply(this, [...partialArgs, ...args]);
          };
        }
        return Stack;
      }
      static extendProperty(name, method, options = {}) {
        let {
          partialArgs = []
        } = options;
        computedPropertyDescriptor.get = function() {
          if (this.computed === null) {
            this.computed = {};
          } else if ((0, _hasOwn.default)(name, this.computed)) {
            return this.computed[name];
          }
          let result = method.apply(this, partialArgs);
          this.computed[name] = result;
          return result;
        };
        Object.defineProperty(Stack.prototype, name, computedPropertyDescriptor);
        return Stack;
      }
      /**
       * Check if a process can be applied on the stack
       * @param {string} processName
       * @param {object} [options]
       * @private
       */
      checkProcessable(processName, options = {}) {
        if (typeof processName !== "string") {
          throw new TypeError("checkProcessable requires as first parameter the processName (a string)");
        }
        if (this.size === 0) {
          throw new TypeError(`The process: ${processName} can not be applied on an empty stack`);
        }
        this[0].checkProcessable(processName, options);
        for (let i = 1; i < this.length; i++) {
          if ((options.sameSize === void 0 || options.sameSize) && this[0].width !== this[i].width) {
            throw new TypeError(`The process: ${processName} can not be applied if width is not identical in all images`);
          }
          if ((options.sameSize === void 0 || options.sameSize) && this[0].height !== this[i].height) {
            throw new TypeError(`The process: ${processName} can not be applied if height is not identical in all images`);
          }
          if ((options.sameAlpha === void 0 || options.sameAlpha) && this[0].alpha !== this[i].alpha) {
            throw new TypeError(`The process: ${processName} can not be applied if alpha is not identical in all images`);
          }
          if ((options.sameBitDepth === void 0 || options.sameBitDepth) && this[0].bitDepth !== this[i].bitDepth) {
            throw new TypeError(`The process: ${processName} can not be applied if bitDepth is not identical in all images`);
          }
          if ((options.sameColorModel === void 0 || options.sameColorModel) && this[0].colorModel !== this[i].colorModel) {
            throw new TypeError(`The process: ${processName} can not be applied if colorModel is not identical in all images`);
          }
          if ((options.sameNumberChannels === void 0 || options.sameNumberChannels) && this[0].channels !== this[i].channels) {
            throw new TypeError(`The process: ${processName} can not be applied if channels is not identical in all images`);
          }
        }
      }
    };
    exports2.default = Stack;
    if (!Array[Symbol.species]) {
      Stack.prototype.map = function(cb, thisArg) {
        if (typeof cb !== "function") {
          throw new TypeError(`${cb} is not a function`);
        }
        let newStack = new Stack(this.length);
        for (let i = 0; i < this.length; i++) {
          newStack[i] = cb.call(thisArg, this[i], i, this);
        }
        return newStack;
      };
    }
    (0, _extend.default)(Stack);
  }
});

// node_modules/image-js/lib/image/core/load.js
var require_load = __commonJS({
  "node_modules/image-js/lib/image/core/load.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = load;
    var _fastJpeg = require_src3();
    var _fastPng = require_lib();
    var _imageType = _interopRequireDefault(require_image_type());
    var _jpegJs = require_jpeg_js();
    var _tiff = require_lib2();
    var _Stack = _interopRequireDefault(require_Stack());
    var _base = require_base64();
    var _Image = _interopRequireDefault(require_Image());
    var _model = require_model();
    var _environment = require_environment();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var isDataURL = /^data:[a-z]+\/(?:[a-z]+);base64,/;
    function load(image, options) {
      if (typeof image === "string") {
        return loadURL(image, options);
      } else if (image instanceof ArrayBuffer) {
        return Promise.resolve(loadBinary(new Uint8Array(image), void 0, options && options.ignorePalette));
      } else if (image.buffer) {
        return Promise.resolve(loadBinary(image, void 0, options && options.ignorePalette));
      } else {
        throw new Error('argument to "load" must be a string or buffer.');
      }
    }
    function loadBinary(image, base64Url, ignorePalette) {
      const type = (0, _imageType.default)(image);
      if (type) {
        switch (type.mime) {
          case "image/png":
            return loadPNG(image);
          case "image/jpeg":
            return loadJPEG(image);
          case "image/tiff":
            return loadTIFF(image, ignorePalette);
          default:
            return loadGeneric(getBase64(type.mime));
        }
      }
      return loadGeneric(getBase64("application/octet-stream"));
      function getBase64(type2) {
        if (base64Url) {
          return base64Url;
        } else {
          return (0, _base.toBase64URL)(image, type2);
        }
      }
    }
    function loadURL(url, options) {
      const dataURL = url.slice(0, 64).match(isDataURL);
      let binaryDataP;
      if (dataURL !== null) {
        binaryDataP = Promise.resolve((0, _base.decode)(url.slice(dataURL[0].length)));
      } else {
        binaryDataP = (0, _environment.fetchBinary)(url, options);
      }
      return binaryDataP.then((binaryData) => {
        const uint8 = new Uint8Array(binaryData);
        return loadBinary(uint8, dataURL ? url : void 0, options && options.ignorePalette);
      });
    }
    function loadPNG(data) {
      const png = (0, _fastPng.decode)(data);
      let channels = png.channels;
      let components;
      let alpha = 0;
      if (channels === 2 || channels === 4) {
        components = channels - 1;
        alpha = 1;
      } else {
        components = channels;
      }
      if (png.palette) {
        return loadPNGFromPalette(png);
      }
      return new _Image.default(png.width, png.height, png.data, {
        components,
        alpha,
        bitDepth: png.depth
      });
    }
    function loadPNGFromPalette(png) {
      const pixels = png.width * png.height;
      const channels = png.palette[0].length;
      const data = new Uint8Array(pixels * channels);
      const pixelsPerByte = 8 / png.depth;
      const factor = png.depth < 8 ? pixelsPerByte : 1;
      const mask = parseInt("1".repeat(png.depth), 2);
      const hasAlpha = channels === 4;
      let dataIndex = 0;
      for (let i = 0; i < pixels; i++) {
        const index = Math.floor(i / factor);
        let value = png.data[index];
        if (png.depth < 8) {
          value = value >>> png.depth * (pixelsPerByte - 1 - i % pixelsPerByte) & mask;
        }
        const paletteValue = png.palette[value];
        data[dataIndex++] = paletteValue[0];
        data[dataIndex++] = paletteValue[1];
        data[dataIndex++] = paletteValue[2];
        if (hasAlpha) {
          data[dataIndex++] = paletteValue[3];
        }
      }
      return new _Image.default(png.width, png.height, data, {
        components: 3,
        alpha: hasAlpha,
        bitDepth: 8
      });
    }
    function loadJPEG(data) {
      const decodedExif = (0, _fastJpeg.decode)(data);
      let meta;
      if (decodedExif.exif) {
        meta = getMetadata(decodedExif.exif);
      }
      const jpeg = (0, _jpegJs.decode)(data, {
        useTArray: true,
        maxMemoryUsageInMB: 1024
      });
      let image = new _Image.default(jpeg.width, jpeg.height, jpeg.data, {
        meta
      });
      if (meta && meta.tiff.tags.Orientation) {
        const orientation = meta.tiff.tags.Orientation;
        if (orientation > 2) {
          image = image.rotate({
            3: 180,
            4: 180,
            5: 90,
            6: 90,
            7: 270,
            8: 270
          }[orientation]);
        }
        if ([2, 4, 5, 7].includes(orientation)) {
          image = image.flipX();
        }
      }
      return image;
    }
    function loadTIFF(data, ignorePalette) {
      let result = (0, _tiff.decode)(data);
      if (result.length === 1) {
        return getImageFromIFD(result[0], ignorePalette);
      } else {
        return new _Stack.default(result.map(function(image) {
          return getImageFromIFD(image, ignorePalette);
        }));
      }
    }
    function getMetadata(image) {
      const metadata = {
        tiff: {
          fields: image.fields,
          tags: image.map
        }
      };
      if (image.exif) {
        metadata.exif = image.exif;
      }
      if (image.gps) {
        metadata.gps = image.gps;
      }
      return metadata;
    }
    function getImageFromIFD(image, ignorePalette) {
      if (!ignorePalette && image.type === 3) {
        const data = new Uint16Array(3 * image.width * image.height);
        const palette = image.palette;
        let ptr = 0;
        for (let i = 0; i < image.data.length; i++) {
          const index = image.data[i];
          const color = palette[index];
          data[ptr++] = color[0];
          data[ptr++] = color[1];
          data[ptr++] = color[2];
        }
        return new _Image.default(image.width, image.height, data, {
          components: 3,
          alpha: image.alpha,
          colorModel: _model.RGB,
          bitDepth: 16,
          meta: getMetadata(image)
        });
      } else {
        return new _Image.default(image.width, image.height, image.data, {
          components: image.type === 2 ? 3 : 1,
          alpha: image.alpha,
          colorModel: image.type === 2 ? _model.RGB : _model.GREY,
          bitDepth: image.bitsPerSample.length ? image.bitsPerSample[0] : image.bitsPerSample,
          meta: getMetadata(image)
        });
      }
    }
    function loadGeneric(url, options) {
      options = options || {};
      return new Promise(function(resolve2, reject2) {
        let image = new _environment.DOMImage();
        image.onload = function() {
          let w = image.width;
          let h = image.height;
          let canvas = (0, _environment.createCanvas)(w, h);
          let ctx = canvas.getContext("2d");
          ctx.drawImage(image, 0, 0, w, h);
          let data = ctx.getImageData(0, 0, w, h).data;
          resolve2(new _Image.default(w, h, data, options));
        };
        image.onerror = function() {
          reject2(new Error(`Could not load ${url}`));
        };
        image.src = url;
      });
    }
  }
});

// node_modules/image-js/lib/image/core/valueMethods.js
var require_valueMethods = __commonJS({
  "node_modules/image-js/lib/image/core/valueMethods.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = setValueMethods;
    var valueMethods = {
      /**
       * Get the value of specific pixel channel
       * @memberof Image
       * @instance
       * @param {number} x - x coordinate (0 = left)
       * @param {number} y - y coordinate (0 = top)
       * @param {number} channel
       * @return {number} - the value of this pixel channel
       */
      getValueXY(x, y, channel) {
        return this.data[(y * this.width + x) * this.channels + channel];
      },
      /**
       * Set the value of specific pixel channel
       * @memberof Image
       * @instance
       * @param {number} x - x coordinate (0 = left)
       * @param {number} y - y coordinate (0 = top)
       * @param {number} channel
       * @param {number} value - the new value of this pixel channel
       * @return {this}
       */
      setValueXY(x, y, channel, value) {
        this.data[(y * this.width + x) * this.channels + channel] = value;
        this.computed = null;
        return this;
      },
      /**
       * Get the value of specific pixel channel
       * @memberof Image
       * @instance
       * @param {number} index - 1D index of the pixel
       * @param {number} channel
       * @return {number} - the value of this pixel channel
       */
      getValue(index, channel) {
        return this.data[index * this.channels + channel];
      },
      /**
       * Set the value of specific pixel channel
       * @memberof Image
       * @instance
       * @param {number} index - 1D index of the pixel
       * @param {number} channel
       * @param {number} value - the new value of this pixel channel
       * @return {this}
       */
      setValue(index, channel, value) {
        this.data[index * this.channels + channel] = value;
        this.computed = null;
        return this;
      },
      /**
       * Get the value of an entire pixel
       * @memberof Image
       * @instance
       * @param {number} x - x coordinate (0 = left)
       * @param {number} y - y coordinate (0 = top)
       * @return {number[]} the value of this pixel
       */
      getPixelXY(x, y) {
        return this.getPixel(y * this.width + x);
      },
      /**
       * Set the value of an entire pixel
       * @memberof Image
       * @instance
       * @param {number} x - x coordinate (0 = left)
       * @param {number} y - y coordinate (0 = top)
       * @param {number[]} value - the new value of this pixel
       * @return {this}
       */
      setPixelXY(x, y, value) {
        return this.setPixel(y * this.width + x, value);
      },
      /**
       * Get the value of an entire pixel
       * @memberof Image
       * @instance
       * @param {number} index - 1D index of the pixel
       * @return {number[]} the value of this pixel
       */
      getPixel(index) {
        const value = new Array(this.channels);
        const target = index * this.channels;
        for (let i = 0; i < this.channels; i++) {
          value[i] = this.data[target + i];
        }
        return value;
      },
      /**
       * Set the value of an entire pixel
       * @memberof Image
       * @instance
       * @param {number} index - 1D index of the pixel
       * @param {number[]} value - the new value of this pixel
       * @return {this}
       */
      setPixel(index, value) {
        const target = index * this.channels;
        for (let i = 0; i < value.length; i++) {
          this.data[target + i] = value[i];
        }
        this.computed = null;
        return this;
      }
    };
    function setValueMethods(Image2) {
      for (const i in valueMethods) {
        Image2.prototype[i] = valueMethods[i];
      }
    }
  }
});

// node_modules/image-js/lib/image/internal/getImageParameters.js
var require_getImageParameters = __commonJS({
  "node_modules/image-js/lib/image/internal/getImageParameters.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = getImageParameters;
    function getImageParameters(image) {
      return {
        width: image.width,
        height: image.height,
        components: image.components,
        alpha: image.alpha,
        colorModel: image.colorModel,
        bitDepth: image.bitDepth
      };
    }
  }
});

// node_modules/image-js/lib/image/internal/getOutputImage.js
var require_getOutputImage = __commonJS({
  "node_modules/image-js/lib/image/internal/getOutputImage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getOutputImage = getOutputImage;
    exports2.getOutputImageOrInPlace = getOutputImageOrInPlace;
    var _Image = _interopRequireDefault(require_Image());
    var _getImageParameters = _interopRequireDefault(require_getImageParameters());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function getOutputImage(thisImage, options, newParameters, internalOptions = {}) {
      const {
        out
      } = options;
      if (out === void 0) {
        if (internalOptions.copy) {
          return thisImage.clone();
        } else {
          return _Image.default.createFrom(thisImage, newParameters);
        }
      } else {
        if (!_Image.default.isImage(out)) {
          throw new TypeError("out must be an Image object");
        }
        const requirements = Object.assign((0, _getImageParameters.default)(thisImage), newParameters);
        for (const property in requirements) {
          if (out[property] !== requirements[property]) {
            throw new RangeError(`cannot use out. Its ${property} must be "${requirements[property]}" (found "${out[property]}")`);
          }
        }
        return out;
      }
    }
    function getOutputImageOrInPlace(thisImage, options, internalOptions) {
      if (options.inPlace !== void 0 && typeof options.inPlace !== "boolean") {
        throw new TypeError("inPlace option must be a boolean");
      }
      if (options.inPlace) {
        if (options.out !== void 0) {
          throw new TypeError("out option must not be set if inPlace option is true");
        }
        return thisImage;
      }
      return getOutputImage(thisImage, options, null, internalOptions);
    }
  }
});

// node_modules/image-js/lib/image/filter/abs.js
var require_abs = __commonJS({
  "node_modules/image-js/lib/image/filter/abs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = abs;
    var _getOutputImage = require_getOutputImage();
    function abs(options = {}) {
      this.checkProcessable("abs", {
        bitDepth: [32]
      });
      const out = (0, _getOutputImage.getOutputImageOrInPlace)(this, options);
      absolute(this, out);
      return out;
    }
    function absolute(image, out) {
      for (let i = 0; i < image.data.length; i++) {
        out.data[i] = Math.abs(image.data[i]);
      }
    }
  }
});

// node_modules/image-js/lib/image/internal/copyAlphaChannel.js
var require_copyAlphaChannel = __commonJS({
  "node_modules/image-js/lib/image/internal/copyAlphaChannel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = copyAlphaChannel;
    function copyAlphaChannel(from, to) {
      if (from.alpha === 1 && to.alpha === 1) {
        for (let i = 0; i < from.size; i++) {
          to.data[i * to.channels + to.components] = from.data[i * from.channels + from.components];
        }
      }
    }
  }
});

// node_modules/image-js/lib/image/filter/invert.js
var require_invert = __commonJS({
  "node_modules/image-js/lib/image/filter/invert.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = invert;
    var _copyAlphaChannel = _interopRequireDefault(require_copyAlphaChannel());
    var _getOutputImage = require_getOutputImage();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function invert(options = {}) {
      this.checkProcessable("invert", {
        bitDepth: [1, 8, 16]
      });
      const out = (0, _getOutputImage.getOutputImageOrInPlace)(this, options);
      if (this.bitDepth === 1) {
        invertBinary(this, out);
      } else {
        invertColor(this, out);
        if (this !== out) {
          (0, _copyAlphaChannel.default)(this, out);
        }
      }
      return out;
    }
    function invertBinary(image, out) {
      for (let i = 0; i < image.data.length; i++) {
        out.data[i] = ~image.data[i];
      }
    }
    function invertColor(image, out) {
      for (let pixel = 0; pixel < image.data.length; pixel += image.channels) {
        for (let c = 0; c < image.components; c++) {
          out.data[pixel + c] = image.maxValue - image.data[pixel + c];
        }
      }
    }
  }
});

// node_modules/image-js/lib/image/filter/flipX.js
var require_flipX = __commonJS({
  "node_modules/image-js/lib/image/filter/flipX.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = flipX;
    function flipX() {
      this.checkProcessable("flipX", {
        bitDepth: [8, 16]
      });
      for (let i = 0; i < this.height; i++) {
        let offsetY = i * this.width * this.channels;
        for (let j = 0; j < Math.floor(this.width / 2); j++) {
          let posCurrent = j * this.channels + offsetY;
          let posOpposite = (this.width - j - 1) * this.channels + offsetY;
          for (let k = 0; k < this.channels; k++) {
            let tmp = this.data[posCurrent + k];
            this.data[posCurrent + k] = this.data[posOpposite + k];
            this.data[posOpposite + k] = tmp;
          }
        }
      }
      return this;
    }
  }
});

// node_modules/image-js/lib/image/filter/flipY.js
var require_flipY = __commonJS({
  "node_modules/image-js/lib/image/filter/flipY.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = flipY;
    function flipY() {
      this.checkProcessable("flipY", {
        bitDepth: [8, 16]
      });
      for (let i = 0; i < Math.floor(this.height / 2); i++) {
        for (let j = 0; j < this.width; j++) {
          let posCurrent = j * this.channels + i * this.width * this.channels;
          let posOpposite = j * this.channels + (this.height - 1 - i) * this.channels * this.width;
          for (let k = 0; k < this.channels; k++) {
            let tmp = this.data[posCurrent + k];
            this.data[posCurrent + k] = this.data[posOpposite + k];
            this.data[posOpposite + k] = tmp;
          }
        }
      }
      return this;
    }
  }
});

// node_modules/image-js/lib/image/filter/blurFilter.js
var require_blurFilter = __commonJS({
  "node_modules/image-js/lib/image/filter/blurFilter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = blurFilter;
    function blurFilter(options = {}) {
      const {
        radius = 1
      } = options;
      if (radius < 1) {
        throw new Error("radius must be greater than 1");
      }
      const n = 2 * radius + 1;
      const kernel = new Array(n);
      for (let i = 0; i < n; i++) {
        kernel[i] = new Array(n);
        for (let j = 0; j < n; j++) {
          kernel[i][j] = 1 / (n * n);
        }
      }
      return this.convolution(kernel);
    }
  }
});

// node_modules/median-quickselect/lib/median-quickselect.min.js
var require_median_quickselect_min = __commonJS({
  "node_modules/median-quickselect/lib/median-quickselect.min.js"(exports2, module2) {
    (function() {
      function a(d) {
        for (var e = 0, f = d.length - 1, g = void 0, h = void 0, i = void 0, j = c(e, f); true; ) {
          if (f <= e)
            return d[j];
          if (f == e + 1)
            return d[e] > d[f] && b(d, e, f), d[j];
          for (g = c(e, f), d[g] > d[f] && b(d, g, f), d[e] > d[f] && b(d, e, f), d[g] > d[e] && b(d, g, e), b(d, g, e + 1), h = e + 1, i = f; true; ) {
            do
              h++;
            while (d[e] > d[h]);
            do
              i--;
            while (d[i] > d[e]);
            if (i < h)
              break;
            b(d, h, i);
          }
          b(d, e, i), i <= j && (e = h), i >= j && (f = i - 1);
        }
      }
      var b = function b2(d, e, f) {
        var _ref;
        return _ref = [d[f], d[e]], d[e] = _ref[0], d[f] = _ref[1], _ref;
      }, c = function c2(d, e) {
        return ~~((d + e) / 2);
      };
      "undefined" != typeof module2 && module2.exports ? module2.exports = a : window.median = a;
    })();
  }
});

// node_modules/image-js/lib/util/channel.js
var require_channel = __commonJS({
  "node_modules/image-js/lib/util/channel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.validateArrayOfChannels = validateArrayOfChannels;
    exports2.validateChannel = validateChannel;
    var Model = _interopRequireWildcard(require_model());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != typeof e && "function" != typeof e)
        return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n.default = e, t && t.set(e, n), n;
    }
    function validateArrayOfChannels(image, options = {}) {
      let {
        channels,
        allowAlpha,
        // are we allowing the selection of an alpha channel ?
        defaultAlpha
        // if no channels are selected should we take the alpha channel ?
      } = options;
      if (typeof allowAlpha !== "boolean") {
        allowAlpha = true;
      }
      if (typeof channels === "undefined") {
        return allChannels(image, defaultAlpha);
      } else {
        return validateChannels(image, channels, allowAlpha);
      }
    }
    function allChannels(image, defaultAlpha) {
      let length = defaultAlpha ? image.channels : image.components;
      let array = new Array(length);
      for (let i = 0; i < length; i++) {
        array[i] = i;
      }
      return array;
    }
    function validateChannels(image, channels, allowAlpha) {
      if (!Array.isArray(channels)) {
        channels = [channels];
      }
      for (let c = 0; c < channels.length; c++) {
        channels[c] = validateChannel(image, channels[c], allowAlpha);
      }
      return channels;
    }
    function validateChannel(image, channel, allowAlpha = true) {
      if (channel === void 0) {
        throw new RangeError(`validateChannel : the channel has to be >=0 and <${image.channels}`);
      }
      if (typeof channel === "string") {
        switch (image.colorModel) {
          case Model.GREY:
            break;
          case Model.RGB:
            if ("rgb".includes(channel)) {
              switch (channel) {
                case "r":
                  channel = 0;
                  break;
                case "g":
                  channel = 1;
                  break;
                case "b":
                  channel = 2;
                  break;
              }
            }
            break;
          case Model.HSL:
            if ("hsl".includes(channel)) {
              switch (channel) {
                case "h":
                  channel = 0;
                  break;
                case "s":
                  channel = 1;
                  break;
                case "l":
                  channel = 2;
                  break;
              }
            }
            break;
          case Model.HSV:
            if ("hsv".includes(channel)) {
              switch (channel) {
                case "h":
                  channel = 0;
                  break;
                case "s":
                  channel = 1;
                  break;
                case "v":
                  channel = 2;
                  break;
              }
            }
            break;
          case Model.CMYK:
            if ("cmyk".includes(channel)) {
              switch (channel) {
                case "c":
                  channel = 0;
                  break;
                case "m":
                  channel = 1;
                  break;
                case "y":
                  channel = 2;
                  break;
                case "k":
                  channel = 3;
                  break;
              }
            }
            break;
          default:
            throw new Error(`Unexpected color model: ${image.colorModel}`);
        }
        if (channel === "a") {
          if (!image.alpha) {
            throw new Error("validateChannel : the image does not contain alpha channel");
          }
          channel = image.components;
        }
        if (typeof channel === "string") {
          throw new Error(`validateChannel : undefined channel: ${channel}`);
        }
      }
      if (channel >= image.channels) {
        throw new RangeError(`validateChannel : the channel has to be >=0 and <${image.channels}`);
      }
      if (!allowAlpha && channel >= image.components) {
        throw new RangeError("validateChannel : alpha channel may not be selected");
      }
      return channel;
    }
  }
});

// node_modules/image-js/lib/image/filter/medianFilter.js
var require_medianFilter = __commonJS({
  "node_modules/image-js/lib/image/filter/medianFilter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = medianFilter;
    var _medianQuickselect = _interopRequireDefault(require_median_quickselect_min());
    var _channel = require_channel();
    var _Image = _interopRequireDefault(require_Image());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function medianFilter(options = {}) {
      let {
        radius = 1,
        border = "copy",
        channels
      } = options;
      this.checkProcessable("medianFilter", {
        bitDepth: [8, 16]
      });
      if (radius < 1) {
        throw new Error("radius must be greater than 0");
      }
      channels = (0, _channel.validateArrayOfChannels)(this, channels, true);
      let kWidth = radius;
      let kHeight = radius;
      let newImage = _Image.default.createFrom(this);
      let size = (kWidth * 2 + 1) * (kHeight * 2 + 1);
      let kernel = new Array(size);
      for (let channel = 0; channel < channels.length; channel++) {
        let c = channels[channel];
        for (let y = kHeight; y < this.height - kHeight; y++) {
          for (let x = kWidth; x < this.width - kWidth; x++) {
            let n = 0;
            for (let j = -kHeight; j <= kHeight; j++) {
              for (let i = -kWidth; i <= kWidth; i++) {
                let index2 = ((y + j) * this.width + x + i) * this.channels + c;
                kernel[n++] = this.data[index2];
              }
            }
            let index = (y * this.width + x) * this.channels + c;
            newImage.data[index] = (0, _medianQuickselect.default)(kernel);
          }
        }
      }
      if (this.alpha && !channels.includes(this.channels)) {
        for (let i = this.components; i < this.data.length; i = i + this.channels) {
          newImage.data[i] = this.data[i];
        }
      }
      newImage.setBorder({
        size: [kWidth, kHeight],
        algorithm: border
      });
      return newImage;
    }
  }
});

// node_modules/image-js/lib/image/filter/gaussianFilter.js
var require_gaussianFilter = __commonJS({
  "node_modules/image-js/lib/image/filter/gaussianFilter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = gaussianFilter;
    function gaussianFilter(options = {}) {
      let {
        radius = 1,
        sigma,
        channels,
        border = "copy"
      } = options;
      this.checkProcessable("gaussian", {
        bitDepth: [8, 16]
      });
      const kernel = getKernel(radius, sigma);
      return this.convolution([kernel, kernel], {
        border,
        channels,
        algorithm: "separable"
      });
    }
    function getKernel(radius, sigma) {
      const n = radius * 2 + 1;
      const kernel = new Array(n);
      const sigmaX = sigma ? sigma : ((n - 1) * 0.5 - 1) * 0.3 + 0.8;
      const scale2X = -0.5 / (sigmaX * sigmaX);
      let sum = 0;
      for (let i = 0; i < n; i++) {
        const x = i - radius;
        const t = Math.exp(scale2X * x * x);
        kernel[i] = t;
        sum += t;
      }
      for (let i = 0; i < n; i++) {
        kernel[i] /= sum;
      }
      return kernel;
    }
  }
});

// node_modules/image-js/lib/util/kernels.js
var require_kernels = __commonJS({
  "node_modules/image-js/lib/util/kernels.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.SOBEL_Y = exports2.SOBEL_X = exports2.SECOND_DERIVATIVE_INV = exports2.SECOND_DERIVATIVE = exports2.SCHARR_Y = exports2.SCHARR_X = exports2.DISCRETE_LAPLACE_8 = exports2.DISCRETE_LAPLACE_4 = void 0;
    var DISCRETE_LAPLACE_4 = exports2.DISCRETE_LAPLACE_4 = [[0, 1, 0], [1, -4, 1], [0, 1, 0]];
    var DISCRETE_LAPLACE_8 = exports2.DISCRETE_LAPLACE_8 = [[1, 1, 1], [1, -8, 1], [1, 1, 1]];
    var SOBEL_X = exports2.SOBEL_X = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]];
    var SOBEL_Y = exports2.SOBEL_Y = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]];
    var SCHARR_X = exports2.SCHARR_X = [[3, 0, -3], [10, 0, -10], [3, 0, -3]];
    var SCHARR_Y = exports2.SCHARR_Y = [[3, 10, 3], [0, 0, 0], [-3, -10, -3]];
    var SECOND_DERIVATIVE = exports2.SECOND_DERIVATIVE = [[-1, -2, 0, 2, 1], [-2, -4, 0, 4, 2], [0, 0, 0, 0, 0], [1, 2, 0, -2, -1], [2, 4, 0, -4, -2]];
    var SECOND_DERIVATIVE_INV = exports2.SECOND_DERIVATIVE_INV = [[1, 2, 0, -2, -1], [2, 4, 0, -4, -2], [0, 0, 0, 0, 0], [-2, -4, 0, 4, 2], [-1, -2, 0, 2, 1]];
  }
});

// node_modules/ml-fft/src/fftlib.js
var require_fftlib = __commonJS({
  "node_modules/ml-fft/src/fftlib.js"(exports2) {
    var FFT = function() {
      var FFT2;
      if (typeof exports2 !== "undefined") {
        FFT2 = exports2;
      } else {
        FFT2 = {};
      }
      var version = {
        release: "0.3.0",
        date: "2013-03"
      };
      FFT2.toString = function() {
        return "version " + version.release + ", released " + version.date;
      };
      var _n = 0, _bitrev = null, _cstb = null;
      var core = {
        init: function(n) {
          if (n !== 0 && (n & n - 1) === 0) {
            _n = n;
            core._initArray();
            core._makeBitReversalTable();
            core._makeCosSinTable();
          } else {
            throw new Error("init: radix-2 required");
          }
        },
        // 1D-FFT
        fft1d: function(re, im) {
          core.fft(re, im, 1);
        },
        // 1D-IFFT
        ifft1d: function(re, im) {
          var n = 1 / _n;
          core.fft(re, im, -1);
          for (var i2 = 0; i2 < _n; i2++) {
            re[i2] *= n;
            im[i2] *= n;
          }
        },
        // 1D-IFFT
        bt1d: function(re, im) {
          core.fft(re, im, -1);
        },
        // 2D-FFT Not very useful if the number of rows have to be equal to cols
        fft2d: function(re, im) {
          var tre = [], tim = [], i2 = 0;
          for (var y = 0; y < _n; y++) {
            i2 = y * _n;
            for (var x1 = 0; x1 < _n; x1++) {
              tre[x1] = re[x1 + i2];
              tim[x1] = im[x1 + i2];
            }
            core.fft1d(tre, tim);
            for (var x2 = 0; x2 < _n; x2++) {
              re[x2 + i2] = tre[x2];
              im[x2 + i2] = tim[x2];
            }
          }
          for (var x = 0; x < _n; x++) {
            for (var y1 = 0; y1 < _n; y1++) {
              i2 = x + y1 * _n;
              tre[y1] = re[i2];
              tim[y1] = im[i2];
            }
            core.fft1d(tre, tim);
            for (var y2 = 0; y2 < _n; y2++) {
              i2 = x + y2 * _n;
              re[i2] = tre[y2];
              im[i2] = tim[y2];
            }
          }
        },
        // 2D-IFFT
        ifft2d: function(re, im) {
          var tre = [], tim = [], i2 = 0;
          for (var y = 0; y < _n; y++) {
            i2 = y * _n;
            for (var x1 = 0; x1 < _n; x1++) {
              tre[x1] = re[x1 + i2];
              tim[x1] = im[x1 + i2];
            }
            core.ifft1d(tre, tim);
            for (var x2 = 0; x2 < _n; x2++) {
              re[x2 + i2] = tre[x2];
              im[x2 + i2] = tim[x2];
            }
          }
          for (var x = 0; x < _n; x++) {
            for (var y1 = 0; y1 < _n; y1++) {
              i2 = x + y1 * _n;
              tre[y1] = re[i2];
              tim[y1] = im[i2];
            }
            core.ifft1d(tre, tim);
            for (var y2 = 0; y2 < _n; y2++) {
              i2 = x + y2 * _n;
              re[i2] = tre[y2];
              im[i2] = tim[y2];
            }
          }
        },
        // core operation of FFT
        fft: function(re, im, inv) {
          var d, h, ik, m, tmp, wr, wi, xr, xi, n4 = _n >> 2;
          for (var l = 0; l < _n; l++) {
            m = _bitrev[l];
            if (l < m) {
              tmp = re[l];
              re[l] = re[m];
              re[m] = tmp;
              tmp = im[l];
              im[l] = im[m];
              im[m] = tmp;
            }
          }
          for (var k = 1; k < _n; k <<= 1) {
            h = 0;
            d = _n / (k << 1);
            for (var j = 0; j < k; j++) {
              wr = _cstb[h + n4];
              wi = inv * _cstb[h];
              for (var i2 = j; i2 < _n; i2 += k << 1) {
                ik = i2 + k;
                xr = wr * re[ik] + wi * im[ik];
                xi = wr * im[ik] - wi * re[ik];
                re[ik] = re[i2] - xr;
                re[i2] += xr;
                im[ik] = im[i2] - xi;
                im[i2] += xi;
              }
              h += d;
            }
          }
        },
        // initialize the array (supports TypedArray)
        _initArray: function() {
          if (typeof Uint32Array !== "undefined") {
            _bitrev = new Uint32Array(_n);
          } else {
            _bitrev = [];
          }
          if (typeof Float64Array !== "undefined") {
            _cstb = new Float64Array(_n * 1.25);
          } else {
            _cstb = [];
          }
        },
        // zero padding
        _paddingZero: function() {
        },
        // makes bit reversal table
        _makeBitReversalTable: function() {
          var i2 = 0, j = 0, k = 0;
          _bitrev[0] = 0;
          while (++i2 < _n) {
            k = _n >> 1;
            while (k <= j) {
              j -= k;
              k >>= 1;
            }
            j += k;
            _bitrev[i2] = j;
          }
        },
        // makes trigonometiric function table
        _makeCosSinTable: function() {
          var n2 = _n >> 1, n4 = _n >> 2, n8 = _n >> 3, n2p4 = n2 + n4, t = Math.sin(Math.PI / _n), dc = 2 * t * t, ds = Math.sqrt(dc * (2 - dc)), c = _cstb[n4] = 1, s = _cstb[0] = 0;
          t = 2 * dc;
          for (var i2 = 1; i2 < n8; i2++) {
            c -= dc;
            dc += t * c;
            s += ds;
            ds -= t * s;
            _cstb[i2] = s;
            _cstb[n4 - i2] = c;
          }
          if (n8 !== 0) {
            _cstb[n8] = Math.sqrt(0.5);
          }
          for (var j = 0; j < n4; j++) {
            _cstb[n2 - j] = _cstb[j];
          }
          for (var k = 0; k < n2p4; k++) {
            _cstb[k + n2] = -_cstb[k];
          }
        }
      };
      var apis = ["init", "fft1d", "ifft1d", "fft2d", "ifft2d"];
      for (var i = 0; i < apis.length; i++) {
        FFT2[apis[i]] = core[apis[i]];
      }
      FFT2.bt = core.bt1d;
      FFT2.fft = core.fft1d;
      FFT2.ifft = core.ifft1d;
      return FFT2;
    }.call(exports2);
  }
});

// node_modules/ml-fft/src/FFTUtils.js
var require_FFTUtils = __commonJS({
  "node_modules/ml-fft/src/FFTUtils.js"(exports2, module2) {
    "use strict";
    var FFT = require_fftlib();
    var FFTUtils = {
      DEBUG: false,
      /**
       * Calculates the inverse of a 2D Fourier transform
       *
       * @param ft
       * @param ftRows
       * @param ftCols
       * @return
       */
      ifft2DArray: function(ft, ftRows, ftCols) {
        var tempTransform = new Array(ftRows * ftCols);
        var nRows = ftRows / 2;
        var nCols = (ftCols - 1) * 2;
        FFT.init(nRows);
        var tmpCols = { re: new Array(nRows), im: new Array(nRows) };
        for (var iCol = 0; iCol < ftCols; iCol++) {
          for (var iRow = nRows - 1; iRow >= 0; iRow--) {
            tmpCols.re[iRow] = ft[iRow * 2 * ftCols + iCol];
            tmpCols.im[iRow] = ft[(iRow * 2 + 1) * ftCols + iCol];
          }
          FFT.bt(tmpCols.re, tmpCols.im);
          for (var iRow = nRows - 1; iRow >= 0; iRow--) {
            tempTransform[iRow * 2 * ftCols + iCol] = tmpCols.re[iRow];
            tempTransform[(iRow * 2 + 1) * ftCols + iCol] = tmpCols.im[iRow];
          }
        }
        var finalTransform = new Array(nRows * nCols);
        FFT.init(nCols);
        var tmpRows = { re: new Array(nCols), im: new Array(nCols) };
        var scale = nCols * nRows;
        for (var iRow = 0; iRow < ftRows; iRow += 2) {
          tmpRows.re[0] = tempTransform[iRow * ftCols];
          tmpRows.im[0] = tempTransform[(iRow + 1) * ftCols];
          for (var iCol = 1; iCol < ftCols; iCol++) {
            tmpRows.re[iCol] = tempTransform[iRow * ftCols + iCol];
            tmpRows.im[iCol] = tempTransform[(iRow + 1) * ftCols + iCol];
            tmpRows.re[nCols - iCol] = tempTransform[iRow * ftCols + iCol];
            tmpRows.im[nCols - iCol] = -tempTransform[(iRow + 1) * ftCols + iCol];
          }
          FFT.bt(tmpRows.re, tmpRows.im);
          var indexB = iRow / 2 * nCols;
          for (var iCol = nCols - 1; iCol >= 0; iCol--) {
            finalTransform[indexB + iCol] = tmpRows.re[iCol] / scale;
          }
        }
        return finalTransform;
      },
      /**
       * Calculates the fourier transform of a matrix of size (nRows,nCols) It is
       * assumed that both nRows and nCols are a power of two
       *
       * On exit the matrix has dimensions (nRows * 2, nCols / 2 + 1) where the
       * even rows contain the real part and the odd rows the imaginary part of the
       * transform
       * @param data
       * @param nRows
       * @param nCols
       * @return
       */
      fft2DArray: function(data, nRows, nCols, opt) {
        var options = Object.assign({}, { inplace: true });
        var ftCols = nCols / 2 + 1;
        var ftRows = nRows * 2;
        var tempTransform = new Array(ftRows * ftCols);
        FFT.init(nCols);
        var tmpRows = { re: new Array(nCols), im: new Array(nCols) };
        var row1 = { re: new Array(nCols), im: new Array(nCols) };
        var row2 = { re: new Array(nCols), im: new Array(nCols) };
        var index, iRow0, iRow1, iRow2, iRow3;
        for (var iRow = 0; iRow < nRows / 2; iRow++) {
          index = iRow * 2 * nCols;
          tmpRows.re = data.slice(index, index + nCols);
          index = (iRow * 2 + 1) * nCols;
          tmpRows.im = data.slice(index, index + nCols);
          FFT.fft1d(tmpRows.re, tmpRows.im);
          this.reconstructTwoRealFFT(tmpRows, row1, row2);
          iRow0 = iRow * 4 * ftCols;
          iRow1 = (iRow * 4 + 1) * ftCols;
          iRow2 = (iRow * 4 + 2) * ftCols;
          iRow3 = (iRow * 4 + 3) * ftCols;
          for (var k = ftCols - 1; k >= 0; k--) {
            tempTransform[iRow0 + k] = row1.re[k];
            tempTransform[iRow1 + k] = row1.im[k];
            tempTransform[iRow2 + k] = row2.re[k];
            tempTransform[iRow3 + k] = row2.im[k];
          }
        }
        row1 = null;
        row2 = null;
        var finalTransform = new Array(ftRows * ftCols);
        FFT.init(nRows);
        var tmpCols = { re: new Array(nRows), im: new Array(nRows) };
        for (var iCol = ftCols - 1; iCol >= 0; iCol--) {
          for (var iRow = nRows - 1; iRow >= 0; iRow--) {
            tmpCols.re[iRow] = tempTransform[iRow * 2 * ftCols + iCol];
            tmpCols.im[iRow] = tempTransform[(iRow * 2 + 1) * ftCols + iCol];
            if (isNaN(tmpCols.re[iRow])) {
              tmpCols.re[iRow] = 0;
            }
            if (isNaN(tmpCols.im[iRow])) {
              tmpCols.im[iRow] = 0;
            }
          }
          FFT.fft1d(tmpCols.re, tmpCols.im);
          for (var iRow = nRows - 1; iRow >= 0; iRow--) {
            finalTransform[iRow * 2 * ftCols + iCol] = tmpCols.re[iRow];
            finalTransform[(iRow * 2 + 1) * ftCols + iCol] = tmpCols.im[iRow];
          }
        }
        return finalTransform;
      },
      /**
       *
       * @param fourierTransform
       * @param realTransform1
       * @param realTransform2
       *
       * Reconstructs the individual Fourier transforms of two simultaneously
       * transformed series. Based on the Symmetry relationships (the asterisk
       * denotes the complex conjugate)
       *
       * F_{N-n} = F_n^{*} for a purely real f transformed to F
       *
       * G_{N-n} = G_n^{*} for a purely imaginary g transformed to G
       *
       */
      reconstructTwoRealFFT: function(fourierTransform, realTransform1, realTransform2) {
        var length = fourierTransform.re.length;
        realTransform1.re[0] = fourierTransform.re[0];
        realTransform1.im[0] = 0;
        realTransform2.re[0] = fourierTransform.im[0];
        realTransform2.im[0] = 0;
        var rm, rp, im, ip, j;
        for (var i = length / 2; i > 0; i--) {
          j = length - i;
          rm = 0.5 * (fourierTransform.re[i] - fourierTransform.re[j]);
          rp = 0.5 * (fourierTransform.re[i] + fourierTransform.re[j]);
          im = 0.5 * (fourierTransform.im[i] - fourierTransform.im[j]);
          ip = 0.5 * (fourierTransform.im[i] + fourierTransform.im[j]);
          realTransform1.re[i] = rp;
          realTransform1.im[i] = im;
          realTransform1.re[j] = rp;
          realTransform1.im[j] = -im;
          realTransform2.re[i] = ip;
          realTransform2.im[i] = -rm;
          realTransform2.re[j] = ip;
          realTransform2.im[j] = rm;
        }
      },
      /**
       * In place version of convolute 2D
       *
       * @param ftSignal
       * @param ftFilter
       * @param ftRows
       * @param ftCols
       * @return
       */
      convolute2DI: function(ftSignal, ftFilter, ftRows, ftCols) {
        var re, im;
        for (var iRow = 0; iRow < ftRows / 2; iRow++) {
          for (var iCol = 0; iCol < ftCols; iCol++) {
            re = ftSignal[iRow * 2 * ftCols + iCol] * ftFilter[iRow * 2 * ftCols + iCol] - ftSignal[(iRow * 2 + 1) * ftCols + iCol] * ftFilter[(iRow * 2 + 1) * ftCols + iCol];
            im = ftSignal[iRow * 2 * ftCols + iCol] * ftFilter[(iRow * 2 + 1) * ftCols + iCol] + ftSignal[(iRow * 2 + 1) * ftCols + iCol] * ftFilter[iRow * 2 * ftCols + iCol];
            ftSignal[iRow * 2 * ftCols + iCol] = re;
            ftSignal[(iRow * 2 + 1) * ftCols + iCol] = im;
          }
        }
      },
      /**
       *
       * @param data
       * @param kernel
       * @param nRows
       * @param nCols
       * @returns {*}
       */
      convolute: function(data, kernel, nRows, nCols, opt) {
        var ftSpectrum = new Array(nCols * nRows);
        for (var i = 0; i < nRows * nCols; i++) {
          ftSpectrum[i] = data[i];
        }
        ftSpectrum = this.fft2DArray(ftSpectrum, nRows, nCols);
        var dimR = kernel.length;
        var dimC = kernel[0].length;
        var ftFilterData = new Array(nCols * nRows);
        for (var i = 0; i < nCols * nRows; i++) {
          ftFilterData[i] = 0;
        }
        var iRow, iCol;
        var shiftR = Math.floor((dimR - 1) / 2);
        var shiftC = Math.floor((dimC - 1) / 2);
        for (var ir = 0; ir < dimR; ir++) {
          iRow = (ir - shiftR + nRows) % nRows;
          for (var ic = 0; ic < dimC; ic++) {
            iCol = (ic - shiftC + nCols) % nCols;
            ftFilterData[iRow * nCols + iCol] = kernel[ir][ic];
          }
        }
        ftFilterData = this.fft2DArray(ftFilterData, nRows, nCols);
        var ftRows = nRows * 2;
        var ftCols = nCols / 2 + 1;
        this.convolute2DI(ftSpectrum, ftFilterData, ftRows, ftCols);
        return this.ifft2DArray(ftSpectrum, ftRows, ftCols);
      },
      toRadix2: function(data, nRows, nCols) {
        var i, j, irow, icol;
        var cols = nCols, rows = nRows, prows = 0, pcols = 0;
        if (!(nCols !== 0 && (nCols & nCols - 1) === 0)) {
          cols = 0;
          while (nCols >> ++cols != 0)
            ;
          cols = 1 << cols;
          pcols = cols - nCols;
        }
        if (!(nRows !== 0 && (nRows & nRows - 1) === 0)) {
          rows = 0;
          while (nRows >> ++rows != 0)
            ;
          rows = 1 << rows;
          prows = (rows - nRows) * cols;
        }
        if (rows == nRows && cols == nCols)
          return { data, rows: nRows, cols: nCols };
        var output = new Array(rows * cols);
        var shiftR = Math.floor((rows - nRows) / 2) - nRows;
        var shiftC = Math.floor((cols - nCols) / 2) - nCols;
        for (i = 0; i < rows; i++) {
          irow = i * cols;
          icol = (i - shiftR) % nRows * nCols;
          for (j = 0; j < cols; j++) {
            output[irow + j] = data[icol + (j - shiftC) % nCols];
          }
        }
        return { data: output, rows, cols };
      },
      /**
       * Crop the given matrix to fit the corresponding number of rows and columns
       */
      crop: function(data, rows, cols, nRows, nCols, opt) {
        if (rows == nRows && cols == nCols)
          return data;
        var options = Object.assign({}, opt);
        var output = new Array(nCols * nRows);
        var shiftR = Math.floor((rows - nRows) / 2);
        var shiftC = Math.floor((cols - nCols) / 2);
        var destinyRow, sourceRow, i, j;
        for (i = 0; i < nRows; i++) {
          destinyRow = i * nCols;
          sourceRow = (i + shiftR) * cols;
          for (j = 0; j < nCols; j++) {
            output[destinyRow + j] = data[sourceRow + (j + shiftC)];
          }
        }
        return output;
      }
    };
    module2.exports = FFTUtils;
  }
});

// node_modules/ml-fft/src/index.js
var require_src4 = __commonJS({
  "node_modules/ml-fft/src/index.js"(exports2) {
    "use strict";
    exports2.FFTUtils = require_FFTUtils();
    exports2.FFT = require_fftlib();
  }
});

// node_modules/ml-matrix-convolution/src/index.js
var require_src5 = __commonJS({
  "node_modules/ml-matrix-convolution/src/index.js"(exports2, module2) {
    "use strict;";
    var FFTUtils = require_src4().FFTUtils;
    function convolutionFFT(input, kernel, opt) {
      var tmp = matrix2Array(input);
      var inputData = tmp.data;
      var options = Object.assign({ normalize: false, divisor: 1, rows: tmp.rows, cols: tmp.cols }, opt);
      var nRows, nCols;
      if (options.rows && options.cols) {
        nRows = options.rows;
        nCols = options.cols;
      } else {
        throw new Error("Invalid number of rows or columns " + nRows + " " + nCols);
      }
      var divisor = options.divisor;
      var i, j;
      var kHeight = kernel.length;
      var kWidth = kernel[0].length;
      if (options.normalize) {
        divisor = 0;
        for (i = 0; i < kHeight; i++)
          for (j = 0; j < kWidth; j++)
            divisor += kernel[i][j];
      }
      if (divisor === 0) {
        throw new RangeError("convolution: The divisor is equal to zero");
      }
      var radix2Sized = FFTUtils.toRadix2(inputData, nRows, nCols);
      var conv = FFTUtils.convolute(radix2Sized.data, kernel, radix2Sized.rows, radix2Sized.cols);
      conv = FFTUtils.crop(conv, radix2Sized.rows, radix2Sized.cols, nRows, nCols);
      if (divisor != 0 && divisor != 1) {
        for (i = 0; i < conv.length; i++) {
          conv[i] /= divisor;
        }
      }
      return conv;
    }
    function convolutionDirect(input, kernel, opt) {
      var tmp = matrix2Array(input);
      var inputData = tmp.data;
      var options = Object.assign({ normalize: false, divisor: 1, rows: tmp.rows, cols: tmp.cols }, opt);
      var nRows, nCols;
      if (options.rows && options.cols) {
        nRows = options.rows;
        nCols = options.cols;
      } else {
        throw new Error("Invalid number of rows or columns " + nRows + " " + nCols);
      }
      var divisor = options.divisor;
      var kHeight = kernel.length;
      var kWidth = kernel[0].length;
      var i, j, x, y, index, sum, kVal, row, col;
      if (options.normalize) {
        divisor = 0;
        for (i = 0; i < kHeight; i++)
          for (j = 0; j < kWidth; j++)
            divisor += kernel[i][j];
      }
      if (divisor === 0) {
        throw new RangeError("convolution: The divisor is equal to zero");
      }
      var output = new Array(nRows * nCols);
      var hHeight = Math.floor(kHeight / 2);
      var hWidth = Math.floor(kWidth / 2);
      for (y = 0; y < nRows; y++) {
        for (x = 0; x < nCols; x++) {
          sum = 0;
          for (j = 0; j < kHeight; j++) {
            for (i = 0; i < kWidth; i++) {
              kVal = kernel[kHeight - j - 1][kWidth - i - 1];
              row = (y + j - hHeight + nRows) % nRows;
              col = (x + i - hWidth + nCols) % nCols;
              index = row * nCols + col;
              sum += inputData[index] * kVal;
            }
          }
          index = y * nCols + x;
          output[index] = sum / divisor;
        }
      }
      return output;
    }
    function LoG(sigma, nPoints, options) {
      var factor = 1e3;
      if (options && options.factor) {
        factor = options.factor;
      }
      var kernel = new Array(nPoints);
      var i, j, tmp, y2, tmp2;
      factor *= -1;
      var center = (nPoints - 1) / 2;
      var sigma2 = 2 * sigma * sigma;
      for (i = 0; i < nPoints; i++) {
        kernel[i] = new Array(nPoints);
        y2 = (i - center) * (i - center);
        for (j = 0; j < nPoints; j++) {
          tmp = -((j - center) * (j - center) + y2) / sigma2;
          kernel[i][j] = Math.round(factor * (1 + tmp) * Math.exp(tmp));
        }
      }
      return kernel;
    }
    function matrix2Array(input) {
      var inputData = input;
      var nRows, nCols;
      if (typeof input[0] != "number") {
        nRows = input.length;
        nCols = input[0].length;
        inputData = new Array(nRows * nCols);
        for (var i = 0; i < nRows; i++) {
          for (var j = 0; j < nCols; j++) {
            inputData[i * nCols + j] = input[i][j];
          }
        }
      } else {
        var tmp = Math.sqrt(input.length);
        if (Number.isInteger(tmp)) {
          nRows = tmp;
          nCols = tmp;
        }
      }
      return { data: inputData, rows: nRows, cols: nCols };
    }
    module2.exports = {
      fft: convolutionFFT,
      direct: convolutionDirect,
      kernelFactory: { LoG },
      matrix2Array
    };
  }
});

// node_modules/is-finite/index.js
var require_is_finite = __commonJS({
  "node_modules/is-finite/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Number.isFinite || function(value) {
      return !(typeof value !== "number" || value !== value || value === Infinity || value === -Infinity);
    };
  }
});

// node_modules/is-integer/index.js
var require_is_integer = __commonJS({
  "node_modules/is-integer/index.js"(exports2, module2) {
    var isFinite2 = require_is_finite();
    module2.exports = Number.isInteger || function(val) {
      return typeof val === "number" && isFinite2(val) && Math.floor(val) === val;
    };
  }
});

// node_modules/image-js/lib/util/kernel.js
var require_kernel = __commonJS({
  "node_modules/image-js/lib/util/kernel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.validateKernel = validateKernel;
    var _isInteger = _interopRequireDefault(require_is_integer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function validateKernel(kernel) {
      let kHeight, kWidth;
      if (Array.isArray(kernel)) {
        if (Array.isArray(kernel[0])) {
          if ((kernel.length & 1) === 0 || (kernel[0].length & 1) === 0) {
            throw new RangeError("validateKernel: Kernel rows and columns should be odd numbers");
          } else {
            kHeight = Math.floor(kernel.length / 2);
            kWidth = Math.floor(kernel[0].length / 2);
          }
        } else {
          let kernelWidth = Math.sqrt(kernel.length);
          if ((0, _isInteger.default)(kernelWidth)) {
            kWidth = kHeight = Math.floor(Math.sqrt(kernel.length) / 2);
          } else {
            throw new RangeError("validateKernel: Kernel array should be a square");
          }
          let newKernel = new Array(kernelWidth);
          for (let i = 0; i < kernelWidth; i++) {
            newKernel[i] = new Array(kernelWidth);
            for (let j = 0; j < kernelWidth; j++) {
              newKernel[i][j] = kernel[i * kernelWidth + j];
            }
          }
          kernel = newKernel;
        }
      } else {
        throw new Error(`validateKernel: Invalid Kernel: ${kernel}`);
      }
      return {
        kernel,
        kWidth,
        kHeight
      };
    }
  }
});

// node_modules/image-js/lib/image/internal/clamp.js
var require_clamp = __commonJS({
  "node_modules/image-js/lib/image/internal/clamp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.clamp = clamp;
    function clamp(value, image) {
      return Math.round(Math.min(Math.max(value, 0), image.maxValue));
    }
  }
});

// node_modules/fft.js/lib/fft.js
var require_fft = __commonJS({
  "node_modules/fft.js/lib/fft.js"(exports2, module2) {
    "use strict";
    function FFT(size) {
      this.size = size | 0;
      if (this.size <= 1 || (this.size & this.size - 1) !== 0)
        throw new Error("FFT size must be a power of two and bigger than 1");
      this._csize = size << 1;
      var table = new Array(this.size * 2);
      for (var i = 0; i < table.length; i += 2) {
        const angle = Math.PI * i / this.size;
        table[i] = Math.cos(angle);
        table[i + 1] = -Math.sin(angle);
      }
      this.table = table;
      var power = 0;
      for (var t = 1; this.size > t; t <<= 1)
        power++;
      this._width = power % 2 === 0 ? power - 1 : power;
      this._bitrev = new Array(1 << this._width);
      for (var j = 0; j < this._bitrev.length; j++) {
        this._bitrev[j] = 0;
        for (var shift = 0; shift < this._width; shift += 2) {
          var revShift = this._width - shift - 2;
          this._bitrev[j] |= (j >>> shift & 3) << revShift;
        }
      }
      this._out = null;
      this._data = null;
      this._inv = 0;
    }
    module2.exports = FFT;
    FFT.prototype.fromComplexArray = function fromComplexArray(complex, storage) {
      var res = storage || new Array(complex.length >>> 1);
      for (var i = 0; i < complex.length; i += 2)
        res[i >>> 1] = complex[i];
      return res;
    };
    FFT.prototype.createComplexArray = function createComplexArray() {
      const res = new Array(this._csize);
      for (var i = 0; i < res.length; i++)
        res[i] = 0;
      return res;
    };
    FFT.prototype.toComplexArray = function toComplexArray(input, storage) {
      var res = storage || this.createComplexArray();
      for (var i = 0; i < res.length; i += 2) {
        res[i] = input[i >>> 1];
        res[i + 1] = 0;
      }
      return res;
    };
    FFT.prototype.completeSpectrum = function completeSpectrum(spectrum) {
      var size = this._csize;
      var half = size >>> 1;
      for (var i = 2; i < half; i += 2) {
        spectrum[size - i] = spectrum[i];
        spectrum[size - i + 1] = -spectrum[i + 1];
      }
    };
    FFT.prototype.transform = function transform(out, data) {
      if (out === data)
        throw new Error("Input and output buffers must be different");
      this._out = out;
      this._data = data;
      this._inv = 0;
      this._transform4();
      this._out = null;
      this._data = null;
    };
    FFT.prototype.realTransform = function realTransform(out, data) {
      if (out === data)
        throw new Error("Input and output buffers must be different");
      this._out = out;
      this._data = data;
      this._inv = 0;
      this._realTransform4();
      this._out = null;
      this._data = null;
    };
    FFT.prototype.inverseTransform = function inverseTransform(out, data) {
      if (out === data)
        throw new Error("Input and output buffers must be different");
      this._out = out;
      this._data = data;
      this._inv = 1;
      this._transform4();
      for (var i = 0; i < out.length; i++)
        out[i] /= this.size;
      this._out = null;
      this._data = null;
    };
    FFT.prototype._transform4 = function _transform4() {
      var out = this._out;
      var size = this._csize;
      var width = this._width;
      var step = 1 << width;
      var len = size / step << 1;
      var outOff;
      var t;
      var bitrev = this._bitrev;
      if (len === 4) {
        for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {
          const off = bitrev[t];
          this._singleTransform2(outOff, off, step);
        }
      } else {
        for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {
          const off = bitrev[t];
          this._singleTransform4(outOff, off, step);
        }
      }
      var inv = this._inv ? -1 : 1;
      var table = this.table;
      for (step >>= 2; step >= 2; step >>= 2) {
        len = size / step << 1;
        var quarterLen = len >>> 2;
        for (outOff = 0; outOff < size; outOff += len) {
          var limit = outOff + quarterLen;
          for (var i = outOff, k = 0; i < limit; i += 2, k += step) {
            const A = i;
            const B = A + quarterLen;
            const C = B + quarterLen;
            const D = C + quarterLen;
            const Ar = out[A];
            const Ai = out[A + 1];
            const Br = out[B];
            const Bi = out[B + 1];
            const Cr = out[C];
            const Ci = out[C + 1];
            const Dr = out[D];
            const Di = out[D + 1];
            const MAr = Ar;
            const MAi = Ai;
            const tableBr = table[k];
            const tableBi = inv * table[k + 1];
            const MBr = Br * tableBr - Bi * tableBi;
            const MBi = Br * tableBi + Bi * tableBr;
            const tableCr = table[2 * k];
            const tableCi = inv * table[2 * k + 1];
            const MCr = Cr * tableCr - Ci * tableCi;
            const MCi = Cr * tableCi + Ci * tableCr;
            const tableDr = table[3 * k];
            const tableDi = inv * table[3 * k + 1];
            const MDr = Dr * tableDr - Di * tableDi;
            const MDi = Dr * tableDi + Di * tableDr;
            const T0r = MAr + MCr;
            const T0i = MAi + MCi;
            const T1r = MAr - MCr;
            const T1i = MAi - MCi;
            const T2r = MBr + MDr;
            const T2i = MBi + MDi;
            const T3r = inv * (MBr - MDr);
            const T3i = inv * (MBi - MDi);
            const FAr = T0r + T2r;
            const FAi = T0i + T2i;
            const FCr = T0r - T2r;
            const FCi = T0i - T2i;
            const FBr = T1r + T3i;
            const FBi = T1i - T3r;
            const FDr = T1r - T3i;
            const FDi = T1i + T3r;
            out[A] = FAr;
            out[A + 1] = FAi;
            out[B] = FBr;
            out[B + 1] = FBi;
            out[C] = FCr;
            out[C + 1] = FCi;
            out[D] = FDr;
            out[D + 1] = FDi;
          }
        }
      }
    };
    FFT.prototype._singleTransform2 = function _singleTransform2(outOff, off, step) {
      const out = this._out;
      const data = this._data;
      const evenR = data[off];
      const evenI = data[off + 1];
      const oddR = data[off + step];
      const oddI = data[off + step + 1];
      const leftR = evenR + oddR;
      const leftI = evenI + oddI;
      const rightR = evenR - oddR;
      const rightI = evenI - oddI;
      out[outOff] = leftR;
      out[outOff + 1] = leftI;
      out[outOff + 2] = rightR;
      out[outOff + 3] = rightI;
    };
    FFT.prototype._singleTransform4 = function _singleTransform4(outOff, off, step) {
      const out = this._out;
      const data = this._data;
      const inv = this._inv ? -1 : 1;
      const step2 = step * 2;
      const step3 = step * 3;
      const Ar = data[off];
      const Ai = data[off + 1];
      const Br = data[off + step];
      const Bi = data[off + step + 1];
      const Cr = data[off + step2];
      const Ci = data[off + step2 + 1];
      const Dr = data[off + step3];
      const Di = data[off + step3 + 1];
      const T0r = Ar + Cr;
      const T0i = Ai + Ci;
      const T1r = Ar - Cr;
      const T1i = Ai - Ci;
      const T2r = Br + Dr;
      const T2i = Bi + Di;
      const T3r = inv * (Br - Dr);
      const T3i = inv * (Bi - Di);
      const FAr = T0r + T2r;
      const FAi = T0i + T2i;
      const FBr = T1r + T3i;
      const FBi = T1i - T3r;
      const FCr = T0r - T2r;
      const FCi = T0i - T2i;
      const FDr = T1r - T3i;
      const FDi = T1i + T3r;
      out[outOff] = FAr;
      out[outOff + 1] = FAi;
      out[outOff + 2] = FBr;
      out[outOff + 3] = FBi;
      out[outOff + 4] = FCr;
      out[outOff + 5] = FCi;
      out[outOff + 6] = FDr;
      out[outOff + 7] = FDi;
    };
    FFT.prototype._realTransform4 = function _realTransform4() {
      var out = this._out;
      var size = this._csize;
      var width = this._width;
      var step = 1 << width;
      var len = size / step << 1;
      var outOff;
      var t;
      var bitrev = this._bitrev;
      if (len === 4) {
        for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {
          const off = bitrev[t];
          this._singleRealTransform2(outOff, off >>> 1, step >>> 1);
        }
      } else {
        for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {
          const off = bitrev[t];
          this._singleRealTransform4(outOff, off >>> 1, step >>> 1);
        }
      }
      var inv = this._inv ? -1 : 1;
      var table = this.table;
      for (step >>= 2; step >= 2; step >>= 2) {
        len = size / step << 1;
        var halfLen = len >>> 1;
        var quarterLen = halfLen >>> 1;
        var hquarterLen = quarterLen >>> 1;
        for (outOff = 0; outOff < size; outOff += len) {
          for (var i = 0, k = 0; i <= hquarterLen; i += 2, k += step) {
            var A = outOff + i;
            var B = A + quarterLen;
            var C = B + quarterLen;
            var D = C + quarterLen;
            var Ar = out[A];
            var Ai = out[A + 1];
            var Br = out[B];
            var Bi = out[B + 1];
            var Cr = out[C];
            var Ci = out[C + 1];
            var Dr = out[D];
            var Di = out[D + 1];
            var MAr = Ar;
            var MAi = Ai;
            var tableBr = table[k];
            var tableBi = inv * table[k + 1];
            var MBr = Br * tableBr - Bi * tableBi;
            var MBi = Br * tableBi + Bi * tableBr;
            var tableCr = table[2 * k];
            var tableCi = inv * table[2 * k + 1];
            var MCr = Cr * tableCr - Ci * tableCi;
            var MCi = Cr * tableCi + Ci * tableCr;
            var tableDr = table[3 * k];
            var tableDi = inv * table[3 * k + 1];
            var MDr = Dr * tableDr - Di * tableDi;
            var MDi = Dr * tableDi + Di * tableDr;
            var T0r = MAr + MCr;
            var T0i = MAi + MCi;
            var T1r = MAr - MCr;
            var T1i = MAi - MCi;
            var T2r = MBr + MDr;
            var T2i = MBi + MDi;
            var T3r = inv * (MBr - MDr);
            var T3i = inv * (MBi - MDi);
            var FAr = T0r + T2r;
            var FAi = T0i + T2i;
            var FBr = T1r + T3i;
            var FBi = T1i - T3r;
            out[A] = FAr;
            out[A + 1] = FAi;
            out[B] = FBr;
            out[B + 1] = FBi;
            if (i === 0) {
              var FCr = T0r - T2r;
              var FCi = T0i - T2i;
              out[C] = FCr;
              out[C + 1] = FCi;
              continue;
            }
            if (i === hquarterLen)
              continue;
            var ST0r = T1r;
            var ST0i = -T1i;
            var ST1r = T0r;
            var ST1i = -T0i;
            var ST2r = -inv * T3i;
            var ST2i = -inv * T3r;
            var ST3r = -inv * T2i;
            var ST3i = -inv * T2r;
            var SFAr = ST0r + ST2r;
            var SFAi = ST0i + ST2i;
            var SFBr = ST1r + ST3i;
            var SFBi = ST1i - ST3r;
            var SA = outOff + quarterLen - i;
            var SB = outOff + halfLen - i;
            out[SA] = SFAr;
            out[SA + 1] = SFAi;
            out[SB] = SFBr;
            out[SB + 1] = SFBi;
          }
        }
      }
    };
    FFT.prototype._singleRealTransform2 = function _singleRealTransform2(outOff, off, step) {
      const out = this._out;
      const data = this._data;
      const evenR = data[off];
      const oddR = data[off + step];
      const leftR = evenR + oddR;
      const rightR = evenR - oddR;
      out[outOff] = leftR;
      out[outOff + 1] = 0;
      out[outOff + 2] = rightR;
      out[outOff + 3] = 0;
    };
    FFT.prototype._singleRealTransform4 = function _singleRealTransform4(outOff, off, step) {
      const out = this._out;
      const data = this._data;
      const inv = this._inv ? -1 : 1;
      const step2 = step * 2;
      const step3 = step * 3;
      const Ar = data[off];
      const Br = data[off + step];
      const Cr = data[off + step2];
      const Dr = data[off + step3];
      const T0r = Ar + Cr;
      const T1r = Ar - Cr;
      const T2r = Br + Dr;
      const T3r = inv * (Br - Dr);
      const FAr = T0r + T2r;
      const FBr = T1r;
      const FBi = -T3r;
      const FCr = T0r - T2r;
      const FDr = T1r;
      const FDi = T3r;
      out[outOff] = FAr;
      out[outOff + 1] = 0;
      out[outOff + 2] = FBr;
      out[outOff + 3] = FBi;
      out[outOff + 4] = FCr;
      out[outOff + 5] = 0;
      out[outOff + 6] = FDr;
      out[outOff + 7] = FDi;
    };
  }
});

// node_modules/next-power-of-two/index.js
var require_next_power_of_two = __commonJS({
  "node_modules/next-power-of-two/index.js"(exports2, module2) {
    module2.exports = nextPowerOfTwo;
    function nextPowerOfTwo(n) {
      if (n === 0)
        return 1;
      n--;
      n |= n >> 1;
      n |= n >> 2;
      n |= n >> 4;
      n |= n >> 8;
      n |= n >> 16;
      return n + 1;
    }
  }
});

// node_modules/ml-convolution/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/ml-convolution/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var FFT = _interopDefault(require_fft());
    var nextPOT = _interopDefault(require_next_power_of_two());
    function directConvolution(input, kernel, output) {
      if (output === void 0) {
        const length = input.length + kernel.length - 1;
        output = new Array(length);
      }
      fill(output);
      for (var i = 0; i < input.length; i++) {
        for (var j = 0; j < kernel.length; j++) {
          output[i + j] += input[i] * kernel[j];
        }
      }
      return output;
    }
    function fill(array) {
      for (var i = 0; i < array.length; i++) {
        array[i] = 0;
      }
    }
    function fftConvolution(input, kernel) {
      const resultLength = input.length + kernel.length - 1;
      const fftLength = nextPOT(resultLength);
      const fft = new FFT(fftLength);
      const { output: fftKernel, input: result } = createPaddedFFt(kernel, fft, fftLength);
      const { output: fftInput } = createPaddedFFt(input, fft, fftLength);
      const fftConv = fftInput;
      const conv = fftKernel;
      for (var i = 0; i < fftConv.length; i += 2) {
        const tmp = fftInput[i] * fftKernel[i] - fftInput[i + 1] * fftKernel[i + 1];
        fftConv[i + 1] = fftInput[i] * fftKernel[i + 1] + fftInput[i + 1] * fftKernel[i];
        fftConv[i] = tmp;
      }
      fft.inverseTransform(conv, fftConv);
      return fft.fromComplexArray(conv, result).slice(0, resultLength);
    }
    function createPaddedFFt(data, fft, length) {
      const input = new Array(length);
      var i = 0;
      for (; i < data.length; i++) {
        input[i] = data[i];
      }
      for (; i < length; i++) {
        input[i] = 0;
      }
      const fftInput = fft.toComplexArray(input);
      const output = fft.createComplexArray();
      fft.transform(output, fftInput);
      return {
        output,
        input,
        fftInput
      };
    }
    exports2.directConvolution = directConvolution;
    exports2.fftConvolution = fftConvolution;
  }
});

// node_modules/image-js/lib/image/operator/convolutionSeparable.js
var require_convolutionSeparable = __commonJS({
  "node_modules/image-js/lib/image/operator/convolutionSeparable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = convolutionSeparable;
    var _mlConvolution = require_lib3();
    function convolutionSeparable(data, separatedKernel, width, height) {
      const result = new Array(data.length);
      let tmp, conv, offset, kernel;
      kernel = separatedKernel[1];
      offset = (kernel.length - 1) / 2;
      conv = new Array(width + kernel.length - 1);
      tmp = new Array(width);
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          tmp[x] = data[y * width + x];
        }
        (0, _mlConvolution.directConvolution)(tmp, kernel, conv);
        for (let x = 0; x < width; x++) {
          result[y * width + x] = conv[offset + x];
        }
      }
      kernel = separatedKernel[0];
      offset = (kernel.length - 1) / 2;
      conv = new Array(height + kernel.length - 1);
      tmp = new Array(height);
      for (let x = 0; x < width; x++) {
        for (let y = 0; y < height; y++) {
          tmp[y] = result[y * width + x];
        }
        (0, _mlConvolution.directConvolution)(tmp, kernel, conv);
        for (let y = 0; y < height; y++) {
          result[y * width + x] = conv[offset + y];
        }
      }
      return result;
    }
  }
});

// node_modules/is-any-array/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/is-any-array/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAnyArray = void 0;
    var toString = Object.prototype.toString;
    function isAnyArray(value) {
      const tag = toString.call(value);
      return tag.endsWith("Array]") && !tag.includes("Big");
    }
    exports2.isAnyArray = isAnyArray;
  }
});

// node_modules/ml-array-max/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/ml-array-max/lib/index.js"(exports2, module2) {
    "use strict";
    var isAnyArray = require_lib4();
    function max(input, options = {}) {
      if (!isAnyArray.isAnyArray(input)) {
        throw new TypeError("input must be an array");
      }
      if (input.length === 0) {
        throw new TypeError("input must not be empty");
      }
      const { fromIndex = 0, toIndex = input.length } = options;
      if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
        throw new Error("fromIndex must be a positive integer smaller than length");
      }
      if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
        throw new Error(
          "toIndex must be an integer greater than fromIndex and at most equal to length"
        );
      }
      let maxValue = input[fromIndex];
      for (let i = fromIndex + 1; i < toIndex; i++) {
        if (input[i] > maxValue)
          maxValue = input[i];
      }
      return maxValue;
    }
    module2.exports = max;
  }
});

// node_modules/ml-array-min/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/ml-array-min/lib/index.js"(exports2, module2) {
    "use strict";
    var isAnyArray = require_lib4();
    function min(input, options = {}) {
      if (!isAnyArray.isAnyArray(input)) {
        throw new TypeError("input must be an array");
      }
      if (input.length === 0) {
        throw new TypeError("input must not be empty");
      }
      const { fromIndex = 0, toIndex = input.length } = options;
      if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
        throw new Error("fromIndex must be a positive integer smaller than length");
      }
      if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
        throw new Error(
          "toIndex must be an integer greater than fromIndex and at most equal to length"
        );
      }
      let minValue = input[fromIndex];
      for (let i = fromIndex + 1; i < toIndex; i++) {
        if (input[i] < minValue)
          minValue = input[i];
      }
      return minValue;
    }
    module2.exports = min;
  }
});

// node_modules/ml-array-rescale/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/ml-array-rescale/lib/index.js"(exports2, module2) {
    "use strict";
    var isAnyArray = require_lib4();
    var max = require_lib5();
    var min = require_lib6();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var max__default = /* @__PURE__ */ _interopDefaultLegacy(max);
    var min__default = /* @__PURE__ */ _interopDefaultLegacy(min);
    function rescale(input, options = {}) {
      if (!isAnyArray.isAnyArray(input)) {
        throw new TypeError("input must be an array");
      } else if (input.length === 0) {
        throw new TypeError("input must not be empty");
      }
      let output;
      if (options.output !== void 0) {
        if (!isAnyArray.isAnyArray(options.output)) {
          throw new TypeError("output option must be an array if specified");
        }
        output = options.output;
      } else {
        output = new Array(input.length);
      }
      const currentMin = min__default["default"](input);
      const currentMax = max__default["default"](input);
      if (currentMin === currentMax) {
        throw new RangeError(
          "minimum and maximum input values are equal. Cannot rescale a constant array"
        );
      }
      const {
        min: minValue = options.autoMinMax ? currentMin : 0,
        max: maxValue = options.autoMinMax ? currentMax : 1
      } = options;
      if (minValue >= maxValue) {
        throw new RangeError("min option must be smaller than max option");
      }
      const factor = (maxValue - minValue) / (currentMax - currentMin);
      for (let i = 0; i < input.length; i++) {
        output[i] = (input[i] - currentMin) * factor + minValue;
      }
      return output;
    }
    module2.exports = rescale;
  }
});

// node_modules/ml-matrix/matrix.js
var require_matrix = __commonJS({
  "node_modules/ml-matrix/matrix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var isAnyArray = require_lib4();
    var rescale = require_lib7();
    var indent = " ".repeat(2);
    var indentData = " ".repeat(4);
    function inspectMatrix() {
      return inspectMatrixWithOptions(this);
    }
    function inspectMatrixWithOptions(matrix, options = {}) {
      const {
        maxRows = 15,
        maxColumns = 10,
        maxNumSize = 8,
        padMinus = "auto"
      } = options;
      return `${matrix.constructor.name} {
${indent}[
${indentData}${inspectData(matrix, maxRows, maxColumns, maxNumSize, padMinus)}
${indent}]
${indent}rows: ${matrix.rows}
${indent}columns: ${matrix.columns}
}`;
    }
    function inspectData(matrix, maxRows, maxColumns, maxNumSize, padMinus) {
      const { rows, columns } = matrix;
      const maxI = Math.min(rows, maxRows);
      const maxJ = Math.min(columns, maxColumns);
      const result = [];
      if (padMinus === "auto") {
        padMinus = false;
        loop:
          for (let i = 0; i < maxI; i++) {
            for (let j = 0; j < maxJ; j++) {
              if (matrix.get(i, j) < 0) {
                padMinus = true;
                break loop;
              }
            }
          }
      }
      for (let i = 0; i < maxI; i++) {
        let line = [];
        for (let j = 0; j < maxJ; j++) {
          line.push(formatNumber(matrix.get(i, j), maxNumSize, padMinus));
        }
        result.push(`${line.join(" ")}`);
      }
      if (maxJ !== columns) {
        result[result.length - 1] += ` ... ${columns - maxColumns} more columns`;
      }
      if (maxI !== rows) {
        result.push(`... ${rows - maxRows} more rows`);
      }
      return result.join(`
${indentData}`);
    }
    function formatNumber(num, maxNumSize, padMinus) {
      return (num >= 0 && padMinus ? ` ${formatNumber2(num, maxNumSize - 1)}` : formatNumber2(num, maxNumSize)).padEnd(maxNumSize);
    }
    function formatNumber2(num, len) {
      let str = num.toString();
      if (str.length <= len)
        return str;
      let fix = num.toFixed(len);
      if (fix.length > len) {
        fix = num.toFixed(Math.max(0, len - (fix.length - len)));
      }
      if (fix.length <= len && !fix.startsWith("0.000") && !fix.startsWith("-0.000")) {
        return fix;
      }
      let exp = num.toExponential(len);
      if (exp.length > len) {
        exp = num.toExponential(Math.max(0, len - (exp.length - len)));
      }
      return exp.slice(0);
    }
    function installMathOperations(AbstractMatrix2, Matrix2) {
      AbstractMatrix2.prototype.add = function add(value) {
        if (typeof value === "number")
          return this.addS(value);
        return this.addM(value);
      };
      AbstractMatrix2.prototype.addS = function addS(value) {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) + value);
          }
        }
        return this;
      };
      AbstractMatrix2.prototype.addM = function addM(matrix) {
        matrix = Matrix2.checkMatrix(matrix);
        if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) + matrix.get(i, j));
          }
        }
        return this;
      };
      AbstractMatrix2.add = function add(matrix, value) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.add(value);
      };
      AbstractMatrix2.prototype.sub = function sub(value) {
        if (typeof value === "number")
          return this.subS(value);
        return this.subM(value);
      };
      AbstractMatrix2.prototype.subS = function subS(value) {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) - value);
          }
        }
        return this;
      };
      AbstractMatrix2.prototype.subM = function subM(matrix) {
        matrix = Matrix2.checkMatrix(matrix);
        if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) - matrix.get(i, j));
          }
        }
        return this;
      };
      AbstractMatrix2.sub = function sub(matrix, value) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.sub(value);
      };
      AbstractMatrix2.prototype.subtract = AbstractMatrix2.prototype.sub;
      AbstractMatrix2.prototype.subtractS = AbstractMatrix2.prototype.subS;
      AbstractMatrix2.prototype.subtractM = AbstractMatrix2.prototype.subM;
      AbstractMatrix2.subtract = AbstractMatrix2.sub;
      AbstractMatrix2.prototype.mul = function mul(value) {
        if (typeof value === "number")
          return this.mulS(value);
        return this.mulM(value);
      };
      AbstractMatrix2.prototype.mulS = function mulS(value) {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) * value);
          }
        }
        return this;
      };
      AbstractMatrix2.prototype.mulM = function mulM(matrix) {
        matrix = Matrix2.checkMatrix(matrix);
        if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) * matrix.get(i, j));
          }
        }
        return this;
      };
      AbstractMatrix2.mul = function mul(matrix, value) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.mul(value);
      };
      AbstractMatrix2.prototype.multiply = AbstractMatrix2.prototype.mul;
      AbstractMatrix2.prototype.multiplyS = AbstractMatrix2.prototype.mulS;
      AbstractMatrix2.prototype.multiplyM = AbstractMatrix2.prototype.mulM;
      AbstractMatrix2.multiply = AbstractMatrix2.mul;
      AbstractMatrix2.prototype.div = function div(value) {
        if (typeof value === "number")
          return this.divS(value);
        return this.divM(value);
      };
      AbstractMatrix2.prototype.divS = function divS(value) {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) / value);
          }
        }
        return this;
      };
      AbstractMatrix2.prototype.divM = function divM(matrix) {
        matrix = Matrix2.checkMatrix(matrix);
        if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) / matrix.get(i, j));
          }
        }
        return this;
      };
      AbstractMatrix2.div = function div(matrix, value) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.div(value);
      };
      AbstractMatrix2.prototype.divide = AbstractMatrix2.prototype.div;
      AbstractMatrix2.prototype.divideS = AbstractMatrix2.prototype.divS;
      AbstractMatrix2.prototype.divideM = AbstractMatrix2.prototype.divM;
      AbstractMatrix2.divide = AbstractMatrix2.div;
      AbstractMatrix2.prototype.mod = function mod(value) {
        if (typeof value === "number")
          return this.modS(value);
        return this.modM(value);
      };
      AbstractMatrix2.prototype.modS = function modS(value) {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) % value);
          }
        }
        return this;
      };
      AbstractMatrix2.prototype.modM = function modM(matrix) {
        matrix = Matrix2.checkMatrix(matrix);
        if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) % matrix.get(i, j));
          }
        }
        return this;
      };
      AbstractMatrix2.mod = function mod(matrix, value) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.mod(value);
      };
      AbstractMatrix2.prototype.modulus = AbstractMatrix2.prototype.mod;
      AbstractMatrix2.prototype.modulusS = AbstractMatrix2.prototype.modS;
      AbstractMatrix2.prototype.modulusM = AbstractMatrix2.prototype.modM;
      AbstractMatrix2.modulus = AbstractMatrix2.mod;
      AbstractMatrix2.prototype.and = function and(value) {
        if (typeof value === "number")
          return this.andS(value);
        return this.andM(value);
      };
      AbstractMatrix2.prototype.andS = function andS(value) {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) & value);
          }
        }
        return this;
      };
      AbstractMatrix2.prototype.andM = function andM(matrix) {
        matrix = Matrix2.checkMatrix(matrix);
        if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) & matrix.get(i, j));
          }
        }
        return this;
      };
      AbstractMatrix2.and = function and(matrix, value) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.and(value);
      };
      AbstractMatrix2.prototype.or = function or(value) {
        if (typeof value === "number")
          return this.orS(value);
        return this.orM(value);
      };
      AbstractMatrix2.prototype.orS = function orS(value) {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) | value);
          }
        }
        return this;
      };
      AbstractMatrix2.prototype.orM = function orM(matrix) {
        matrix = Matrix2.checkMatrix(matrix);
        if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) | matrix.get(i, j));
          }
        }
        return this;
      };
      AbstractMatrix2.or = function or(matrix, value) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.or(value);
      };
      AbstractMatrix2.prototype.xor = function xor(value) {
        if (typeof value === "number")
          return this.xorS(value);
        return this.xorM(value);
      };
      AbstractMatrix2.prototype.xorS = function xorS(value) {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) ^ value);
          }
        }
        return this;
      };
      AbstractMatrix2.prototype.xorM = function xorM(matrix) {
        matrix = Matrix2.checkMatrix(matrix);
        if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) ^ matrix.get(i, j));
          }
        }
        return this;
      };
      AbstractMatrix2.xor = function xor(matrix, value) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.xor(value);
      };
      AbstractMatrix2.prototype.leftShift = function leftShift(value) {
        if (typeof value === "number")
          return this.leftShiftS(value);
        return this.leftShiftM(value);
      };
      AbstractMatrix2.prototype.leftShiftS = function leftShiftS(value) {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) << value);
          }
        }
        return this;
      };
      AbstractMatrix2.prototype.leftShiftM = function leftShiftM(matrix) {
        matrix = Matrix2.checkMatrix(matrix);
        if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) << matrix.get(i, j));
          }
        }
        return this;
      };
      AbstractMatrix2.leftShift = function leftShift(matrix, value) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.leftShift(value);
      };
      AbstractMatrix2.prototype.signPropagatingRightShift = function signPropagatingRightShift(value) {
        if (typeof value === "number")
          return this.signPropagatingRightShiftS(value);
        return this.signPropagatingRightShiftM(value);
      };
      AbstractMatrix2.prototype.signPropagatingRightShiftS = function signPropagatingRightShiftS(value) {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) >> value);
          }
        }
        return this;
      };
      AbstractMatrix2.prototype.signPropagatingRightShiftM = function signPropagatingRightShiftM(matrix) {
        matrix = Matrix2.checkMatrix(matrix);
        if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) >> matrix.get(i, j));
          }
        }
        return this;
      };
      AbstractMatrix2.signPropagatingRightShift = function signPropagatingRightShift(matrix, value) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.signPropagatingRightShift(value);
      };
      AbstractMatrix2.prototype.rightShift = function rightShift(value) {
        if (typeof value === "number")
          return this.rightShiftS(value);
        return this.rightShiftM(value);
      };
      AbstractMatrix2.prototype.rightShiftS = function rightShiftS(value) {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) >>> value);
          }
        }
        return this;
      };
      AbstractMatrix2.prototype.rightShiftM = function rightShiftM(matrix) {
        matrix = Matrix2.checkMatrix(matrix);
        if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) >>> matrix.get(i, j));
          }
        }
        return this;
      };
      AbstractMatrix2.rightShift = function rightShift(matrix, value) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.rightShift(value);
      };
      AbstractMatrix2.prototype.zeroFillRightShift = AbstractMatrix2.prototype.rightShift;
      AbstractMatrix2.prototype.zeroFillRightShiftS = AbstractMatrix2.prototype.rightShiftS;
      AbstractMatrix2.prototype.zeroFillRightShiftM = AbstractMatrix2.prototype.rightShiftM;
      AbstractMatrix2.zeroFillRightShift = AbstractMatrix2.rightShift;
      AbstractMatrix2.prototype.not = function not() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, ~this.get(i, j));
          }
        }
        return this;
      };
      AbstractMatrix2.not = function not(matrix) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.not();
      };
      AbstractMatrix2.prototype.abs = function abs() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.abs(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix2.abs = function abs(matrix) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.abs();
      };
      AbstractMatrix2.prototype.acos = function acos() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.acos(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix2.acos = function acos(matrix) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.acos();
      };
      AbstractMatrix2.prototype.acosh = function acosh() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.acosh(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix2.acosh = function acosh(matrix) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.acosh();
      };
      AbstractMatrix2.prototype.asin = function asin() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.asin(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix2.asin = function asin(matrix) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.asin();
      };
      AbstractMatrix2.prototype.asinh = function asinh() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.asinh(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix2.asinh = function asinh(matrix) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.asinh();
      };
      AbstractMatrix2.prototype.atan = function atan() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.atan(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix2.atan = function atan(matrix) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.atan();
      };
      AbstractMatrix2.prototype.atanh = function atanh() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.atanh(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix2.atanh = function atanh(matrix) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.atanh();
      };
      AbstractMatrix2.prototype.cbrt = function cbrt() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.cbrt(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix2.cbrt = function cbrt(matrix) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.cbrt();
      };
      AbstractMatrix2.prototype.ceil = function ceil() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.ceil(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix2.ceil = function ceil(matrix) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.ceil();
      };
      AbstractMatrix2.prototype.clz32 = function clz32() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.clz32(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix2.clz32 = function clz32(matrix) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.clz32();
      };
      AbstractMatrix2.prototype.cos = function cos() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.cos(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix2.cos = function cos(matrix) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.cos();
      };
      AbstractMatrix2.prototype.cosh = function cosh() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.cosh(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix2.cosh = function cosh(matrix) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.cosh();
      };
      AbstractMatrix2.prototype.exp = function exp() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.exp(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix2.exp = function exp(matrix) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.exp();
      };
      AbstractMatrix2.prototype.expm1 = function expm1() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.expm1(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix2.expm1 = function expm1(matrix) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.expm1();
      };
      AbstractMatrix2.prototype.floor = function floor() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.floor(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix2.floor = function floor(matrix) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.floor();
      };
      AbstractMatrix2.prototype.fround = function fround() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.fround(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix2.fround = function fround(matrix) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.fround();
      };
      AbstractMatrix2.prototype.log = function log() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.log(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix2.log = function log(matrix) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.log();
      };
      AbstractMatrix2.prototype.log1p = function log1p() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.log1p(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix2.log1p = function log1p(matrix) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.log1p();
      };
      AbstractMatrix2.prototype.log10 = function log10() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.log10(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix2.log10 = function log10(matrix) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.log10();
      };
      AbstractMatrix2.prototype.log2 = function log2() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.log2(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix2.log2 = function log2(matrix) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.log2();
      };
      AbstractMatrix2.prototype.round = function round() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.round(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix2.round = function round(matrix) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.round();
      };
      AbstractMatrix2.prototype.sign = function sign() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.sign(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix2.sign = function sign(matrix) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.sign();
      };
      AbstractMatrix2.prototype.sin = function sin() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.sin(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix2.sin = function sin(matrix) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.sin();
      };
      AbstractMatrix2.prototype.sinh = function sinh() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.sinh(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix2.sinh = function sinh(matrix) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.sinh();
      };
      AbstractMatrix2.prototype.sqrt = function sqrt() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.sqrt(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix2.sqrt = function sqrt(matrix) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.sqrt();
      };
      AbstractMatrix2.prototype.tan = function tan() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.tan(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix2.tan = function tan(matrix) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.tan();
      };
      AbstractMatrix2.prototype.tanh = function tanh() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.tanh(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix2.tanh = function tanh(matrix) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.tanh();
      };
      AbstractMatrix2.prototype.trunc = function trunc() {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.trunc(this.get(i, j)));
          }
        }
        return this;
      };
      AbstractMatrix2.trunc = function trunc(matrix) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.trunc();
      };
      AbstractMatrix2.pow = function pow(matrix, arg0) {
        const newMatrix = new Matrix2(matrix);
        return newMatrix.pow(arg0);
      };
      AbstractMatrix2.prototype.pow = function pow(value) {
        if (typeof value === "number")
          return this.powS(value);
        return this.powM(value);
      };
      AbstractMatrix2.prototype.powS = function powS(value) {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.pow(this.get(i, j), value));
          }
        }
        return this;
      };
      AbstractMatrix2.prototype.powM = function powM(matrix) {
        matrix = Matrix2.checkMatrix(matrix);
        if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
          throw new RangeError("Matrices dimensions must be equal");
        }
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, Math.pow(this.get(i, j), matrix.get(i, j)));
          }
        }
        return this;
      };
    }
    function checkRowIndex(matrix, index, outer) {
      let max = outer ? matrix.rows : matrix.rows - 1;
      if (index < 0 || index > max) {
        throw new RangeError("Row index out of range");
      }
    }
    function checkColumnIndex(matrix, index, outer) {
      let max = outer ? matrix.columns : matrix.columns - 1;
      if (index < 0 || index > max) {
        throw new RangeError("Column index out of range");
      }
    }
    function checkRowVector(matrix, vector) {
      if (vector.to1DArray) {
        vector = vector.to1DArray();
      }
      if (vector.length !== matrix.columns) {
        throw new RangeError(
          "vector size must be the same as the number of columns"
        );
      }
      return vector;
    }
    function checkColumnVector(matrix, vector) {
      if (vector.to1DArray) {
        vector = vector.to1DArray();
      }
      if (vector.length !== matrix.rows) {
        throw new RangeError("vector size must be the same as the number of rows");
      }
      return vector;
    }
    function checkRowIndices(matrix, rowIndices) {
      if (!isAnyArray.isAnyArray(rowIndices)) {
        throw new TypeError("row indices must be an array");
      }
      for (let i = 0; i < rowIndices.length; i++) {
        if (rowIndices[i] < 0 || rowIndices[i] >= matrix.rows) {
          throw new RangeError("row indices are out of range");
        }
      }
    }
    function checkColumnIndices(matrix, columnIndices) {
      if (!isAnyArray.isAnyArray(columnIndices)) {
        throw new TypeError("column indices must be an array");
      }
      for (let i = 0; i < columnIndices.length; i++) {
        if (columnIndices[i] < 0 || columnIndices[i] >= matrix.columns) {
          throw new RangeError("column indices are out of range");
        }
      }
    }
    function checkRange(matrix, startRow, endRow, startColumn, endColumn) {
      if (arguments.length !== 5) {
        throw new RangeError("expected 4 arguments");
      }
      checkNumber("startRow", startRow);
      checkNumber("endRow", endRow);
      checkNumber("startColumn", startColumn);
      checkNumber("endColumn", endColumn);
      if (startRow > endRow || startColumn > endColumn || startRow < 0 || startRow >= matrix.rows || endRow < 0 || endRow >= matrix.rows || startColumn < 0 || startColumn >= matrix.columns || endColumn < 0 || endColumn >= matrix.columns) {
        throw new RangeError("Submatrix indices are out of range");
      }
    }
    function newArray(length, value = 0) {
      let array = [];
      for (let i = 0; i < length; i++) {
        array.push(value);
      }
      return array;
    }
    function checkNumber(name, value) {
      if (typeof value !== "number") {
        throw new TypeError(`${name} must be a number`);
      }
    }
    function checkNonEmpty(matrix) {
      if (matrix.isEmpty()) {
        throw new Error("Empty matrix has no elements to index");
      }
    }
    function sumByRow(matrix) {
      let sum = newArray(matrix.rows);
      for (let i = 0; i < matrix.rows; ++i) {
        for (let j = 0; j < matrix.columns; ++j) {
          sum[i] += matrix.get(i, j);
        }
      }
      return sum;
    }
    function sumByColumn(matrix) {
      let sum = newArray(matrix.columns);
      for (let i = 0; i < matrix.rows; ++i) {
        for (let j = 0; j < matrix.columns; ++j) {
          sum[j] += matrix.get(i, j);
        }
      }
      return sum;
    }
    function sumAll(matrix) {
      let v = 0;
      for (let i = 0; i < matrix.rows; i++) {
        for (let j = 0; j < matrix.columns; j++) {
          v += matrix.get(i, j);
        }
      }
      return v;
    }
    function productByRow(matrix) {
      let sum = newArray(matrix.rows, 1);
      for (let i = 0; i < matrix.rows; ++i) {
        for (let j = 0; j < matrix.columns; ++j) {
          sum[i] *= matrix.get(i, j);
        }
      }
      return sum;
    }
    function productByColumn(matrix) {
      let sum = newArray(matrix.columns, 1);
      for (let i = 0; i < matrix.rows; ++i) {
        for (let j = 0; j < matrix.columns; ++j) {
          sum[j] *= matrix.get(i, j);
        }
      }
      return sum;
    }
    function productAll(matrix) {
      let v = 1;
      for (let i = 0; i < matrix.rows; i++) {
        for (let j = 0; j < matrix.columns; j++) {
          v *= matrix.get(i, j);
        }
      }
      return v;
    }
    function varianceByRow(matrix, unbiased, mean) {
      const rows = matrix.rows;
      const cols = matrix.columns;
      const variance = [];
      for (let i = 0; i < rows; i++) {
        let sum1 = 0;
        let sum2 = 0;
        let x = 0;
        for (let j = 0; j < cols; j++) {
          x = matrix.get(i, j) - mean[i];
          sum1 += x;
          sum2 += x * x;
        }
        if (unbiased) {
          variance.push((sum2 - sum1 * sum1 / cols) / (cols - 1));
        } else {
          variance.push((sum2 - sum1 * sum1 / cols) / cols);
        }
      }
      return variance;
    }
    function varianceByColumn(matrix, unbiased, mean) {
      const rows = matrix.rows;
      const cols = matrix.columns;
      const variance = [];
      for (let j = 0; j < cols; j++) {
        let sum1 = 0;
        let sum2 = 0;
        let x = 0;
        for (let i = 0; i < rows; i++) {
          x = matrix.get(i, j) - mean[j];
          sum1 += x;
          sum2 += x * x;
        }
        if (unbiased) {
          variance.push((sum2 - sum1 * sum1 / rows) / (rows - 1));
        } else {
          variance.push((sum2 - sum1 * sum1 / rows) / rows);
        }
      }
      return variance;
    }
    function varianceAll(matrix, unbiased, mean) {
      const rows = matrix.rows;
      const cols = matrix.columns;
      const size = rows * cols;
      let sum1 = 0;
      let sum2 = 0;
      let x = 0;
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          x = matrix.get(i, j) - mean;
          sum1 += x;
          sum2 += x * x;
        }
      }
      if (unbiased) {
        return (sum2 - sum1 * sum1 / size) / (size - 1);
      } else {
        return (sum2 - sum1 * sum1 / size) / size;
      }
    }
    function centerByRow(matrix, mean) {
      for (let i = 0; i < matrix.rows; i++) {
        for (let j = 0; j < matrix.columns; j++) {
          matrix.set(i, j, matrix.get(i, j) - mean[i]);
        }
      }
    }
    function centerByColumn(matrix, mean) {
      for (let i = 0; i < matrix.rows; i++) {
        for (let j = 0; j < matrix.columns; j++) {
          matrix.set(i, j, matrix.get(i, j) - mean[j]);
        }
      }
    }
    function centerAll(matrix, mean) {
      for (let i = 0; i < matrix.rows; i++) {
        for (let j = 0; j < matrix.columns; j++) {
          matrix.set(i, j, matrix.get(i, j) - mean);
        }
      }
    }
    function getScaleByRow(matrix) {
      const scale = [];
      for (let i = 0; i < matrix.rows; i++) {
        let sum = 0;
        for (let j = 0; j < matrix.columns; j++) {
          sum += Math.pow(matrix.get(i, j), 2) / (matrix.columns - 1);
        }
        scale.push(Math.sqrt(sum));
      }
      return scale;
    }
    function scaleByRow(matrix, scale) {
      for (let i = 0; i < matrix.rows; i++) {
        for (let j = 0; j < matrix.columns; j++) {
          matrix.set(i, j, matrix.get(i, j) / scale[i]);
        }
      }
    }
    function getScaleByColumn(matrix) {
      const scale = [];
      for (let j = 0; j < matrix.columns; j++) {
        let sum = 0;
        for (let i = 0; i < matrix.rows; i++) {
          sum += Math.pow(matrix.get(i, j), 2) / (matrix.rows - 1);
        }
        scale.push(Math.sqrt(sum));
      }
      return scale;
    }
    function scaleByColumn(matrix, scale) {
      for (let i = 0; i < matrix.rows; i++) {
        for (let j = 0; j < matrix.columns; j++) {
          matrix.set(i, j, matrix.get(i, j) / scale[j]);
        }
      }
    }
    function getScaleAll(matrix) {
      const divider = matrix.size - 1;
      let sum = 0;
      for (let j = 0; j < matrix.columns; j++) {
        for (let i = 0; i < matrix.rows; i++) {
          sum += Math.pow(matrix.get(i, j), 2) / divider;
        }
      }
      return Math.sqrt(sum);
    }
    function scaleAll(matrix, scale) {
      for (let i = 0; i < matrix.rows; i++) {
        for (let j = 0; j < matrix.columns; j++) {
          matrix.set(i, j, matrix.get(i, j) / scale);
        }
      }
    }
    var AbstractMatrix = class {
      static from1DArray(newRows, newColumns, newData) {
        let length = newRows * newColumns;
        if (length !== newData.length) {
          throw new RangeError("data length does not match given dimensions");
        }
        let newMatrix = new Matrix(newRows, newColumns);
        for (let row = 0; row < newRows; row++) {
          for (let column = 0; column < newColumns; column++) {
            newMatrix.set(row, column, newData[row * newColumns + column]);
          }
        }
        return newMatrix;
      }
      static rowVector(newData) {
        let vector = new Matrix(1, newData.length);
        for (let i = 0; i < newData.length; i++) {
          vector.set(0, i, newData[i]);
        }
        return vector;
      }
      static columnVector(newData) {
        let vector = new Matrix(newData.length, 1);
        for (let i = 0; i < newData.length; i++) {
          vector.set(i, 0, newData[i]);
        }
        return vector;
      }
      static zeros(rows, columns) {
        return new Matrix(rows, columns);
      }
      static ones(rows, columns) {
        return new Matrix(rows, columns).fill(1);
      }
      static rand(rows, columns, options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { random = Math.random } = options;
        let matrix = new Matrix(rows, columns);
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < columns; j++) {
            matrix.set(i, j, random());
          }
        }
        return matrix;
      }
      static randInt(rows, columns, options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { min = 0, max = 1e3, random = Math.random } = options;
        if (!Number.isInteger(min))
          throw new TypeError("min must be an integer");
        if (!Number.isInteger(max))
          throw new TypeError("max must be an integer");
        if (min >= max)
          throw new RangeError("min must be smaller than max");
        let interval = max - min;
        let matrix = new Matrix(rows, columns);
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < columns; j++) {
            let value = min + Math.round(random() * interval);
            matrix.set(i, j, value);
          }
        }
        return matrix;
      }
      static eye(rows, columns, value) {
        if (columns === void 0)
          columns = rows;
        if (value === void 0)
          value = 1;
        let min = Math.min(rows, columns);
        let matrix = this.zeros(rows, columns);
        for (let i = 0; i < min; i++) {
          matrix.set(i, i, value);
        }
        return matrix;
      }
      static diag(data, rows, columns) {
        let l = data.length;
        if (rows === void 0)
          rows = l;
        if (columns === void 0)
          columns = rows;
        let min = Math.min(l, rows, columns);
        let matrix = this.zeros(rows, columns);
        for (let i = 0; i < min; i++) {
          matrix.set(i, i, data[i]);
        }
        return matrix;
      }
      static min(matrix1, matrix2) {
        matrix1 = this.checkMatrix(matrix1);
        matrix2 = this.checkMatrix(matrix2);
        let rows = matrix1.rows;
        let columns = matrix1.columns;
        let result = new Matrix(rows, columns);
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < columns; j++) {
            result.set(i, j, Math.min(matrix1.get(i, j), matrix2.get(i, j)));
          }
        }
        return result;
      }
      static max(matrix1, matrix2) {
        matrix1 = this.checkMatrix(matrix1);
        matrix2 = this.checkMatrix(matrix2);
        let rows = matrix1.rows;
        let columns = matrix1.columns;
        let result = new this(rows, columns);
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < columns; j++) {
            result.set(i, j, Math.max(matrix1.get(i, j), matrix2.get(i, j)));
          }
        }
        return result;
      }
      static checkMatrix(value) {
        return AbstractMatrix.isMatrix(value) ? value : new Matrix(value);
      }
      static isMatrix(value) {
        return value != null && value.klass === "Matrix";
      }
      get size() {
        return this.rows * this.columns;
      }
      apply(callback) {
        if (typeof callback !== "function") {
          throw new TypeError("callback must be a function");
        }
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            callback.call(this, i, j);
          }
        }
        return this;
      }
      to1DArray() {
        let array = [];
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            array.push(this.get(i, j));
          }
        }
        return array;
      }
      to2DArray() {
        let copy = [];
        for (let i = 0; i < this.rows; i++) {
          copy.push([]);
          for (let j = 0; j < this.columns; j++) {
            copy[i].push(this.get(i, j));
          }
        }
        return copy;
      }
      toJSON() {
        return this.to2DArray();
      }
      isRowVector() {
        return this.rows === 1;
      }
      isColumnVector() {
        return this.columns === 1;
      }
      isVector() {
        return this.rows === 1 || this.columns === 1;
      }
      isSquare() {
        return this.rows === this.columns;
      }
      isEmpty() {
        return this.rows === 0 || this.columns === 0;
      }
      isSymmetric() {
        if (this.isSquare()) {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j <= i; j++) {
              if (this.get(i, j) !== this.get(j, i)) {
                return false;
              }
            }
          }
          return true;
        }
        return false;
      }
      isDistance() {
        if (!this.isSymmetric())
          return false;
        for (let i = 0; i < this.rows; i++) {
          if (this.get(i, i) !== 0)
            return false;
        }
        return true;
      }
      isEchelonForm() {
        let i = 0;
        let j = 0;
        let previousColumn = -1;
        let isEchelonForm = true;
        let checked = false;
        while (i < this.rows && isEchelonForm) {
          j = 0;
          checked = false;
          while (j < this.columns && checked === false) {
            if (this.get(i, j) === 0) {
              j++;
            } else if (this.get(i, j) === 1 && j > previousColumn) {
              checked = true;
              previousColumn = j;
            } else {
              isEchelonForm = false;
              checked = true;
            }
          }
          i++;
        }
        return isEchelonForm;
      }
      isReducedEchelonForm() {
        let i = 0;
        let j = 0;
        let previousColumn = -1;
        let isReducedEchelonForm = true;
        let checked = false;
        while (i < this.rows && isReducedEchelonForm) {
          j = 0;
          checked = false;
          while (j < this.columns && checked === false) {
            if (this.get(i, j) === 0) {
              j++;
            } else if (this.get(i, j) === 1 && j > previousColumn) {
              checked = true;
              previousColumn = j;
            } else {
              isReducedEchelonForm = false;
              checked = true;
            }
          }
          for (let k = j + 1; k < this.rows; k++) {
            if (this.get(i, k) !== 0) {
              isReducedEchelonForm = false;
            }
          }
          i++;
        }
        return isReducedEchelonForm;
      }
      echelonForm() {
        let result = this.clone();
        let h = 0;
        let k = 0;
        while (h < result.rows && k < result.columns) {
          let iMax = h;
          for (let i = h; i < result.rows; i++) {
            if (result.get(i, k) > result.get(iMax, k)) {
              iMax = i;
            }
          }
          if (result.get(iMax, k) === 0) {
            k++;
          } else {
            result.swapRows(h, iMax);
            let tmp = result.get(h, k);
            for (let j = k; j < result.columns; j++) {
              result.set(h, j, result.get(h, j) / tmp);
            }
            for (let i = h + 1; i < result.rows; i++) {
              let factor = result.get(i, k) / result.get(h, k);
              result.set(i, k, 0);
              for (let j = k + 1; j < result.columns; j++) {
                result.set(i, j, result.get(i, j) - result.get(h, j) * factor);
              }
            }
            h++;
            k++;
          }
        }
        return result;
      }
      reducedEchelonForm() {
        let result = this.echelonForm();
        let m = result.columns;
        let n = result.rows;
        let h = n - 1;
        while (h >= 0) {
          if (result.maxRow(h) === 0) {
            h--;
          } else {
            let p = 0;
            let pivot = false;
            while (p < n && pivot === false) {
              if (result.get(h, p) === 1) {
                pivot = true;
              } else {
                p++;
              }
            }
            for (let i = 0; i < h; i++) {
              let factor = result.get(i, p);
              for (let j = p; j < m; j++) {
                let tmp = result.get(i, j) - factor * result.get(h, j);
                result.set(i, j, tmp);
              }
            }
            h--;
          }
        }
        return result;
      }
      set() {
        throw new Error("set method is unimplemented");
      }
      get() {
        throw new Error("get method is unimplemented");
      }
      repeat(options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { rows = 1, columns = 1 } = options;
        if (!Number.isInteger(rows) || rows <= 0) {
          throw new TypeError("rows must be a positive integer");
        }
        if (!Number.isInteger(columns) || columns <= 0) {
          throw new TypeError("columns must be a positive integer");
        }
        let matrix = new Matrix(this.rows * rows, this.columns * columns);
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < columns; j++) {
            matrix.setSubMatrix(this, this.rows * i, this.columns * j);
          }
        }
        return matrix;
      }
      fill(value) {
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, value);
          }
        }
        return this;
      }
      neg() {
        return this.mulS(-1);
      }
      getRow(index) {
        checkRowIndex(this, index);
        let row = [];
        for (let i = 0; i < this.columns; i++) {
          row.push(this.get(index, i));
        }
        return row;
      }
      getRowVector(index) {
        return Matrix.rowVector(this.getRow(index));
      }
      setRow(index, array) {
        checkRowIndex(this, index);
        array = checkRowVector(this, array);
        for (let i = 0; i < this.columns; i++) {
          this.set(index, i, array[i]);
        }
        return this;
      }
      swapRows(row1, row2) {
        checkRowIndex(this, row1);
        checkRowIndex(this, row2);
        for (let i = 0; i < this.columns; i++) {
          let temp = this.get(row1, i);
          this.set(row1, i, this.get(row2, i));
          this.set(row2, i, temp);
        }
        return this;
      }
      getColumn(index) {
        checkColumnIndex(this, index);
        let column = [];
        for (let i = 0; i < this.rows; i++) {
          column.push(this.get(i, index));
        }
        return column;
      }
      getColumnVector(index) {
        return Matrix.columnVector(this.getColumn(index));
      }
      setColumn(index, array) {
        checkColumnIndex(this, index);
        array = checkColumnVector(this, array);
        for (let i = 0; i < this.rows; i++) {
          this.set(i, index, array[i]);
        }
        return this;
      }
      swapColumns(column1, column2) {
        checkColumnIndex(this, column1);
        checkColumnIndex(this, column2);
        for (let i = 0; i < this.rows; i++) {
          let temp = this.get(i, column1);
          this.set(i, column1, this.get(i, column2));
          this.set(i, column2, temp);
        }
        return this;
      }
      addRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) + vector[j]);
          }
        }
        return this;
      }
      subRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) - vector[j]);
          }
        }
        return this;
      }
      mulRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) * vector[j]);
          }
        }
        return this;
      }
      divRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) / vector[j]);
          }
        }
        return this;
      }
      addColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) + vector[i]);
          }
        }
        return this;
      }
      subColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) - vector[i]);
          }
        }
        return this;
      }
      mulColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) * vector[i]);
          }
        }
        return this;
      }
      divColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) / vector[i]);
          }
        }
        return this;
      }
      mulRow(index, value) {
        checkRowIndex(this, index);
        for (let i = 0; i < this.columns; i++) {
          this.set(index, i, this.get(index, i) * value);
        }
        return this;
      }
      mulColumn(index, value) {
        checkColumnIndex(this, index);
        for (let i = 0; i < this.rows; i++) {
          this.set(i, index, this.get(i, index) * value);
        }
        return this;
      }
      max(by) {
        if (this.isEmpty()) {
          return NaN;
        }
        switch (by) {
          case "row": {
            const max = new Array(this.rows).fill(Number.NEGATIVE_INFINITY);
            for (let row = 0; row < this.rows; row++) {
              for (let column = 0; column < this.columns; column++) {
                if (this.get(row, column) > max[row]) {
                  max[row] = this.get(row, column);
                }
              }
            }
            return max;
          }
          case "column": {
            const max = new Array(this.columns).fill(Number.NEGATIVE_INFINITY);
            for (let row = 0; row < this.rows; row++) {
              for (let column = 0; column < this.columns; column++) {
                if (this.get(row, column) > max[column]) {
                  max[column] = this.get(row, column);
                }
              }
            }
            return max;
          }
          case void 0: {
            let max = this.get(0, 0);
            for (let row = 0; row < this.rows; row++) {
              for (let column = 0; column < this.columns; column++) {
                if (this.get(row, column) > max) {
                  max = this.get(row, column);
                }
              }
            }
            return max;
          }
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      maxIndex() {
        checkNonEmpty(this);
        let v = this.get(0, 0);
        let idx = [0, 0];
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            if (this.get(i, j) > v) {
              v = this.get(i, j);
              idx[0] = i;
              idx[1] = j;
            }
          }
        }
        return idx;
      }
      min(by) {
        if (this.isEmpty()) {
          return NaN;
        }
        switch (by) {
          case "row": {
            const min = new Array(this.rows).fill(Number.POSITIVE_INFINITY);
            for (let row = 0; row < this.rows; row++) {
              for (let column = 0; column < this.columns; column++) {
                if (this.get(row, column) < min[row]) {
                  min[row] = this.get(row, column);
                }
              }
            }
            return min;
          }
          case "column": {
            const min = new Array(this.columns).fill(Number.POSITIVE_INFINITY);
            for (let row = 0; row < this.rows; row++) {
              for (let column = 0; column < this.columns; column++) {
                if (this.get(row, column) < min[column]) {
                  min[column] = this.get(row, column);
                }
              }
            }
            return min;
          }
          case void 0: {
            let min = this.get(0, 0);
            for (let row = 0; row < this.rows; row++) {
              for (let column = 0; column < this.columns; column++) {
                if (this.get(row, column) < min) {
                  min = this.get(row, column);
                }
              }
            }
            return min;
          }
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      minIndex() {
        checkNonEmpty(this);
        let v = this.get(0, 0);
        let idx = [0, 0];
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            if (this.get(i, j) < v) {
              v = this.get(i, j);
              idx[0] = i;
              idx[1] = j;
            }
          }
        }
        return idx;
      }
      maxRow(row) {
        checkRowIndex(this, row);
        if (this.isEmpty()) {
          return NaN;
        }
        let v = this.get(row, 0);
        for (let i = 1; i < this.columns; i++) {
          if (this.get(row, i) > v) {
            v = this.get(row, i);
          }
        }
        return v;
      }
      maxRowIndex(row) {
        checkRowIndex(this, row);
        checkNonEmpty(this);
        let v = this.get(row, 0);
        let idx = [row, 0];
        for (let i = 1; i < this.columns; i++) {
          if (this.get(row, i) > v) {
            v = this.get(row, i);
            idx[1] = i;
          }
        }
        return idx;
      }
      minRow(row) {
        checkRowIndex(this, row);
        if (this.isEmpty()) {
          return NaN;
        }
        let v = this.get(row, 0);
        for (let i = 1; i < this.columns; i++) {
          if (this.get(row, i) < v) {
            v = this.get(row, i);
          }
        }
        return v;
      }
      minRowIndex(row) {
        checkRowIndex(this, row);
        checkNonEmpty(this);
        let v = this.get(row, 0);
        let idx = [row, 0];
        for (let i = 1; i < this.columns; i++) {
          if (this.get(row, i) < v) {
            v = this.get(row, i);
            idx[1] = i;
          }
        }
        return idx;
      }
      maxColumn(column) {
        checkColumnIndex(this, column);
        if (this.isEmpty()) {
          return NaN;
        }
        let v = this.get(0, column);
        for (let i = 1; i < this.rows; i++) {
          if (this.get(i, column) > v) {
            v = this.get(i, column);
          }
        }
        return v;
      }
      maxColumnIndex(column) {
        checkColumnIndex(this, column);
        checkNonEmpty(this);
        let v = this.get(0, column);
        let idx = [0, column];
        for (let i = 1; i < this.rows; i++) {
          if (this.get(i, column) > v) {
            v = this.get(i, column);
            idx[0] = i;
          }
        }
        return idx;
      }
      minColumn(column) {
        checkColumnIndex(this, column);
        if (this.isEmpty()) {
          return NaN;
        }
        let v = this.get(0, column);
        for (let i = 1; i < this.rows; i++) {
          if (this.get(i, column) < v) {
            v = this.get(i, column);
          }
        }
        return v;
      }
      minColumnIndex(column) {
        checkColumnIndex(this, column);
        checkNonEmpty(this);
        let v = this.get(0, column);
        let idx = [0, column];
        for (let i = 1; i < this.rows; i++) {
          if (this.get(i, column) < v) {
            v = this.get(i, column);
            idx[0] = i;
          }
        }
        return idx;
      }
      diag() {
        let min = Math.min(this.rows, this.columns);
        let diag = [];
        for (let i = 0; i < min; i++) {
          diag.push(this.get(i, i));
        }
        return diag;
      }
      norm(type = "frobenius") {
        switch (type) {
          case "max":
            return this.max();
          case "frobenius":
            return Math.sqrt(this.dot(this));
          default:
            throw new RangeError(`unknown norm type: ${type}`);
        }
      }
      cumulativeSum() {
        let sum = 0;
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            sum += this.get(i, j);
            this.set(i, j, sum);
          }
        }
        return this;
      }
      dot(vector2) {
        if (AbstractMatrix.isMatrix(vector2))
          vector2 = vector2.to1DArray();
        let vector1 = this.to1DArray();
        if (vector1.length !== vector2.length) {
          throw new RangeError("vectors do not have the same size");
        }
        let dot = 0;
        for (let i = 0; i < vector1.length; i++) {
          dot += vector1[i] * vector2[i];
        }
        return dot;
      }
      mmul(other) {
        other = Matrix.checkMatrix(other);
        let m = this.rows;
        let n = this.columns;
        let p = other.columns;
        let result = new Matrix(m, p);
        let Bcolj = new Float64Array(n);
        for (let j = 0; j < p; j++) {
          for (let k = 0; k < n; k++) {
            Bcolj[k] = other.get(k, j);
          }
          for (let i = 0; i < m; i++) {
            let s = 0;
            for (let k = 0; k < n; k++) {
              s += this.get(i, k) * Bcolj[k];
            }
            result.set(i, j, s);
          }
        }
        return result;
      }
      strassen2x2(other) {
        other = Matrix.checkMatrix(other);
        let result = new Matrix(2, 2);
        const a11 = this.get(0, 0);
        const b11 = other.get(0, 0);
        const a12 = this.get(0, 1);
        const b12 = other.get(0, 1);
        const a21 = this.get(1, 0);
        const b21 = other.get(1, 0);
        const a22 = this.get(1, 1);
        const b22 = other.get(1, 1);
        const m1 = (a11 + a22) * (b11 + b22);
        const m2 = (a21 + a22) * b11;
        const m3 = a11 * (b12 - b22);
        const m4 = a22 * (b21 - b11);
        const m5 = (a11 + a12) * b22;
        const m6 = (a21 - a11) * (b11 + b12);
        const m7 = (a12 - a22) * (b21 + b22);
        const c00 = m1 + m4 - m5 + m7;
        const c01 = m3 + m5;
        const c10 = m2 + m4;
        const c11 = m1 - m2 + m3 + m6;
        result.set(0, 0, c00);
        result.set(0, 1, c01);
        result.set(1, 0, c10);
        result.set(1, 1, c11);
        return result;
      }
      strassen3x3(other) {
        other = Matrix.checkMatrix(other);
        let result = new Matrix(3, 3);
        const a00 = this.get(0, 0);
        const a01 = this.get(0, 1);
        const a02 = this.get(0, 2);
        const a10 = this.get(1, 0);
        const a11 = this.get(1, 1);
        const a12 = this.get(1, 2);
        const a20 = this.get(2, 0);
        const a21 = this.get(2, 1);
        const a22 = this.get(2, 2);
        const b00 = other.get(0, 0);
        const b01 = other.get(0, 1);
        const b02 = other.get(0, 2);
        const b10 = other.get(1, 0);
        const b11 = other.get(1, 1);
        const b12 = other.get(1, 2);
        const b20 = other.get(2, 0);
        const b21 = other.get(2, 1);
        const b22 = other.get(2, 2);
        const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;
        const m2 = (a00 - a10) * (-b01 + b11);
        const m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);
        const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);
        const m5 = (a10 + a11) * (-b00 + b01);
        const m6 = a00 * b00;
        const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);
        const m8 = (-a00 + a20) * (b02 - b12);
        const m9 = (a20 + a21) * (-b00 + b02);
        const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;
        const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);
        const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);
        const m13 = (a02 - a22) * (b11 - b21);
        const m14 = a02 * b20;
        const m15 = (a21 + a22) * (-b20 + b21);
        const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);
        const m17 = (a02 - a12) * (b12 - b22);
        const m18 = (a11 + a12) * (-b20 + b22);
        const m19 = a01 * b10;
        const m20 = a12 * b21;
        const m21 = a10 * b02;
        const m22 = a20 * b01;
        const m23 = a22 * b22;
        const c00 = m6 + m14 + m19;
        const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;
        const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;
        const c10 = m2 + m3 + m4 + m6 + m14 + m16 + m17;
        const c11 = m2 + m4 + m5 + m6 + m20;
        const c12 = m14 + m16 + m17 + m18 + m21;
        const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;
        const c21 = m12 + m13 + m14 + m15 + m22;
        const c22 = m6 + m7 + m8 + m9 + m23;
        result.set(0, 0, c00);
        result.set(0, 1, c01);
        result.set(0, 2, c02);
        result.set(1, 0, c10);
        result.set(1, 1, c11);
        result.set(1, 2, c12);
        result.set(2, 0, c20);
        result.set(2, 1, c21);
        result.set(2, 2, c22);
        return result;
      }
      mmulStrassen(y) {
        y = Matrix.checkMatrix(y);
        let x = this.clone();
        let r1 = x.rows;
        let c1 = x.columns;
        let r2 = y.rows;
        let c2 = y.columns;
        if (c1 !== r2) {
          console.warn(
            `Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`
          );
        }
        function embed(mat, rows, cols) {
          let r3 = mat.rows;
          let c3 = mat.columns;
          if (r3 === rows && c3 === cols) {
            return mat;
          } else {
            let resultat = AbstractMatrix.zeros(rows, cols);
            resultat = resultat.setSubMatrix(mat, 0, 0);
            return resultat;
          }
        }
        let r = Math.max(r1, r2);
        let c = Math.max(c1, c2);
        x = embed(x, r, c);
        y = embed(y, r, c);
        function blockMult(a, b, rows, cols) {
          if (rows <= 512 || cols <= 512) {
            return a.mmul(b);
          }
          if (rows % 2 === 1 && cols % 2 === 1) {
            a = embed(a, rows + 1, cols + 1);
            b = embed(b, rows + 1, cols + 1);
          } else if (rows % 2 === 1) {
            a = embed(a, rows + 1, cols);
            b = embed(b, rows + 1, cols);
          } else if (cols % 2 === 1) {
            a = embed(a, rows, cols + 1);
            b = embed(b, rows, cols + 1);
          }
          let halfRows = parseInt(a.rows / 2, 10);
          let halfCols = parseInt(a.columns / 2, 10);
          let a11 = a.subMatrix(0, halfRows - 1, 0, halfCols - 1);
          let b11 = b.subMatrix(0, halfRows - 1, 0, halfCols - 1);
          let a12 = a.subMatrix(0, halfRows - 1, halfCols, a.columns - 1);
          let b12 = b.subMatrix(0, halfRows - 1, halfCols, b.columns - 1);
          let a21 = a.subMatrix(halfRows, a.rows - 1, 0, halfCols - 1);
          let b21 = b.subMatrix(halfRows, b.rows - 1, 0, halfCols - 1);
          let a22 = a.subMatrix(halfRows, a.rows - 1, halfCols, a.columns - 1);
          let b22 = b.subMatrix(halfRows, b.rows - 1, halfCols, b.columns - 1);
          let m1 = blockMult(
            AbstractMatrix.add(a11, a22),
            AbstractMatrix.add(b11, b22),
            halfRows,
            halfCols
          );
          let m2 = blockMult(AbstractMatrix.add(a21, a22), b11, halfRows, halfCols);
          let m3 = blockMult(a11, AbstractMatrix.sub(b12, b22), halfRows, halfCols);
          let m4 = blockMult(a22, AbstractMatrix.sub(b21, b11), halfRows, halfCols);
          let m5 = blockMult(AbstractMatrix.add(a11, a12), b22, halfRows, halfCols);
          let m6 = blockMult(
            AbstractMatrix.sub(a21, a11),
            AbstractMatrix.add(b11, b12),
            halfRows,
            halfCols
          );
          let m7 = blockMult(
            AbstractMatrix.sub(a12, a22),
            AbstractMatrix.add(b21, b22),
            halfRows,
            halfCols
          );
          let c11 = AbstractMatrix.add(m1, m4);
          c11.sub(m5);
          c11.add(m7);
          let c12 = AbstractMatrix.add(m3, m5);
          let c21 = AbstractMatrix.add(m2, m4);
          let c22 = AbstractMatrix.sub(m1, m2);
          c22.add(m3);
          c22.add(m6);
          let result = AbstractMatrix.zeros(2 * c11.rows, 2 * c11.columns);
          result = result.setSubMatrix(c11, 0, 0);
          result = result.setSubMatrix(c12, c11.rows, 0);
          result = result.setSubMatrix(c21, 0, c11.columns);
          result = result.setSubMatrix(c22, c11.rows, c11.columns);
          return result.subMatrix(0, rows - 1, 0, cols - 1);
        }
        return blockMult(x, y, r, c);
      }
      scaleRows(options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { min = 0, max = 1 } = options;
        if (!Number.isFinite(min))
          throw new TypeError("min must be a number");
        if (!Number.isFinite(max))
          throw new TypeError("max must be a number");
        if (min >= max)
          throw new RangeError("min must be smaller than max");
        let newMatrix = new Matrix(this.rows, this.columns);
        for (let i = 0; i < this.rows; i++) {
          const row = this.getRow(i);
          if (row.length > 0) {
            rescale(row, { min, max, output: row });
          }
          newMatrix.setRow(i, row);
        }
        return newMatrix;
      }
      scaleColumns(options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { min = 0, max = 1 } = options;
        if (!Number.isFinite(min))
          throw new TypeError("min must be a number");
        if (!Number.isFinite(max))
          throw new TypeError("max must be a number");
        if (min >= max)
          throw new RangeError("min must be smaller than max");
        let newMatrix = new Matrix(this.rows, this.columns);
        for (let i = 0; i < this.columns; i++) {
          const column = this.getColumn(i);
          if (column.length) {
            rescale(column, {
              min,
              max,
              output: column
            });
          }
          newMatrix.setColumn(i, column);
        }
        return newMatrix;
      }
      flipRows() {
        const middle = Math.ceil(this.columns / 2);
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < middle; j++) {
            let first = this.get(i, j);
            let last = this.get(i, this.columns - 1 - j);
            this.set(i, j, last);
            this.set(i, this.columns - 1 - j, first);
          }
        }
        return this;
      }
      flipColumns() {
        const middle = Math.ceil(this.rows / 2);
        for (let j = 0; j < this.columns; j++) {
          for (let i = 0; i < middle; i++) {
            let first = this.get(i, j);
            let last = this.get(this.rows - 1 - i, j);
            this.set(i, j, last);
            this.set(this.rows - 1 - i, j, first);
          }
        }
        return this;
      }
      kroneckerProduct(other) {
        other = Matrix.checkMatrix(other);
        let m = this.rows;
        let n = this.columns;
        let p = other.rows;
        let q = other.columns;
        let result = new Matrix(m * p, n * q);
        for (let i = 0; i < m; i++) {
          for (let j = 0; j < n; j++) {
            for (let k = 0; k < p; k++) {
              for (let l = 0; l < q; l++) {
                result.set(p * i + k, q * j + l, this.get(i, j) * other.get(k, l));
              }
            }
          }
        }
        return result;
      }
      kroneckerSum(other) {
        other = Matrix.checkMatrix(other);
        if (!this.isSquare() || !other.isSquare()) {
          throw new Error("Kronecker Sum needs two Square Matrices");
        }
        let m = this.rows;
        let n = other.rows;
        let AxI = this.kroneckerProduct(Matrix.eye(n, n));
        let IxB = Matrix.eye(m, m).kroneckerProduct(other);
        return AxI.add(IxB);
      }
      transpose() {
        let result = new Matrix(this.columns, this.rows);
        for (let i = 0; i < this.rows; i++) {
          for (let j = 0; j < this.columns; j++) {
            result.set(j, i, this.get(i, j));
          }
        }
        return result;
      }
      sortRows(compareFunction = compareNumbers) {
        for (let i = 0; i < this.rows; i++) {
          this.setRow(i, this.getRow(i).sort(compareFunction));
        }
        return this;
      }
      sortColumns(compareFunction = compareNumbers) {
        for (let i = 0; i < this.columns; i++) {
          this.setColumn(i, this.getColumn(i).sort(compareFunction));
        }
        return this;
      }
      subMatrix(startRow, endRow, startColumn, endColumn) {
        checkRange(this, startRow, endRow, startColumn, endColumn);
        let newMatrix = new Matrix(
          endRow - startRow + 1,
          endColumn - startColumn + 1
        );
        for (let i = startRow; i <= endRow; i++) {
          for (let j = startColumn; j <= endColumn; j++) {
            newMatrix.set(i - startRow, j - startColumn, this.get(i, j));
          }
        }
        return newMatrix;
      }
      subMatrixRow(indices, startColumn, endColumn) {
        if (startColumn === void 0)
          startColumn = 0;
        if (endColumn === void 0)
          endColumn = this.columns - 1;
        if (startColumn > endColumn || startColumn < 0 || startColumn >= this.columns || endColumn < 0 || endColumn >= this.columns) {
          throw new RangeError("Argument out of range");
        }
        let newMatrix = new Matrix(indices.length, endColumn - startColumn + 1);
        for (let i = 0; i < indices.length; i++) {
          for (let j = startColumn; j <= endColumn; j++) {
            if (indices[i] < 0 || indices[i] >= this.rows) {
              throw new RangeError(`Row index out of range: ${indices[i]}`);
            }
            newMatrix.set(i, j - startColumn, this.get(indices[i], j));
          }
        }
        return newMatrix;
      }
      subMatrixColumn(indices, startRow, endRow) {
        if (startRow === void 0)
          startRow = 0;
        if (endRow === void 0)
          endRow = this.rows - 1;
        if (startRow > endRow || startRow < 0 || startRow >= this.rows || endRow < 0 || endRow >= this.rows) {
          throw new RangeError("Argument out of range");
        }
        let newMatrix = new Matrix(endRow - startRow + 1, indices.length);
        for (let i = 0; i < indices.length; i++) {
          for (let j = startRow; j <= endRow; j++) {
            if (indices[i] < 0 || indices[i] >= this.columns) {
              throw new RangeError(`Column index out of range: ${indices[i]}`);
            }
            newMatrix.set(j - startRow, i, this.get(j, indices[i]));
          }
        }
        return newMatrix;
      }
      setSubMatrix(matrix, startRow, startColumn) {
        matrix = Matrix.checkMatrix(matrix);
        if (matrix.isEmpty()) {
          return this;
        }
        let endRow = startRow + matrix.rows - 1;
        let endColumn = startColumn + matrix.columns - 1;
        checkRange(this, startRow, endRow, startColumn, endColumn);
        for (let i = 0; i < matrix.rows; i++) {
          for (let j = 0; j < matrix.columns; j++) {
            this.set(startRow + i, startColumn + j, matrix.get(i, j));
          }
        }
        return this;
      }
      selection(rowIndices, columnIndices) {
        checkRowIndices(this, rowIndices);
        checkColumnIndices(this, columnIndices);
        let newMatrix = new Matrix(rowIndices.length, columnIndices.length);
        for (let i = 0; i < rowIndices.length; i++) {
          let rowIndex = rowIndices[i];
          for (let j = 0; j < columnIndices.length; j++) {
            let columnIndex = columnIndices[j];
            newMatrix.set(i, j, this.get(rowIndex, columnIndex));
          }
        }
        return newMatrix;
      }
      trace() {
        let min = Math.min(this.rows, this.columns);
        let trace = 0;
        for (let i = 0; i < min; i++) {
          trace += this.get(i, i);
        }
        return trace;
      }
      clone() {
        return this.constructor.copy(this, new Matrix(this.rows, this.columns));
      }
      /**
       * @template {AbstractMatrix} M
       * @param {AbstractMatrix} from
       * @param {M} to
       * @return {M}
       */
      static copy(from, to) {
        for (const [row, column, value] of from.entries()) {
          to.set(row, column, value);
        }
        return to;
      }
      sum(by) {
        switch (by) {
          case "row":
            return sumByRow(this);
          case "column":
            return sumByColumn(this);
          case void 0:
            return sumAll(this);
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      product(by) {
        switch (by) {
          case "row":
            return productByRow(this);
          case "column":
            return productByColumn(this);
          case void 0:
            return productAll(this);
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      mean(by) {
        const sum = this.sum(by);
        switch (by) {
          case "row": {
            for (let i = 0; i < this.rows; i++) {
              sum[i] /= this.columns;
            }
            return sum;
          }
          case "column": {
            for (let i = 0; i < this.columns; i++) {
              sum[i] /= this.rows;
            }
            return sum;
          }
          case void 0:
            return sum / this.size;
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      variance(by, options = {}) {
        if (typeof by === "object") {
          options = by;
          by = void 0;
        }
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { unbiased = true, mean = this.mean(by) } = options;
        if (typeof unbiased !== "boolean") {
          throw new TypeError("unbiased must be a boolean");
        }
        switch (by) {
          case "row": {
            if (!isAnyArray.isAnyArray(mean)) {
              throw new TypeError("mean must be an array");
            }
            return varianceByRow(this, unbiased, mean);
          }
          case "column": {
            if (!isAnyArray.isAnyArray(mean)) {
              throw new TypeError("mean must be an array");
            }
            return varianceByColumn(this, unbiased, mean);
          }
          case void 0: {
            if (typeof mean !== "number") {
              throw new TypeError("mean must be a number");
            }
            return varianceAll(this, unbiased, mean);
          }
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      standardDeviation(by, options) {
        if (typeof by === "object") {
          options = by;
          by = void 0;
        }
        const variance = this.variance(by, options);
        if (by === void 0) {
          return Math.sqrt(variance);
        } else {
          for (let i = 0; i < variance.length; i++) {
            variance[i] = Math.sqrt(variance[i]);
          }
          return variance;
        }
      }
      center(by, options = {}) {
        if (typeof by === "object") {
          options = by;
          by = void 0;
        }
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { center = this.mean(by) } = options;
        switch (by) {
          case "row": {
            if (!isAnyArray.isAnyArray(center)) {
              throw new TypeError("center must be an array");
            }
            centerByRow(this, center);
            return this;
          }
          case "column": {
            if (!isAnyArray.isAnyArray(center)) {
              throw new TypeError("center must be an array");
            }
            centerByColumn(this, center);
            return this;
          }
          case void 0: {
            if (typeof center !== "number") {
              throw new TypeError("center must be a number");
            }
            centerAll(this, center);
            return this;
          }
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      scale(by, options = {}) {
        if (typeof by === "object") {
          options = by;
          by = void 0;
        }
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        let scale = options.scale;
        switch (by) {
          case "row": {
            if (scale === void 0) {
              scale = getScaleByRow(this);
            } else if (!isAnyArray.isAnyArray(scale)) {
              throw new TypeError("scale must be an array");
            }
            scaleByRow(this, scale);
            return this;
          }
          case "column": {
            if (scale === void 0) {
              scale = getScaleByColumn(this);
            } else if (!isAnyArray.isAnyArray(scale)) {
              throw new TypeError("scale must be an array");
            }
            scaleByColumn(this, scale);
            return this;
          }
          case void 0: {
            if (scale === void 0) {
              scale = getScaleAll(this);
            } else if (typeof scale !== "number") {
              throw new TypeError("scale must be a number");
            }
            scaleAll(this, scale);
            return this;
          }
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      toString(options) {
        return inspectMatrixWithOptions(this, options);
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      /**
       * iterator from left to right, from top to bottom
       * yield [row, column, value]
       * @returns {Generator<[number, number, number], void, *>}
       */
      *entries() {
        for (let row = 0; row < this.rows; row++) {
          for (let col = 0; col < this.columns; col++) {
            yield [row, col, this.get(row, col)];
          }
        }
      }
      /**
       * iterator from left to right, from top to bottom
       * yield value
       * @returns {Generator<number, void, *>}
       */
      *values() {
        for (let row = 0; row < this.rows; row++) {
          for (let col = 0; col < this.columns; col++) {
            yield this.get(row, col);
          }
        }
      }
    };
    AbstractMatrix.prototype.klass = "Matrix";
    if (typeof Symbol !== "undefined") {
      AbstractMatrix.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspectMatrix;
    }
    function compareNumbers(a, b) {
      return a - b;
    }
    function isArrayOfNumbers(array) {
      return array.every((element) => {
        return typeof element === "number";
      });
    }
    AbstractMatrix.random = AbstractMatrix.rand;
    AbstractMatrix.randomInt = AbstractMatrix.randInt;
    AbstractMatrix.diagonal = AbstractMatrix.diag;
    AbstractMatrix.prototype.diagonal = AbstractMatrix.prototype.diag;
    AbstractMatrix.identity = AbstractMatrix.eye;
    AbstractMatrix.prototype.negate = AbstractMatrix.prototype.neg;
    AbstractMatrix.prototype.tensorProduct = AbstractMatrix.prototype.kroneckerProduct;
    var _initData, initData_fn;
    var _Matrix = class extends AbstractMatrix {
      constructor(nRows, nColumns) {
        super();
        /**
         * Init an empty matrix
         * @param {number} nRows
         * @param {number} nColumns
         */
        __privateAdd(this, _initData);
        /**
         * @type {Float64Array[]}
         */
        __publicField(this, "data");
        if (_Matrix.isMatrix(nRows)) {
          __privateMethod(this, _initData, initData_fn).call(this, nRows.rows, nRows.columns);
          _Matrix.copy(nRows, this);
        } else if (Number.isInteger(nRows) && nRows >= 0) {
          __privateMethod(this, _initData, initData_fn).call(this, nRows, nColumns);
        } else if (isAnyArray.isAnyArray(nRows)) {
          const arrayData = nRows;
          nRows = arrayData.length;
          nColumns = nRows ? arrayData[0].length : 0;
          if (typeof nColumns !== "number") {
            throw new TypeError(
              "Data must be a 2D array with at least one element"
            );
          }
          this.data = [];
          for (let i = 0; i < nRows; i++) {
            if (arrayData[i].length !== nColumns) {
              throw new RangeError("Inconsistent array dimensions");
            }
            if (!isArrayOfNumbers(arrayData[i])) {
              throw new TypeError("Input data contains non-numeric values");
            }
            this.data.push(Float64Array.from(arrayData[i]));
          }
          this.rows = nRows;
          this.columns = nColumns;
        } else {
          throw new TypeError(
            "First argument must be a positive number or an array"
          );
        }
      }
      set(rowIndex, columnIndex, value) {
        this.data[rowIndex][columnIndex] = value;
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.data[rowIndex][columnIndex];
      }
      removeRow(index) {
        checkRowIndex(this, index);
        this.data.splice(index, 1);
        this.rows -= 1;
        return this;
      }
      addRow(index, array) {
        if (array === void 0) {
          array = index;
          index = this.rows;
        }
        checkRowIndex(this, index, true);
        array = Float64Array.from(checkRowVector(this, array));
        this.data.splice(index, 0, array);
        this.rows += 1;
        return this;
      }
      removeColumn(index) {
        checkColumnIndex(this, index);
        for (let i = 0; i < this.rows; i++) {
          const newRow = new Float64Array(this.columns - 1);
          for (let j = 0; j < index; j++) {
            newRow[j] = this.data[i][j];
          }
          for (let j = index + 1; j < this.columns; j++) {
            newRow[j - 1] = this.data[i][j];
          }
          this.data[i] = newRow;
        }
        this.columns -= 1;
        return this;
      }
      addColumn(index, array) {
        if (typeof array === "undefined") {
          array = index;
          index = this.columns;
        }
        checkColumnIndex(this, index, true);
        array = checkColumnVector(this, array);
        for (let i = 0; i < this.rows; i++) {
          const newRow = new Float64Array(this.columns + 1);
          let j = 0;
          for (; j < index; j++) {
            newRow[j] = this.data[i][j];
          }
          newRow[j++] = array[i];
          for (; j < this.columns + 1; j++) {
            newRow[j] = this.data[i][j - 1];
          }
          this.data[i] = newRow;
        }
        this.columns += 1;
        return this;
      }
    };
    var Matrix = _Matrix;
    _initData = new WeakSet();
    initData_fn = function(nRows, nColumns) {
      this.data = [];
      if (Number.isInteger(nColumns) && nColumns >= 0) {
        for (let i = 0; i < nRows; i++) {
          this.data.push(new Float64Array(nColumns));
        }
      } else {
        throw new TypeError("nColumns must be a positive integer");
      }
      this.rows = nRows;
      this.columns = nColumns;
    };
    installMathOperations(AbstractMatrix, Matrix);
    var _matrix;
    var _SymmetricMatrix = class extends AbstractMatrix {
      /**
       * @param {number | AbstractMatrix | ArrayLike<ArrayLike<number>>} diagonalSize
       * @return {this}
       */
      constructor(diagonalSize) {
        super();
        /** @type {Matrix} */
        __privateAdd(this, _matrix, void 0);
        if (Matrix.isMatrix(diagonalSize)) {
          if (!diagonalSize.isSymmetric()) {
            throw new TypeError("not symmetric data");
          }
          __privateSet(this, _matrix, Matrix.copy(
            diagonalSize,
            new Matrix(diagonalSize.rows, diagonalSize.rows)
          ));
        } else if (Number.isInteger(diagonalSize) && diagonalSize >= 0) {
          __privateSet(this, _matrix, new Matrix(diagonalSize, diagonalSize));
        } else {
          __privateSet(this, _matrix, new Matrix(diagonalSize));
          if (!this.isSymmetric()) {
            throw new TypeError("not symmetric data");
          }
        }
      }
      get size() {
        return __privateGet(this, _matrix).size;
      }
      get rows() {
        return __privateGet(this, _matrix).rows;
      }
      get columns() {
        return __privateGet(this, _matrix).columns;
      }
      get diagonalSize() {
        return this.rows;
      }
      /**
       * not the same as matrix.isSymmetric()
       * Here is to check if it's instanceof SymmetricMatrix without bundling issues
       *
       * @param value
       * @returns {boolean}
       */
      static isSymmetricMatrix(value) {
        return Matrix.isMatrix(value) && value.klassType === "SymmetricMatrix";
      }
      /**
       * @param diagonalSize
       * @return {SymmetricMatrix}
       */
      static zeros(diagonalSize) {
        return new this(diagonalSize);
      }
      /**
       * @param diagonalSize
       * @return {SymmetricMatrix}
       */
      static ones(diagonalSize) {
        return new this(diagonalSize).fill(1);
      }
      clone() {
        const matrix = new _SymmetricMatrix(this.diagonalSize);
        for (const [row, col, value] of this.upperRightEntries()) {
          matrix.set(row, col, value);
        }
        return matrix;
      }
      toMatrix() {
        return new Matrix(this);
      }
      get(rowIndex, columnIndex) {
        return __privateGet(this, _matrix).get(rowIndex, columnIndex);
      }
      set(rowIndex, columnIndex, value) {
        __privateGet(this, _matrix).set(rowIndex, columnIndex, value);
        __privateGet(this, _matrix).set(columnIndex, rowIndex, value);
        return this;
      }
      removeCross(index) {
        __privateGet(this, _matrix).removeRow(index);
        __privateGet(this, _matrix).removeColumn(index);
        return this;
      }
      addCross(index, array) {
        if (array === void 0) {
          array = index;
          index = this.diagonalSize;
        }
        const row = array.slice();
        row.splice(index, 1);
        __privateGet(this, _matrix).addRow(index, row);
        __privateGet(this, _matrix).addColumn(index, array);
        return this;
      }
      /**
       * @param {Mask[]} mask
       */
      applyMask(mask) {
        if (mask.length !== this.diagonalSize) {
          throw new RangeError("Mask size do not match with matrix size");
        }
        const sidesToRemove = [];
        for (const [index, passthroughs] of mask.entries()) {
          if (passthroughs)
            continue;
          sidesToRemove.push(index);
        }
        sidesToRemove.reverse();
        for (const sideIndex of sidesToRemove) {
          this.removeCross(sideIndex);
        }
        return this;
      }
      /**
       * Compact format upper-right corner of matrix
       * iterate from left to right, from top to bottom.
       *
       * ```
       *   A B C D
       * A 1 2 3 4
       * B 2 5 6 7
       * C 3 6 8 9
       * D 4 7 9 10
       * ```
       *
       * will return compact 1D array `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`
       *
       * length is S(i=0, n=sideSize) => 10 for a 4 sideSized matrix
       *
       * @returns {number[]}
       */
      toCompact() {
        const { diagonalSize } = this;
        const compact = new Array(diagonalSize * (diagonalSize + 1) / 2);
        for (let col = 0, row = 0, index = 0; index < compact.length; index++) {
          compact[index] = this.get(row, col);
          if (++col >= diagonalSize)
            col = ++row;
        }
        return compact;
      }
      /**
       * @param {number[]} compact
       * @return {SymmetricMatrix}
       */
      static fromCompact(compact) {
        const compactSize = compact.length;
        const diagonalSize = (Math.sqrt(8 * compactSize + 1) - 1) / 2;
        if (!Number.isInteger(diagonalSize)) {
          throw new TypeError(
            `This array is not a compact representation of a Symmetric Matrix, ${JSON.stringify(
              compact
            )}`
          );
        }
        const matrix = new _SymmetricMatrix(diagonalSize);
        for (let col = 0, row = 0, index = 0; index < compactSize; index++) {
          matrix.set(col, row, compact[index]);
          if (++col >= diagonalSize)
            col = ++row;
        }
        return matrix;
      }
      /**
       * half iterator upper-right-corner from left to right, from top to bottom
       * yield [row, column, value]
       *
       * @returns {Generator<[number, number, number], void, *>}
       */
      *upperRightEntries() {
        for (let row = 0, col = 0; row < this.diagonalSize; void 0) {
          const value = this.get(row, col);
          yield [row, col, value];
          if (++col >= this.diagonalSize)
            col = ++row;
        }
      }
      /**
       * half iterator upper-right-corner from left to right, from top to bottom
       * yield value
       *
       * @returns {Generator<[number, number, number], void, *>}
       */
      *upperRightValues() {
        for (let row = 0, col = 0; row < this.diagonalSize; void 0) {
          const value = this.get(row, col);
          yield value;
          if (++col >= this.diagonalSize)
            col = ++row;
        }
      }
    };
    var SymmetricMatrix = _SymmetricMatrix;
    _matrix = new WeakMap();
    SymmetricMatrix.prototype.klassType = "SymmetricMatrix";
    var DistanceMatrix = class extends SymmetricMatrix {
      /**
       * not the same as matrix.isSymmetric()
       * Here is to check if it's instanceof SymmetricMatrix without bundling issues
       *
       * @param value
       * @returns {boolean}
       */
      static isDistanceMatrix(value) {
        return SymmetricMatrix.isSymmetricMatrix(value) && value.klassSubType === "DistanceMatrix";
      }
      constructor(sideSize) {
        super(sideSize);
        if (!this.isDistance()) {
          throw new TypeError("Provided arguments do no produce a distance matrix");
        }
      }
      set(rowIndex, columnIndex, value) {
        if (rowIndex === columnIndex)
          value = 0;
        return super.set(rowIndex, columnIndex, value);
      }
      addCross(index, array) {
        if (array === void 0) {
          array = index;
          index = this.diagonalSize;
        }
        array = array.slice();
        array[index] = 0;
        return super.addCross(index, array);
      }
      toSymmetricMatrix() {
        return new SymmetricMatrix(this);
      }
      clone() {
        const matrix = new DistanceMatrix(this.diagonalSize);
        for (const [row, col, value] of this.upperRightEntries()) {
          if (row === col)
            continue;
          matrix.set(row, col, value);
        }
        return matrix;
      }
      /**
       * Compact format upper-right corner of matrix
       * no diagonal (only zeros)
       * iterable from left to right, from top to bottom.
       *
       * ```
       *   A B C D
       * A 0 1 2 3
       * B 1 0 4 5
       * C 2 4 0 6
       * D 3 5 6 0
       * ```
       *
       * will return compact 1D array `[1, 2, 3, 4, 5, 6]`
       *
       * length is S(i=0, n=sideSize-1) => 6 for a 4 side sized matrix
       *
       * @returns {number[]}
       */
      toCompact() {
        const { diagonalSize } = this;
        const compactLength = (diagonalSize - 1) * diagonalSize / 2;
        const compact = new Array(compactLength);
        for (let col = 1, row = 0, index = 0; index < compact.length; index++) {
          compact[index] = this.get(row, col);
          if (++col >= diagonalSize)
            col = ++row + 1;
        }
        return compact;
      }
      /**
       * @param {number[]} compact
       */
      static fromCompact(compact) {
        const compactSize = compact.length;
        const diagonalSize = (Math.sqrt(8 * compactSize + 1) + 1) / 2;
        if (!Number.isInteger(diagonalSize)) {
          throw new TypeError(
            `This array is not a compact representation of a DistanceMatrix, ${JSON.stringify(
              compact
            )}`
          );
        }
        const matrix = new this(diagonalSize);
        for (let col = 1, row = 0, index = 0; index < compactSize; index++) {
          matrix.set(col, row, compact[index]);
          if (++col >= diagonalSize)
            col = ++row + 1;
        }
        return matrix;
      }
    };
    DistanceMatrix.prototype.klassSubType = "DistanceMatrix";
    var BaseView = class extends AbstractMatrix {
      constructor(matrix, rows, columns) {
        super();
        this.matrix = matrix;
        this.rows = rows;
        this.columns = columns;
      }
    };
    var MatrixColumnView = class extends BaseView {
      constructor(matrix, column) {
        checkColumnIndex(matrix, column);
        super(matrix, matrix.rows, 1);
        this.column = column;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(rowIndex, this.column, value);
        return this;
      }
      get(rowIndex) {
        return this.matrix.get(rowIndex, this.column);
      }
    };
    var MatrixColumnSelectionView = class extends BaseView {
      constructor(matrix, columnIndices) {
        checkColumnIndices(matrix, columnIndices);
        super(matrix, matrix.rows, columnIndices.length);
        this.columnIndices = columnIndices;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(rowIndex, this.columnIndices[columnIndex], value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(rowIndex, this.columnIndices[columnIndex]);
      }
    };
    var MatrixFlipColumnView = class extends BaseView {
      constructor(matrix) {
        super(matrix, matrix.rows, matrix.columns);
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(rowIndex, this.columns - columnIndex - 1, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(rowIndex, this.columns - columnIndex - 1);
      }
    };
    var MatrixFlipRowView = class extends BaseView {
      constructor(matrix) {
        super(matrix, matrix.rows, matrix.columns);
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.rows - rowIndex - 1, columnIndex, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(this.rows - rowIndex - 1, columnIndex);
      }
    };
    var MatrixRowView = class extends BaseView {
      constructor(matrix, row) {
        checkRowIndex(matrix, row);
        super(matrix, 1, matrix.columns);
        this.row = row;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.row, columnIndex, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(this.row, columnIndex);
      }
    };
    var MatrixRowSelectionView = class extends BaseView {
      constructor(matrix, rowIndices) {
        checkRowIndices(matrix, rowIndices);
        super(matrix, rowIndices.length, matrix.columns);
        this.rowIndices = rowIndices;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.rowIndices[rowIndex], columnIndex, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(this.rowIndices[rowIndex], columnIndex);
      }
    };
    var MatrixSelectionView = class extends BaseView {
      constructor(matrix, rowIndices, columnIndices) {
        checkRowIndices(matrix, rowIndices);
        checkColumnIndices(matrix, columnIndices);
        super(matrix, rowIndices.length, columnIndices.length);
        this.rowIndices = rowIndices;
        this.columnIndices = columnIndices;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(
          this.rowIndices[rowIndex],
          this.columnIndices[columnIndex],
          value
        );
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(
          this.rowIndices[rowIndex],
          this.columnIndices[columnIndex]
        );
      }
    };
    var MatrixSubView = class extends BaseView {
      constructor(matrix, startRow, endRow, startColumn, endColumn) {
        checkRange(matrix, startRow, endRow, startColumn, endColumn);
        super(matrix, endRow - startRow + 1, endColumn - startColumn + 1);
        this.startRow = startRow;
        this.startColumn = startColumn;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(
          this.startRow + rowIndex,
          this.startColumn + columnIndex,
          value
        );
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(
          this.startRow + rowIndex,
          this.startColumn + columnIndex
        );
      }
    };
    var MatrixTransposeView = class extends BaseView {
      constructor(matrix) {
        super(matrix, matrix.columns, matrix.rows);
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(columnIndex, rowIndex, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(columnIndex, rowIndex);
      }
    };
    var WrapperMatrix1D = class extends AbstractMatrix {
      constructor(data, options = {}) {
        const { rows = 1 } = options;
        if (data.length % rows !== 0) {
          throw new Error("the data length is not divisible by the number of rows");
        }
        super();
        this.rows = rows;
        this.columns = data.length / rows;
        this.data = data;
      }
      set(rowIndex, columnIndex, value) {
        let index = this._calculateIndex(rowIndex, columnIndex);
        this.data[index] = value;
        return this;
      }
      get(rowIndex, columnIndex) {
        let index = this._calculateIndex(rowIndex, columnIndex);
        return this.data[index];
      }
      _calculateIndex(row, column) {
        return row * this.columns + column;
      }
    };
    var WrapperMatrix2D = class extends AbstractMatrix {
      constructor(data) {
        super();
        this.data = data;
        this.rows = data.length;
        this.columns = data[0].length;
      }
      set(rowIndex, columnIndex, value) {
        this.data[rowIndex][columnIndex] = value;
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.data[rowIndex][columnIndex];
      }
    };
    function wrap(array, options) {
      if (isAnyArray.isAnyArray(array)) {
        if (array[0] && isAnyArray.isAnyArray(array[0])) {
          return new WrapperMatrix2D(array);
        } else {
          return new WrapperMatrix1D(array, options);
        }
      } else {
        throw new Error("the argument is not an array");
      }
    }
    var LuDecomposition = class {
      constructor(matrix) {
        matrix = WrapperMatrix2D.checkMatrix(matrix);
        let lu = matrix.clone();
        let rows = lu.rows;
        let columns = lu.columns;
        let pivotVector = new Float64Array(rows);
        let pivotSign = 1;
        let i, j, k, p, s, t, v;
        let LUcolj, kmax;
        for (i = 0; i < rows; i++) {
          pivotVector[i] = i;
        }
        LUcolj = new Float64Array(rows);
        for (j = 0; j < columns; j++) {
          for (i = 0; i < rows; i++) {
            LUcolj[i] = lu.get(i, j);
          }
          for (i = 0; i < rows; i++) {
            kmax = Math.min(i, j);
            s = 0;
            for (k = 0; k < kmax; k++) {
              s += lu.get(i, k) * LUcolj[k];
            }
            LUcolj[i] -= s;
            lu.set(i, j, LUcolj[i]);
          }
          p = j;
          for (i = j + 1; i < rows; i++) {
            if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {
              p = i;
            }
          }
          if (p !== j) {
            for (k = 0; k < columns; k++) {
              t = lu.get(p, k);
              lu.set(p, k, lu.get(j, k));
              lu.set(j, k, t);
            }
            v = pivotVector[p];
            pivotVector[p] = pivotVector[j];
            pivotVector[j] = v;
            pivotSign = -pivotSign;
          }
          if (j < rows && lu.get(j, j) !== 0) {
            for (i = j + 1; i < rows; i++) {
              lu.set(i, j, lu.get(i, j) / lu.get(j, j));
            }
          }
        }
        this.LU = lu;
        this.pivotVector = pivotVector;
        this.pivotSign = pivotSign;
      }
      isSingular() {
        let data = this.LU;
        let col = data.columns;
        for (let j = 0; j < col; j++) {
          if (data.get(j, j) === 0) {
            return true;
          }
        }
        return false;
      }
      solve(value) {
        value = Matrix.checkMatrix(value);
        let lu = this.LU;
        let rows = lu.rows;
        if (rows !== value.rows) {
          throw new Error("Invalid matrix dimensions");
        }
        if (this.isSingular()) {
          throw new Error("LU matrix is singular");
        }
        let count = value.columns;
        let X = value.subMatrixRow(this.pivotVector, 0, count - 1);
        let columns = lu.columns;
        let i, j, k;
        for (k = 0; k < columns; k++) {
          for (i = k + 1; i < columns; i++) {
            for (j = 0; j < count; j++) {
              X.set(i, j, X.get(i, j) - X.get(k, j) * lu.get(i, k));
            }
          }
        }
        for (k = columns - 1; k >= 0; k--) {
          for (j = 0; j < count; j++) {
            X.set(k, j, X.get(k, j) / lu.get(k, k));
          }
          for (i = 0; i < k; i++) {
            for (j = 0; j < count; j++) {
              X.set(i, j, X.get(i, j) - X.get(k, j) * lu.get(i, k));
            }
          }
        }
        return X;
      }
      get determinant() {
        let data = this.LU;
        if (!data.isSquare()) {
          throw new Error("Matrix must be square");
        }
        let determinant2 = this.pivotSign;
        let col = data.columns;
        for (let j = 0; j < col; j++) {
          determinant2 *= data.get(j, j);
        }
        return determinant2;
      }
      get lowerTriangularMatrix() {
        let data = this.LU;
        let rows = data.rows;
        let columns = data.columns;
        let X = new Matrix(rows, columns);
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < columns; j++) {
            if (i > j) {
              X.set(i, j, data.get(i, j));
            } else if (i === j) {
              X.set(i, j, 1);
            } else {
              X.set(i, j, 0);
            }
          }
        }
        return X;
      }
      get upperTriangularMatrix() {
        let data = this.LU;
        let rows = data.rows;
        let columns = data.columns;
        let X = new Matrix(rows, columns);
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < columns; j++) {
            if (i <= j) {
              X.set(i, j, data.get(i, j));
            } else {
              X.set(i, j, 0);
            }
          }
        }
        return X;
      }
      get pivotPermutationVector() {
        return Array.from(this.pivotVector);
      }
    };
    function hypotenuse(a, b) {
      let r = 0;
      if (Math.abs(a) > Math.abs(b)) {
        r = b / a;
        return Math.abs(a) * Math.sqrt(1 + r * r);
      }
      if (b !== 0) {
        r = a / b;
        return Math.abs(b) * Math.sqrt(1 + r * r);
      }
      return 0;
    }
    var QrDecomposition = class {
      constructor(value) {
        value = WrapperMatrix2D.checkMatrix(value);
        let qr = value.clone();
        let m = value.rows;
        let n = value.columns;
        let rdiag = new Float64Array(n);
        let i, j, k, s;
        for (k = 0; k < n; k++) {
          let nrm = 0;
          for (i = k; i < m; i++) {
            nrm = hypotenuse(nrm, qr.get(i, k));
          }
          if (nrm !== 0) {
            if (qr.get(k, k) < 0) {
              nrm = -nrm;
            }
            for (i = k; i < m; i++) {
              qr.set(i, k, qr.get(i, k) / nrm);
            }
            qr.set(k, k, qr.get(k, k) + 1);
            for (j = k + 1; j < n; j++) {
              s = 0;
              for (i = k; i < m; i++) {
                s += qr.get(i, k) * qr.get(i, j);
              }
              s = -s / qr.get(k, k);
              for (i = k; i < m; i++) {
                qr.set(i, j, qr.get(i, j) + s * qr.get(i, k));
              }
            }
          }
          rdiag[k] = -nrm;
        }
        this.QR = qr;
        this.Rdiag = rdiag;
      }
      solve(value) {
        value = Matrix.checkMatrix(value);
        let qr = this.QR;
        let m = qr.rows;
        if (value.rows !== m) {
          throw new Error("Matrix row dimensions must agree");
        }
        if (!this.isFullRank()) {
          throw new Error("Matrix is rank deficient");
        }
        let count = value.columns;
        let X = value.clone();
        let n = qr.columns;
        let i, j, k, s;
        for (k = 0; k < n; k++) {
          for (j = 0; j < count; j++) {
            s = 0;
            for (i = k; i < m; i++) {
              s += qr.get(i, k) * X.get(i, j);
            }
            s = -s / qr.get(k, k);
            for (i = k; i < m; i++) {
              X.set(i, j, X.get(i, j) + s * qr.get(i, k));
            }
          }
        }
        for (k = n - 1; k >= 0; k--) {
          for (j = 0; j < count; j++) {
            X.set(k, j, X.get(k, j) / this.Rdiag[k]);
          }
          for (i = 0; i < k; i++) {
            for (j = 0; j < count; j++) {
              X.set(i, j, X.get(i, j) - X.get(k, j) * qr.get(i, k));
            }
          }
        }
        return X.subMatrix(0, n - 1, 0, count - 1);
      }
      isFullRank() {
        let columns = this.QR.columns;
        for (let i = 0; i < columns; i++) {
          if (this.Rdiag[i] === 0) {
            return false;
          }
        }
        return true;
      }
      get upperTriangularMatrix() {
        let qr = this.QR;
        let n = qr.columns;
        let X = new Matrix(n, n);
        let i, j;
        for (i = 0; i < n; i++) {
          for (j = 0; j < n; j++) {
            if (i < j) {
              X.set(i, j, qr.get(i, j));
            } else if (i === j) {
              X.set(i, j, this.Rdiag[i]);
            } else {
              X.set(i, j, 0);
            }
          }
        }
        return X;
      }
      get orthogonalMatrix() {
        let qr = this.QR;
        let rows = qr.rows;
        let columns = qr.columns;
        let X = new Matrix(rows, columns);
        let i, j, k, s;
        for (k = columns - 1; k >= 0; k--) {
          for (i = 0; i < rows; i++) {
            X.set(i, k, 0);
          }
          X.set(k, k, 1);
          for (j = k; j < columns; j++) {
            if (qr.get(k, k) !== 0) {
              s = 0;
              for (i = k; i < rows; i++) {
                s += qr.get(i, k) * X.get(i, j);
              }
              s = -s / qr.get(k, k);
              for (i = k; i < rows; i++) {
                X.set(i, j, X.get(i, j) + s * qr.get(i, k));
              }
            }
          }
        }
        return X;
      }
    };
    var SingularValueDecomposition = class {
      constructor(value, options = {}) {
        value = WrapperMatrix2D.checkMatrix(value);
        if (value.isEmpty()) {
          throw new Error("Matrix must be non-empty");
        }
        let m = value.rows;
        let n = value.columns;
        const {
          computeLeftSingularVectors = true,
          computeRightSingularVectors = true,
          autoTranspose = false
        } = options;
        let wantu = Boolean(computeLeftSingularVectors);
        let wantv = Boolean(computeRightSingularVectors);
        let swapped = false;
        let a;
        if (m < n) {
          if (!autoTranspose) {
            a = value.clone();
            console.warn(
              "Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose"
            );
          } else {
            a = value.transpose();
            m = a.rows;
            n = a.columns;
            swapped = true;
            let aux = wantu;
            wantu = wantv;
            wantv = aux;
          }
        } else {
          a = value.clone();
        }
        let nu = Math.min(m, n);
        let ni = Math.min(m + 1, n);
        let s = new Float64Array(ni);
        let U = new Matrix(m, nu);
        let V = new Matrix(n, n);
        let e = new Float64Array(n);
        let work = new Float64Array(m);
        let si = new Float64Array(ni);
        for (let i = 0; i < ni; i++)
          si[i] = i;
        let nct = Math.min(m - 1, n);
        let nrt = Math.max(0, Math.min(n - 2, m));
        let mrc = Math.max(nct, nrt);
        for (let k = 0; k < mrc; k++) {
          if (k < nct) {
            s[k] = 0;
            for (let i = k; i < m; i++) {
              s[k] = hypotenuse(s[k], a.get(i, k));
            }
            if (s[k] !== 0) {
              if (a.get(k, k) < 0) {
                s[k] = -s[k];
              }
              for (let i = k; i < m; i++) {
                a.set(i, k, a.get(i, k) / s[k]);
              }
              a.set(k, k, a.get(k, k) + 1);
            }
            s[k] = -s[k];
          }
          for (let j = k + 1; j < n; j++) {
            if (k < nct && s[k] !== 0) {
              let t = 0;
              for (let i = k; i < m; i++) {
                t += a.get(i, k) * a.get(i, j);
              }
              t = -t / a.get(k, k);
              for (let i = k; i < m; i++) {
                a.set(i, j, a.get(i, j) + t * a.get(i, k));
              }
            }
            e[j] = a.get(k, j);
          }
          if (wantu && k < nct) {
            for (let i = k; i < m; i++) {
              U.set(i, k, a.get(i, k));
            }
          }
          if (k < nrt) {
            e[k] = 0;
            for (let i = k + 1; i < n; i++) {
              e[k] = hypotenuse(e[k], e[i]);
            }
            if (e[k] !== 0) {
              if (e[k + 1] < 0) {
                e[k] = 0 - e[k];
              }
              for (let i = k + 1; i < n; i++) {
                e[i] /= e[k];
              }
              e[k + 1] += 1;
            }
            e[k] = -e[k];
            if (k + 1 < m && e[k] !== 0) {
              for (let i = k + 1; i < m; i++) {
                work[i] = 0;
              }
              for (let i = k + 1; i < m; i++) {
                for (let j = k + 1; j < n; j++) {
                  work[i] += e[j] * a.get(i, j);
                }
              }
              for (let j = k + 1; j < n; j++) {
                let t = -e[j] / e[k + 1];
                for (let i = k + 1; i < m; i++) {
                  a.set(i, j, a.get(i, j) + t * work[i]);
                }
              }
            }
            if (wantv) {
              for (let i = k + 1; i < n; i++) {
                V.set(i, k, e[i]);
              }
            }
          }
        }
        let p = Math.min(n, m + 1);
        if (nct < n) {
          s[nct] = a.get(nct, nct);
        }
        if (m < p) {
          s[p - 1] = 0;
        }
        if (nrt + 1 < p) {
          e[nrt] = a.get(nrt, p - 1);
        }
        e[p - 1] = 0;
        if (wantu) {
          for (let j = nct; j < nu; j++) {
            for (let i = 0; i < m; i++) {
              U.set(i, j, 0);
            }
            U.set(j, j, 1);
          }
          for (let k = nct - 1; k >= 0; k--) {
            if (s[k] !== 0) {
              for (let j = k + 1; j < nu; j++) {
                let t = 0;
                for (let i = k; i < m; i++) {
                  t += U.get(i, k) * U.get(i, j);
                }
                t = -t / U.get(k, k);
                for (let i = k; i < m; i++) {
                  U.set(i, j, U.get(i, j) + t * U.get(i, k));
                }
              }
              for (let i = k; i < m; i++) {
                U.set(i, k, -U.get(i, k));
              }
              U.set(k, k, 1 + U.get(k, k));
              for (let i = 0; i < k - 1; i++) {
                U.set(i, k, 0);
              }
            } else {
              for (let i = 0; i < m; i++) {
                U.set(i, k, 0);
              }
              U.set(k, k, 1);
            }
          }
        }
        if (wantv) {
          for (let k = n - 1; k >= 0; k--) {
            if (k < nrt && e[k] !== 0) {
              for (let j = k + 1; j < n; j++) {
                let t = 0;
                for (let i = k + 1; i < n; i++) {
                  t += V.get(i, k) * V.get(i, j);
                }
                t = -t / V.get(k + 1, k);
                for (let i = k + 1; i < n; i++) {
                  V.set(i, j, V.get(i, j) + t * V.get(i, k));
                }
              }
            }
            for (let i = 0; i < n; i++) {
              V.set(i, k, 0);
            }
            V.set(k, k, 1);
          }
        }
        let pp = p - 1;
        let eps = Number.EPSILON;
        while (p > 0) {
          let k, kase;
          for (k = p - 2; k >= -1; k--) {
            if (k === -1) {
              break;
            }
            const alpha = Number.MIN_VALUE + eps * Math.abs(s[k] + Math.abs(s[k + 1]));
            if (Math.abs(e[k]) <= alpha || Number.isNaN(e[k])) {
              e[k] = 0;
              break;
            }
          }
          if (k === p - 2) {
            kase = 4;
          } else {
            let ks;
            for (ks = p - 1; ks >= k; ks--) {
              if (ks === k) {
                break;
              }
              let t = (ks !== p ? Math.abs(e[ks]) : 0) + (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);
              if (Math.abs(s[ks]) <= eps * t) {
                s[ks] = 0;
                break;
              }
            }
            if (ks === k) {
              kase = 3;
            } else if (ks === p - 1) {
              kase = 1;
            } else {
              kase = 2;
              k = ks;
            }
          }
          k++;
          switch (kase) {
            case 1: {
              let f = e[p - 2];
              e[p - 2] = 0;
              for (let j = p - 2; j >= k; j--) {
                let t = hypotenuse(s[j], f);
                let cs = s[j] / t;
                let sn = f / t;
                s[j] = t;
                if (j !== k) {
                  f = -sn * e[j - 1];
                  e[j - 1] = cs * e[j - 1];
                }
                if (wantv) {
                  for (let i = 0; i < n; i++) {
                    t = cs * V.get(i, j) + sn * V.get(i, p - 1);
                    V.set(i, p - 1, -sn * V.get(i, j) + cs * V.get(i, p - 1));
                    V.set(i, j, t);
                  }
                }
              }
              break;
            }
            case 2: {
              let f = e[k - 1];
              e[k - 1] = 0;
              for (let j = k; j < p; j++) {
                let t = hypotenuse(s[j], f);
                let cs = s[j] / t;
                let sn = f / t;
                s[j] = t;
                f = -sn * e[j];
                e[j] = cs * e[j];
                if (wantu) {
                  for (let i = 0; i < m; i++) {
                    t = cs * U.get(i, j) + sn * U.get(i, k - 1);
                    U.set(i, k - 1, -sn * U.get(i, j) + cs * U.get(i, k - 1));
                    U.set(i, j, t);
                  }
                }
              }
              break;
            }
            case 3: {
              const scale = Math.max(
                Math.abs(s[p - 1]),
                Math.abs(s[p - 2]),
                Math.abs(e[p - 2]),
                Math.abs(s[k]),
                Math.abs(e[k])
              );
              const sp = s[p - 1] / scale;
              const spm1 = s[p - 2] / scale;
              const epm1 = e[p - 2] / scale;
              const sk = s[k] / scale;
              const ek = e[k] / scale;
              const b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;
              const c = sp * epm1 * (sp * epm1);
              let shift = 0;
              if (b !== 0 || c !== 0) {
                if (b < 0) {
                  shift = 0 - Math.sqrt(b * b + c);
                } else {
                  shift = Math.sqrt(b * b + c);
                }
                shift = c / (b + shift);
              }
              let f = (sk + sp) * (sk - sp) + shift;
              let g = sk * ek;
              for (let j = k; j < p - 1; j++) {
                let t = hypotenuse(f, g);
                if (t === 0)
                  t = Number.MIN_VALUE;
                let cs = f / t;
                let sn = g / t;
                if (j !== k) {
                  e[j - 1] = t;
                }
                f = cs * s[j] + sn * e[j];
                e[j] = cs * e[j] - sn * s[j];
                g = sn * s[j + 1];
                s[j + 1] = cs * s[j + 1];
                if (wantv) {
                  for (let i = 0; i < n; i++) {
                    t = cs * V.get(i, j) + sn * V.get(i, j + 1);
                    V.set(i, j + 1, -sn * V.get(i, j) + cs * V.get(i, j + 1));
                    V.set(i, j, t);
                  }
                }
                t = hypotenuse(f, g);
                if (t === 0)
                  t = Number.MIN_VALUE;
                cs = f / t;
                sn = g / t;
                s[j] = t;
                f = cs * e[j] + sn * s[j + 1];
                s[j + 1] = -sn * e[j] + cs * s[j + 1];
                g = sn * e[j + 1];
                e[j + 1] = cs * e[j + 1];
                if (wantu && j < m - 1) {
                  for (let i = 0; i < m; i++) {
                    t = cs * U.get(i, j) + sn * U.get(i, j + 1);
                    U.set(i, j + 1, -sn * U.get(i, j) + cs * U.get(i, j + 1));
                    U.set(i, j, t);
                  }
                }
              }
              e[p - 2] = f;
              break;
            }
            case 4: {
              if (s[k] <= 0) {
                s[k] = s[k] < 0 ? -s[k] : 0;
                if (wantv) {
                  for (let i = 0; i <= pp; i++) {
                    V.set(i, k, -V.get(i, k));
                  }
                }
              }
              while (k < pp) {
                if (s[k] >= s[k + 1]) {
                  break;
                }
                let t = s[k];
                s[k] = s[k + 1];
                s[k + 1] = t;
                if (wantv && k < n - 1) {
                  for (let i = 0; i < n; i++) {
                    t = V.get(i, k + 1);
                    V.set(i, k + 1, V.get(i, k));
                    V.set(i, k, t);
                  }
                }
                if (wantu && k < m - 1) {
                  for (let i = 0; i < m; i++) {
                    t = U.get(i, k + 1);
                    U.set(i, k + 1, U.get(i, k));
                    U.set(i, k, t);
                  }
                }
                k++;
              }
              p--;
              break;
            }
          }
        }
        if (swapped) {
          let tmp = V;
          V = U;
          U = tmp;
        }
        this.m = m;
        this.n = n;
        this.s = s;
        this.U = U;
        this.V = V;
      }
      solve(value) {
        let Y = value;
        let e = this.threshold;
        let scols = this.s.length;
        let Ls = Matrix.zeros(scols, scols);
        for (let i = 0; i < scols; i++) {
          if (Math.abs(this.s[i]) <= e) {
            Ls.set(i, i, 0);
          } else {
            Ls.set(i, i, 1 / this.s[i]);
          }
        }
        let U = this.U;
        let V = this.rightSingularVectors;
        let VL = V.mmul(Ls);
        let vrows = V.rows;
        let urows = U.rows;
        let VLU = Matrix.zeros(vrows, urows);
        for (let i = 0; i < vrows; i++) {
          for (let j = 0; j < urows; j++) {
            let sum = 0;
            for (let k = 0; k < scols; k++) {
              sum += VL.get(i, k) * U.get(j, k);
            }
            VLU.set(i, j, sum);
          }
        }
        return VLU.mmul(Y);
      }
      solveForDiagonal(value) {
        return this.solve(Matrix.diag(value));
      }
      inverse() {
        let V = this.V;
        let e = this.threshold;
        let vrows = V.rows;
        let vcols = V.columns;
        let X = new Matrix(vrows, this.s.length);
        for (let i = 0; i < vrows; i++) {
          for (let j = 0; j < vcols; j++) {
            if (Math.abs(this.s[j]) > e) {
              X.set(i, j, V.get(i, j) / this.s[j]);
            }
          }
        }
        let U = this.U;
        let urows = U.rows;
        let ucols = U.columns;
        let Y = new Matrix(vrows, urows);
        for (let i = 0; i < vrows; i++) {
          for (let j = 0; j < urows; j++) {
            let sum = 0;
            for (let k = 0; k < ucols; k++) {
              sum += X.get(i, k) * U.get(j, k);
            }
            Y.set(i, j, sum);
          }
        }
        return Y;
      }
      get condition() {
        return this.s[0] / this.s[Math.min(this.m, this.n) - 1];
      }
      get norm2() {
        return this.s[0];
      }
      get rank() {
        let tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;
        let r = 0;
        let s = this.s;
        for (let i = 0, ii = s.length; i < ii; i++) {
          if (s[i] > tol) {
            r++;
          }
        }
        return r;
      }
      get diagonal() {
        return Array.from(this.s);
      }
      get threshold() {
        return Number.EPSILON / 2 * Math.max(this.m, this.n) * this.s[0];
      }
      get leftSingularVectors() {
        return this.U;
      }
      get rightSingularVectors() {
        return this.V;
      }
      get diagonalMatrix() {
        return Matrix.diag(this.s);
      }
    };
    function inverse(matrix, useSVD = false) {
      matrix = WrapperMatrix2D.checkMatrix(matrix);
      if (useSVD) {
        return new SingularValueDecomposition(matrix).inverse();
      } else {
        return solve(matrix, Matrix.eye(matrix.rows));
      }
    }
    function solve(leftHandSide, rightHandSide, useSVD = false) {
      leftHandSide = WrapperMatrix2D.checkMatrix(leftHandSide);
      rightHandSide = WrapperMatrix2D.checkMatrix(rightHandSide);
      if (useSVD) {
        return new SingularValueDecomposition(leftHandSide).solve(rightHandSide);
      } else {
        return leftHandSide.isSquare() ? new LuDecomposition(leftHandSide).solve(rightHandSide) : new QrDecomposition(leftHandSide).solve(rightHandSide);
      }
    }
    function determinant(matrix) {
      matrix = Matrix.checkMatrix(matrix);
      if (matrix.isSquare()) {
        if (matrix.columns === 0) {
          return 1;
        }
        let a, b, c, d;
        if (matrix.columns === 2) {
          a = matrix.get(0, 0);
          b = matrix.get(0, 1);
          c = matrix.get(1, 0);
          d = matrix.get(1, 1);
          return a * d - b * c;
        } else if (matrix.columns === 3) {
          let subMatrix0, subMatrix1, subMatrix2;
          subMatrix0 = new MatrixSelectionView(matrix, [1, 2], [1, 2]);
          subMatrix1 = new MatrixSelectionView(matrix, [1, 2], [0, 2]);
          subMatrix2 = new MatrixSelectionView(matrix, [1, 2], [0, 1]);
          a = matrix.get(0, 0);
          b = matrix.get(0, 1);
          c = matrix.get(0, 2);
          return a * determinant(subMatrix0) - b * determinant(subMatrix1) + c * determinant(subMatrix2);
        } else {
          return new LuDecomposition(matrix).determinant;
        }
      } else {
        throw Error("determinant can only be calculated for a square matrix");
      }
    }
    function xrange(n, exception) {
      let range = [];
      for (let i = 0; i < n; i++) {
        if (i !== exception) {
          range.push(i);
        }
      }
      return range;
    }
    function dependenciesOneRow(error, matrix, index, thresholdValue = 1e-9, thresholdError = 1e-9) {
      if (error > thresholdError) {
        return new Array(matrix.rows + 1).fill(0);
      } else {
        let returnArray = matrix.addRow(index, [0]);
        for (let i = 0; i < returnArray.rows; i++) {
          if (Math.abs(returnArray.get(i, 0)) < thresholdValue) {
            returnArray.set(i, 0, 0);
          }
        }
        return returnArray.to1DArray();
      }
    }
    function linearDependencies(matrix, options = {}) {
      const { thresholdValue = 1e-9, thresholdError = 1e-9 } = options;
      matrix = Matrix.checkMatrix(matrix);
      let n = matrix.rows;
      let results = new Matrix(n, n);
      for (let i = 0; i < n; i++) {
        let b = Matrix.columnVector(matrix.getRow(i));
        let Abis = matrix.subMatrixRow(xrange(n, i)).transpose();
        let svd = new SingularValueDecomposition(Abis);
        let x = svd.solve(b);
        let error = Matrix.sub(b, Abis.mmul(x)).abs().max();
        results.setRow(
          i,
          dependenciesOneRow(error, x, i, thresholdValue, thresholdError)
        );
      }
      return results;
    }
    function pseudoInverse(matrix, threshold = Number.EPSILON) {
      matrix = Matrix.checkMatrix(matrix);
      if (matrix.isEmpty()) {
        return matrix.transpose();
      }
      let svdSolution = new SingularValueDecomposition(matrix, { autoTranspose: true });
      let U = svdSolution.leftSingularVectors;
      let V = svdSolution.rightSingularVectors;
      let s = svdSolution.diagonal;
      for (let i = 0; i < s.length; i++) {
        if (Math.abs(s[i]) > threshold) {
          s[i] = 1 / s[i];
        } else {
          s[i] = 0;
        }
      }
      return V.mmul(Matrix.diag(s).mmul(U.transpose()));
    }
    function covariance(xMatrix, yMatrix = xMatrix, options = {}) {
      xMatrix = new Matrix(xMatrix);
      let yIsSame = false;
      if (typeof yMatrix === "object" && !Matrix.isMatrix(yMatrix) && !isAnyArray.isAnyArray(yMatrix)) {
        options = yMatrix;
        yMatrix = xMatrix;
        yIsSame = true;
      } else {
        yMatrix = new Matrix(yMatrix);
      }
      if (xMatrix.rows !== yMatrix.rows) {
        throw new TypeError("Both matrices must have the same number of rows");
      }
      const { center = true } = options;
      if (center) {
        xMatrix = xMatrix.center("column");
        if (!yIsSame) {
          yMatrix = yMatrix.center("column");
        }
      }
      const cov = xMatrix.transpose().mmul(yMatrix);
      for (let i = 0; i < cov.rows; i++) {
        for (let j = 0; j < cov.columns; j++) {
          cov.set(i, j, cov.get(i, j) * (1 / (xMatrix.rows - 1)));
        }
      }
      return cov;
    }
    function correlation(xMatrix, yMatrix = xMatrix, options = {}) {
      xMatrix = new Matrix(xMatrix);
      let yIsSame = false;
      if (typeof yMatrix === "object" && !Matrix.isMatrix(yMatrix) && !isAnyArray.isAnyArray(yMatrix)) {
        options = yMatrix;
        yMatrix = xMatrix;
        yIsSame = true;
      } else {
        yMatrix = new Matrix(yMatrix);
      }
      if (xMatrix.rows !== yMatrix.rows) {
        throw new TypeError("Both matrices must have the same number of rows");
      }
      const { center = true, scale = true } = options;
      if (center) {
        xMatrix.center("column");
        if (!yIsSame) {
          yMatrix.center("column");
        }
      }
      if (scale) {
        xMatrix.scale("column");
        if (!yIsSame) {
          yMatrix.scale("column");
        }
      }
      const sdx = xMatrix.standardDeviation("column", { unbiased: true });
      const sdy = yIsSame ? sdx : yMatrix.standardDeviation("column", { unbiased: true });
      const corr = xMatrix.transpose().mmul(yMatrix);
      for (let i = 0; i < corr.rows; i++) {
        for (let j = 0; j < corr.columns; j++) {
          corr.set(
            i,
            j,
            corr.get(i, j) * (1 / (sdx[i] * sdy[j])) * (1 / (xMatrix.rows - 1))
          );
        }
      }
      return corr;
    }
    var EigenvalueDecomposition = class {
      constructor(matrix, options = {}) {
        const { assumeSymmetric = false } = options;
        matrix = WrapperMatrix2D.checkMatrix(matrix);
        if (!matrix.isSquare()) {
          throw new Error("Matrix is not a square matrix");
        }
        if (matrix.isEmpty()) {
          throw new Error("Matrix must be non-empty");
        }
        let n = matrix.columns;
        let V = new Matrix(n, n);
        let d = new Float64Array(n);
        let e = new Float64Array(n);
        let value = matrix;
        let i, j;
        let isSymmetric = false;
        if (assumeSymmetric) {
          isSymmetric = true;
        } else {
          isSymmetric = matrix.isSymmetric();
        }
        if (isSymmetric) {
          for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
              V.set(i, j, value.get(i, j));
            }
          }
          tred2(n, e, d, V);
          tql2(n, e, d, V);
        } else {
          let H = new Matrix(n, n);
          let ort = new Float64Array(n);
          for (j = 0; j < n; j++) {
            for (i = 0; i < n; i++) {
              H.set(i, j, value.get(i, j));
            }
          }
          orthes(n, H, ort, V);
          hqr2(n, e, d, V, H);
        }
        this.n = n;
        this.e = e;
        this.d = d;
        this.V = V;
      }
      get realEigenvalues() {
        return Array.from(this.d);
      }
      get imaginaryEigenvalues() {
        return Array.from(this.e);
      }
      get eigenvectorMatrix() {
        return this.V;
      }
      get diagonalMatrix() {
        let n = this.n;
        let e = this.e;
        let d = this.d;
        let X = new Matrix(n, n);
        let i, j;
        for (i = 0; i < n; i++) {
          for (j = 0; j < n; j++) {
            X.set(i, j, 0);
          }
          X.set(i, i, d[i]);
          if (e[i] > 0) {
            X.set(i, i + 1, e[i]);
          } else if (e[i] < 0) {
            X.set(i, i - 1, e[i]);
          }
        }
        return X;
      }
    };
    function tred2(n, e, d, V) {
      let f, g, h, i, j, k, hh, scale;
      for (j = 0; j < n; j++) {
        d[j] = V.get(n - 1, j);
      }
      for (i = n - 1; i > 0; i--) {
        scale = 0;
        h = 0;
        for (k = 0; k < i; k++) {
          scale = scale + Math.abs(d[k]);
        }
        if (scale === 0) {
          e[i] = d[i - 1];
          for (j = 0; j < i; j++) {
            d[j] = V.get(i - 1, j);
            V.set(i, j, 0);
            V.set(j, i, 0);
          }
        } else {
          for (k = 0; k < i; k++) {
            d[k] /= scale;
            h += d[k] * d[k];
          }
          f = d[i - 1];
          g = Math.sqrt(h);
          if (f > 0) {
            g = -g;
          }
          e[i] = scale * g;
          h = h - f * g;
          d[i - 1] = f - g;
          for (j = 0; j < i; j++) {
            e[j] = 0;
          }
          for (j = 0; j < i; j++) {
            f = d[j];
            V.set(j, i, f);
            g = e[j] + V.get(j, j) * f;
            for (k = j + 1; k <= i - 1; k++) {
              g += V.get(k, j) * d[k];
              e[k] += V.get(k, j) * f;
            }
            e[j] = g;
          }
          f = 0;
          for (j = 0; j < i; j++) {
            e[j] /= h;
            f += e[j] * d[j];
          }
          hh = f / (h + h);
          for (j = 0; j < i; j++) {
            e[j] -= hh * d[j];
          }
          for (j = 0; j < i; j++) {
            f = d[j];
            g = e[j];
            for (k = j; k <= i - 1; k++) {
              V.set(k, j, V.get(k, j) - (f * e[k] + g * d[k]));
            }
            d[j] = V.get(i - 1, j);
            V.set(i, j, 0);
          }
        }
        d[i] = h;
      }
      for (i = 0; i < n - 1; i++) {
        V.set(n - 1, i, V.get(i, i));
        V.set(i, i, 1);
        h = d[i + 1];
        if (h !== 0) {
          for (k = 0; k <= i; k++) {
            d[k] = V.get(k, i + 1) / h;
          }
          for (j = 0; j <= i; j++) {
            g = 0;
            for (k = 0; k <= i; k++) {
              g += V.get(k, i + 1) * V.get(k, j);
            }
            for (k = 0; k <= i; k++) {
              V.set(k, j, V.get(k, j) - g * d[k]);
            }
          }
        }
        for (k = 0; k <= i; k++) {
          V.set(k, i + 1, 0);
        }
      }
      for (j = 0; j < n; j++) {
        d[j] = V.get(n - 1, j);
        V.set(n - 1, j, 0);
      }
      V.set(n - 1, n - 1, 1);
      e[0] = 0;
    }
    function tql2(n, e, d, V) {
      let g, h, i, j, k, l, m, p, r, dl1, c, c2, c3, el1, s, s2;
      for (i = 1; i < n; i++) {
        e[i - 1] = e[i];
      }
      e[n - 1] = 0;
      let f = 0;
      let tst1 = 0;
      let eps = Number.EPSILON;
      for (l = 0; l < n; l++) {
        tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));
        m = l;
        while (m < n) {
          if (Math.abs(e[m]) <= eps * tst1) {
            break;
          }
          m++;
        }
        if (m > l) {
          do {
            g = d[l];
            p = (d[l + 1] - g) / (2 * e[l]);
            r = hypotenuse(p, 1);
            if (p < 0) {
              r = -r;
            }
            d[l] = e[l] / (p + r);
            d[l + 1] = e[l] * (p + r);
            dl1 = d[l + 1];
            h = g - d[l];
            for (i = l + 2; i < n; i++) {
              d[i] -= h;
            }
            f = f + h;
            p = d[m];
            c = 1;
            c2 = c;
            c3 = c;
            el1 = e[l + 1];
            s = 0;
            s2 = 0;
            for (i = m - 1; i >= l; i--) {
              c3 = c2;
              c2 = c;
              s2 = s;
              g = c * e[i];
              h = c * p;
              r = hypotenuse(p, e[i]);
              e[i + 1] = s * r;
              s = e[i] / r;
              c = p / r;
              p = c * d[i] - s * g;
              d[i + 1] = h + s * (c * g + s * d[i]);
              for (k = 0; k < n; k++) {
                h = V.get(k, i + 1);
                V.set(k, i + 1, s * V.get(k, i) + c * h);
                V.set(k, i, c * V.get(k, i) - s * h);
              }
            }
            p = -s * s2 * c3 * el1 * e[l] / dl1;
            e[l] = s * p;
            d[l] = c * p;
          } while (Math.abs(e[l]) > eps * tst1);
        }
        d[l] = d[l] + f;
        e[l] = 0;
      }
      for (i = 0; i < n - 1; i++) {
        k = i;
        p = d[i];
        for (j = i + 1; j < n; j++) {
          if (d[j] < p) {
            k = j;
            p = d[j];
          }
        }
        if (k !== i) {
          d[k] = d[i];
          d[i] = p;
          for (j = 0; j < n; j++) {
            p = V.get(j, i);
            V.set(j, i, V.get(j, k));
            V.set(j, k, p);
          }
        }
      }
    }
    function orthes(n, H, ort, V) {
      let low = 0;
      let high = n - 1;
      let f, g, h, i, j, m;
      let scale;
      for (m = low + 1; m <= high - 1; m++) {
        scale = 0;
        for (i = m; i <= high; i++) {
          scale = scale + Math.abs(H.get(i, m - 1));
        }
        if (scale !== 0) {
          h = 0;
          for (i = high; i >= m; i--) {
            ort[i] = H.get(i, m - 1) / scale;
            h += ort[i] * ort[i];
          }
          g = Math.sqrt(h);
          if (ort[m] > 0) {
            g = -g;
          }
          h = h - ort[m] * g;
          ort[m] = ort[m] - g;
          for (j = m; j < n; j++) {
            f = 0;
            for (i = high; i >= m; i--) {
              f += ort[i] * H.get(i, j);
            }
            f = f / h;
            for (i = m; i <= high; i++) {
              H.set(i, j, H.get(i, j) - f * ort[i]);
            }
          }
          for (i = 0; i <= high; i++) {
            f = 0;
            for (j = high; j >= m; j--) {
              f += ort[j] * H.get(i, j);
            }
            f = f / h;
            for (j = m; j <= high; j++) {
              H.set(i, j, H.get(i, j) - f * ort[j]);
            }
          }
          ort[m] = scale * ort[m];
          H.set(m, m - 1, scale * g);
        }
      }
      for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
          V.set(i, j, i === j ? 1 : 0);
        }
      }
      for (m = high - 1; m >= low + 1; m--) {
        if (H.get(m, m - 1) !== 0) {
          for (i = m + 1; i <= high; i++) {
            ort[i] = H.get(i, m - 1);
          }
          for (j = m; j <= high; j++) {
            g = 0;
            for (i = m; i <= high; i++) {
              g += ort[i] * V.get(i, j);
            }
            g = g / ort[m] / H.get(m, m - 1);
            for (i = m; i <= high; i++) {
              V.set(i, j, V.get(i, j) + g * ort[i]);
            }
          }
        }
      }
    }
    function hqr2(nn, e, d, V, H) {
      let n = nn - 1;
      let low = 0;
      let high = nn - 1;
      let eps = Number.EPSILON;
      let exshift = 0;
      let norm = 0;
      let p = 0;
      let q = 0;
      let r = 0;
      let s = 0;
      let z = 0;
      let iter = 0;
      let i, j, k, l, m, t, w, x, y;
      let ra, sa, vr, vi;
      let notlast, cdivres;
      for (i = 0; i < nn; i++) {
        if (i < low || i > high) {
          d[i] = H.get(i, i);
          e[i] = 0;
        }
        for (j = Math.max(i - 1, 0); j < nn; j++) {
          norm = norm + Math.abs(H.get(i, j));
        }
      }
      while (n >= low) {
        l = n;
        while (l > low) {
          s = Math.abs(H.get(l - 1, l - 1)) + Math.abs(H.get(l, l));
          if (s === 0) {
            s = norm;
          }
          if (Math.abs(H.get(l, l - 1)) < eps * s) {
            break;
          }
          l--;
        }
        if (l === n) {
          H.set(n, n, H.get(n, n) + exshift);
          d[n] = H.get(n, n);
          e[n] = 0;
          n--;
          iter = 0;
        } else if (l === n - 1) {
          w = H.get(n, n - 1) * H.get(n - 1, n);
          p = (H.get(n - 1, n - 1) - H.get(n, n)) / 2;
          q = p * p + w;
          z = Math.sqrt(Math.abs(q));
          H.set(n, n, H.get(n, n) + exshift);
          H.set(n - 1, n - 1, H.get(n - 1, n - 1) + exshift);
          x = H.get(n, n);
          if (q >= 0) {
            z = p >= 0 ? p + z : p - z;
            d[n - 1] = x + z;
            d[n] = d[n - 1];
            if (z !== 0) {
              d[n] = x - w / z;
            }
            e[n - 1] = 0;
            e[n] = 0;
            x = H.get(n, n - 1);
            s = Math.abs(x) + Math.abs(z);
            p = x / s;
            q = z / s;
            r = Math.sqrt(p * p + q * q);
            p = p / r;
            q = q / r;
            for (j = n - 1; j < nn; j++) {
              z = H.get(n - 1, j);
              H.set(n - 1, j, q * z + p * H.get(n, j));
              H.set(n, j, q * H.get(n, j) - p * z);
            }
            for (i = 0; i <= n; i++) {
              z = H.get(i, n - 1);
              H.set(i, n - 1, q * z + p * H.get(i, n));
              H.set(i, n, q * H.get(i, n) - p * z);
            }
            for (i = low; i <= high; i++) {
              z = V.get(i, n - 1);
              V.set(i, n - 1, q * z + p * V.get(i, n));
              V.set(i, n, q * V.get(i, n) - p * z);
            }
          } else {
            d[n - 1] = x + p;
            d[n] = x + p;
            e[n - 1] = z;
            e[n] = -z;
          }
          n = n - 2;
          iter = 0;
        } else {
          x = H.get(n, n);
          y = 0;
          w = 0;
          if (l < n) {
            y = H.get(n - 1, n - 1);
            w = H.get(n, n - 1) * H.get(n - 1, n);
          }
          if (iter === 10) {
            exshift += x;
            for (i = low; i <= n; i++) {
              H.set(i, i, H.get(i, i) - x);
            }
            s = Math.abs(H.get(n, n - 1)) + Math.abs(H.get(n - 1, n - 2));
            x = y = 0.75 * s;
            w = -0.4375 * s * s;
          }
          if (iter === 30) {
            s = (y - x) / 2;
            s = s * s + w;
            if (s > 0) {
              s = Math.sqrt(s);
              if (y < x) {
                s = -s;
              }
              s = x - w / ((y - x) / 2 + s);
              for (i = low; i <= n; i++) {
                H.set(i, i, H.get(i, i) - s);
              }
              exshift += s;
              x = y = w = 0.964;
            }
          }
          iter = iter + 1;
          m = n - 2;
          while (m >= l) {
            z = H.get(m, m);
            r = x - z;
            s = y - z;
            p = (r * s - w) / H.get(m + 1, m) + H.get(m, m + 1);
            q = H.get(m + 1, m + 1) - z - r - s;
            r = H.get(m + 2, m + 1);
            s = Math.abs(p) + Math.abs(q) + Math.abs(r);
            p = p / s;
            q = q / s;
            r = r / s;
            if (m === l) {
              break;
            }
            if (Math.abs(H.get(m, m - 1)) * (Math.abs(q) + Math.abs(r)) < eps * (Math.abs(p) * (Math.abs(H.get(m - 1, m - 1)) + Math.abs(z) + Math.abs(H.get(m + 1, m + 1))))) {
              break;
            }
            m--;
          }
          for (i = m + 2; i <= n; i++) {
            H.set(i, i - 2, 0);
            if (i > m + 2) {
              H.set(i, i - 3, 0);
            }
          }
          for (k = m; k <= n - 1; k++) {
            notlast = k !== n - 1;
            if (k !== m) {
              p = H.get(k, k - 1);
              q = H.get(k + 1, k - 1);
              r = notlast ? H.get(k + 2, k - 1) : 0;
              x = Math.abs(p) + Math.abs(q) + Math.abs(r);
              if (x !== 0) {
                p = p / x;
                q = q / x;
                r = r / x;
              }
            }
            if (x === 0) {
              break;
            }
            s = Math.sqrt(p * p + q * q + r * r);
            if (p < 0) {
              s = -s;
            }
            if (s !== 0) {
              if (k !== m) {
                H.set(k, k - 1, -s * x);
              } else if (l !== m) {
                H.set(k, k - 1, -H.get(k, k - 1));
              }
              p = p + s;
              x = p / s;
              y = q / s;
              z = r / s;
              q = q / p;
              r = r / p;
              for (j = k; j < nn; j++) {
                p = H.get(k, j) + q * H.get(k + 1, j);
                if (notlast) {
                  p = p + r * H.get(k + 2, j);
                  H.set(k + 2, j, H.get(k + 2, j) - p * z);
                }
                H.set(k, j, H.get(k, j) - p * x);
                H.set(k + 1, j, H.get(k + 1, j) - p * y);
              }
              for (i = 0; i <= Math.min(n, k + 3); i++) {
                p = x * H.get(i, k) + y * H.get(i, k + 1);
                if (notlast) {
                  p = p + z * H.get(i, k + 2);
                  H.set(i, k + 2, H.get(i, k + 2) - p * r);
                }
                H.set(i, k, H.get(i, k) - p);
                H.set(i, k + 1, H.get(i, k + 1) - p * q);
              }
              for (i = low; i <= high; i++) {
                p = x * V.get(i, k) + y * V.get(i, k + 1);
                if (notlast) {
                  p = p + z * V.get(i, k + 2);
                  V.set(i, k + 2, V.get(i, k + 2) - p * r);
                }
                V.set(i, k, V.get(i, k) - p);
                V.set(i, k + 1, V.get(i, k + 1) - p * q);
              }
            }
          }
        }
      }
      if (norm === 0) {
        return;
      }
      for (n = nn - 1; n >= 0; n--) {
        p = d[n];
        q = e[n];
        if (q === 0) {
          l = n;
          H.set(n, n, 1);
          for (i = n - 1; i >= 0; i--) {
            w = H.get(i, i) - p;
            r = 0;
            for (j = l; j <= n; j++) {
              r = r + H.get(i, j) * H.get(j, n);
            }
            if (e[i] < 0) {
              z = w;
              s = r;
            } else {
              l = i;
              if (e[i] === 0) {
                H.set(i, n, w !== 0 ? -r / w : -r / (eps * norm));
              } else {
                x = H.get(i, i + 1);
                y = H.get(i + 1, i);
                q = (d[i] - p) * (d[i] - p) + e[i] * e[i];
                t = (x * s - z * r) / q;
                H.set(i, n, t);
                H.set(
                  i + 1,
                  n,
                  Math.abs(x) > Math.abs(z) ? (-r - w * t) / x : (-s - y * t) / z
                );
              }
              t = Math.abs(H.get(i, n));
              if (eps * t * t > 1) {
                for (j = i; j <= n; j++) {
                  H.set(j, n, H.get(j, n) / t);
                }
              }
            }
          }
        } else if (q < 0) {
          l = n - 1;
          if (Math.abs(H.get(n, n - 1)) > Math.abs(H.get(n - 1, n))) {
            H.set(n - 1, n - 1, q / H.get(n, n - 1));
            H.set(n - 1, n, -(H.get(n, n) - p) / H.get(n, n - 1));
          } else {
            cdivres = cdiv(0, -H.get(n - 1, n), H.get(n - 1, n - 1) - p, q);
            H.set(n - 1, n - 1, cdivres[0]);
            H.set(n - 1, n, cdivres[1]);
          }
          H.set(n, n - 1, 0);
          H.set(n, n, 1);
          for (i = n - 2; i >= 0; i--) {
            ra = 0;
            sa = 0;
            for (j = l; j <= n; j++) {
              ra = ra + H.get(i, j) * H.get(j, n - 1);
              sa = sa + H.get(i, j) * H.get(j, n);
            }
            w = H.get(i, i) - p;
            if (e[i] < 0) {
              z = w;
              r = ra;
              s = sa;
            } else {
              l = i;
              if (e[i] === 0) {
                cdivres = cdiv(-ra, -sa, w, q);
                H.set(i, n - 1, cdivres[0]);
                H.set(i, n, cdivres[1]);
              } else {
                x = H.get(i, i + 1);
                y = H.get(i + 1, i);
                vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;
                vi = (d[i] - p) * 2 * q;
                if (vr === 0 && vi === 0) {
                  vr = eps * norm * (Math.abs(w) + Math.abs(q) + Math.abs(x) + Math.abs(y) + Math.abs(z));
                }
                cdivres = cdiv(
                  x * r - z * ra + q * sa,
                  x * s - z * sa - q * ra,
                  vr,
                  vi
                );
                H.set(i, n - 1, cdivres[0]);
                H.set(i, n, cdivres[1]);
                if (Math.abs(x) > Math.abs(z) + Math.abs(q)) {
                  H.set(
                    i + 1,
                    n - 1,
                    (-ra - w * H.get(i, n - 1) + q * H.get(i, n)) / x
                  );
                  H.set(
                    i + 1,
                    n,
                    (-sa - w * H.get(i, n) - q * H.get(i, n - 1)) / x
                  );
                } else {
                  cdivres = cdiv(
                    -r - y * H.get(i, n - 1),
                    -s - y * H.get(i, n),
                    z,
                    q
                  );
                  H.set(i + 1, n - 1, cdivres[0]);
                  H.set(i + 1, n, cdivres[1]);
                }
              }
              t = Math.max(Math.abs(H.get(i, n - 1)), Math.abs(H.get(i, n)));
              if (eps * t * t > 1) {
                for (j = i; j <= n; j++) {
                  H.set(j, n - 1, H.get(j, n - 1) / t);
                  H.set(j, n, H.get(j, n) / t);
                }
              }
            }
          }
        }
      }
      for (i = 0; i < nn; i++) {
        if (i < low || i > high) {
          for (j = i; j < nn; j++) {
            V.set(i, j, H.get(i, j));
          }
        }
      }
      for (j = nn - 1; j >= low; j--) {
        for (i = low; i <= high; i++) {
          z = 0;
          for (k = low; k <= Math.min(j, high); k++) {
            z = z + V.get(i, k) * H.get(k, j);
          }
          V.set(i, j, z);
        }
      }
    }
    function cdiv(xr, xi, yr, yi) {
      let r, d;
      if (Math.abs(yr) > Math.abs(yi)) {
        r = yi / yr;
        d = yr + r * yi;
        return [(xr + r * xi) / d, (xi - r * xr) / d];
      } else {
        r = yr / yi;
        d = yi + r * yr;
        return [(r * xr + xi) / d, (r * xi - xr) / d];
      }
    }
    var CholeskyDecomposition = class {
      constructor(value) {
        value = WrapperMatrix2D.checkMatrix(value);
        if (!value.isSymmetric()) {
          throw new Error("Matrix is not symmetric");
        }
        let a = value;
        let dimension = a.rows;
        let l = new Matrix(dimension, dimension);
        let positiveDefinite = true;
        let i, j, k;
        for (j = 0; j < dimension; j++) {
          let d = 0;
          for (k = 0; k < j; k++) {
            let s = 0;
            for (i = 0; i < k; i++) {
              s += l.get(k, i) * l.get(j, i);
            }
            s = (a.get(j, k) - s) / l.get(k, k);
            l.set(j, k, s);
            d = d + s * s;
          }
          d = a.get(j, j) - d;
          positiveDefinite &= d > 0;
          l.set(j, j, Math.sqrt(Math.max(d, 0)));
          for (k = j + 1; k < dimension; k++) {
            l.set(j, k, 0);
          }
        }
        this.L = l;
        this.positiveDefinite = Boolean(positiveDefinite);
      }
      isPositiveDefinite() {
        return this.positiveDefinite;
      }
      solve(value) {
        value = WrapperMatrix2D.checkMatrix(value);
        let l = this.L;
        let dimension = l.rows;
        if (value.rows !== dimension) {
          throw new Error("Matrix dimensions do not match");
        }
        if (this.isPositiveDefinite() === false) {
          throw new Error("Matrix is not positive definite");
        }
        let count = value.columns;
        let B = value.clone();
        let i, j, k;
        for (k = 0; k < dimension; k++) {
          for (j = 0; j < count; j++) {
            for (i = 0; i < k; i++) {
              B.set(k, j, B.get(k, j) - B.get(i, j) * l.get(k, i));
            }
            B.set(k, j, B.get(k, j) / l.get(k, k));
          }
        }
        for (k = dimension - 1; k >= 0; k--) {
          for (j = 0; j < count; j++) {
            for (i = k + 1; i < dimension; i++) {
              B.set(k, j, B.get(k, j) - B.get(i, j) * l.get(i, k));
            }
            B.set(k, j, B.get(k, j) / l.get(k, k));
          }
        }
        return B;
      }
      get lowerTriangularMatrix() {
        return this.L;
      }
    };
    var nipals = class {
      constructor(X, options = {}) {
        X = WrapperMatrix2D.checkMatrix(X);
        let { Y } = options;
        const {
          scaleScores = false,
          maxIterations = 1e3,
          terminationCriteria = 1e-10
        } = options;
        let u;
        if (Y) {
          if (isAnyArray.isAnyArray(Y) && typeof Y[0] === "number") {
            Y = Matrix.columnVector(Y);
          } else {
            Y = WrapperMatrix2D.checkMatrix(Y);
          }
          if (Y.rows !== X.rows) {
            throw new Error("Y should have the same number of rows as X");
          }
          u = Y.getColumnVector(0);
        } else {
          u = X.getColumnVector(0);
        }
        let diff = 1;
        let t, q, w, tOld;
        for (let counter = 0; counter < maxIterations && diff > terminationCriteria; counter++) {
          w = X.transpose().mmul(u).div(u.transpose().mmul(u).get(0, 0));
          w = w.div(w.norm());
          t = X.mmul(w).div(w.transpose().mmul(w).get(0, 0));
          if (counter > 0) {
            diff = t.clone().sub(tOld).pow(2).sum();
          }
          tOld = t.clone();
          if (Y) {
            q = Y.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));
            q = q.div(q.norm());
            u = Y.mmul(q).div(q.transpose().mmul(q).get(0, 0));
          } else {
            u = t;
          }
        }
        if (Y) {
          let p = X.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));
          p = p.div(p.norm());
          let xResidual = X.clone().sub(t.clone().mmul(p.transpose()));
          let residual = u.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));
          let yResidual = Y.clone().sub(
            t.clone().mulS(residual.get(0, 0)).mmul(q.transpose())
          );
          this.t = t;
          this.p = p.transpose();
          this.w = w.transpose();
          this.q = q;
          this.u = u;
          this.s = t.transpose().mmul(t);
          this.xResidual = xResidual;
          this.yResidual = yResidual;
          this.betas = residual;
        } else {
          this.w = w.transpose();
          this.s = t.transpose().mmul(t).sqrt();
          if (scaleScores) {
            this.t = t.clone().div(this.s.get(0, 0));
          } else {
            this.t = t;
          }
          this.xResidual = X.sub(t.mmul(w.transpose()));
        }
      }
    };
    exports2.AbstractMatrix = AbstractMatrix;
    exports2.CHO = CholeskyDecomposition;
    exports2.CholeskyDecomposition = CholeskyDecomposition;
    exports2.DistanceMatrix = DistanceMatrix;
    exports2.EVD = EigenvalueDecomposition;
    exports2.EigenvalueDecomposition = EigenvalueDecomposition;
    exports2.LU = LuDecomposition;
    exports2.LuDecomposition = LuDecomposition;
    exports2.Matrix = Matrix;
    exports2.MatrixColumnSelectionView = MatrixColumnSelectionView;
    exports2.MatrixColumnView = MatrixColumnView;
    exports2.MatrixFlipColumnView = MatrixFlipColumnView;
    exports2.MatrixFlipRowView = MatrixFlipRowView;
    exports2.MatrixRowSelectionView = MatrixRowSelectionView;
    exports2.MatrixRowView = MatrixRowView;
    exports2.MatrixSelectionView = MatrixSelectionView;
    exports2.MatrixSubView = MatrixSubView;
    exports2.MatrixTransposeView = MatrixTransposeView;
    exports2.NIPALS = nipals;
    exports2.Nipals = nipals;
    exports2.QR = QrDecomposition;
    exports2.QrDecomposition = QrDecomposition;
    exports2.SVD = SingularValueDecomposition;
    exports2.SingularValueDecomposition = SingularValueDecomposition;
    exports2.SymmetricMatrix = SymmetricMatrix;
    exports2.WrapperMatrix1D = WrapperMatrix1D;
    exports2.WrapperMatrix2D = WrapperMatrix2D;
    exports2.correlation = correlation;
    exports2.covariance = covariance;
    exports2.default = Matrix;
    exports2.determinant = determinant;
    exports2.inverse = inverse;
    exports2.linearDependencies = linearDependencies;
    exports2.pseudoInverse = pseudoInverse;
    exports2.solve = solve;
    exports2.wrap = wrap;
  }
});

// node_modules/image-js/lib/image/operator/getSeparatedKernel.js
var require_getSeparatedKernel = __commonJS({
  "node_modules/image-js/lib/image/operator/getSeparatedKernel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = getSeparatedKernel;
    var _mlMatrix = require_matrix();
    function getSeparatedKernel(kernel) {
      const svd = new _mlMatrix.SVD(kernel, {
        autoTranspose: true
      });
      if (svd.rank !== 1)
        return null;
      const s = Math.sqrt(svd.s[0]);
      const v = svd.U.to2DArray().map((v2) => v2[0] * s);
      const h = svd.V.to2DArray().map((h2) => h2[0] * s);
      return [v, h];
    }
  }
});

// node_modules/image-js/lib/image/operator/convolution.js
var require_convolution = __commonJS({
  "node_modules/image-js/lib/image/operator/convolution.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = convolution;
    var _mlMatrixConvolution = require_src5();
    var _channel = require_channel();
    var _kernel = require_kernel();
    var _Image = _interopRequireDefault(require_Image());
    var _clamp = require_clamp();
    var _convolutionSeparable = _interopRequireDefault(require_convolutionSeparable());
    var _getSeparatedKernel = _interopRequireDefault(require_getSeparatedKernel());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function convolution(kernel, options = {}) {
      let {
        channels,
        bitDepth,
        normalize = false,
        divisor = 1,
        border = "copy",
        algorithm = "auto"
      } = options;
      let createOptions = {};
      if (bitDepth)
        createOptions.bitDepth = bitDepth;
      let newImage = _Image.default.createFrom(this, createOptions);
      channels = (0, _channel.validateArrayOfChannels)(this, channels, true);
      if (algorithm !== "separable") {
        ({
          kernel
        } = (0, _kernel.validateKernel)(kernel));
      } else if (!Array.isArray(kernel) || kernel.length !== 2) {
        throw new RangeError("separable convolution requires two arrays of numbers to represent the kernel");
      }
      if (algorithm === "auto") {
        let separatedKernel = (0, _getSeparatedKernel.default)(kernel);
        if (separatedKernel !== null) {
          algorithm = "separable";
          kernel = separatedKernel;
        } else if ((kernel.length > 9 || kernel[0].length > 9) && this.width <= 4096 && this.height <= 4096) {
          algorithm = "fft";
        } else {
          algorithm = "direct";
        }
      }
      let halfHeight, halfWidth;
      if (algorithm === "separable") {
        halfHeight = Math.floor(kernel[0].length / 2);
        halfWidth = Math.floor(kernel[1].length / 2);
      } else {
        halfHeight = Math.floor(kernel.length / 2);
        halfWidth = Math.floor(kernel[0].length / 2);
      }
      let clamped = newImage.isClamped;
      let tmpData = new Array(this.height * this.width);
      let index, x, y, channel, c, tmpResult;
      for (channel = 0; channel < channels.length; channel++) {
        c = channels[channel];
        for (y = 0; y < this.height; y++) {
          for (x = 0; x < this.width; x++) {
            index = y * this.width + x;
            tmpData[index] = this.data[index * this.channels + c];
          }
        }
        if (algorithm === "direct") {
          tmpResult = (0, _mlMatrixConvolution.direct)(tmpData, kernel, {
            rows: this.height,
            cols: this.width,
            normalize,
            divisor
          });
        } else if (algorithm === "separable") {
          tmpResult = (0, _convolutionSeparable.default)(tmpData, kernel, this.width, this.height);
          if (normalize) {
            divisor = 0;
            for (let i = 0; i < kernel[0].length; i++) {
              for (let j = 0; j < kernel[1].length; j++) {
                divisor += kernel[0][i] * kernel[1][j];
              }
            }
          }
          if (divisor !== 1) {
            for (let i = 0; i < tmpResult.length; i++) {
              tmpResult[i] /= divisor;
            }
          }
        } else {
          tmpResult = (0, _mlMatrixConvolution.fft)(tmpData, kernel, {
            rows: this.height,
            cols: this.width,
            normalize,
            divisor
          });
        }
        for (y = 0; y < this.height; y++) {
          for (x = 0; x < this.width; x++) {
            index = y * this.width + x;
            if (clamped) {
              newImage.data[index * this.channels + c] = (0, _clamp.clamp)(tmpResult[index], newImage);
            } else {
              newImage.data[index * this.channels + c] = tmpResult[index];
            }
          }
        }
      }
      if (this.alpha && !channels.includes(this.channels)) {
        for (x = this.components; x < this.data.length; x = x + this.channels) {
          newImage.data[x] = this.data[x];
        }
      }
      if (border !== "periodic") {
        newImage.setBorder({
          size: [halfWidth, halfHeight],
          algorithm: border
        });
      }
      return newImage;
    }
  }
});

// node_modules/image-js/lib/image/filter/gradientFilter.js
var require_gradientFilter = __commonJS({
  "node_modules/image-js/lib/image/filter/gradientFilter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = gradientFilter;
    var _convolution = _interopRequireDefault(require_convolution());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function gradientFilter(options = {}) {
      let {
        direction = "xy",
        border = "copy",
        kernelX,
        kernelY,
        channels,
        bitDepth = this.bitDepth
      } = options;
      this.checkProcessable("gradientFilter", {
        bitDepth: [8, 16]
      });
      switch (direction) {
        case "x":
          if (!kernelX)
            throw new Error("kernelX option is missing");
          return _convolution.default.call(this, kernelX, {
            channels,
            border,
            bitDepth
          });
        case "y":
          if (!kernelY)
            throw new Error("kernelY option is missing");
          return _convolution.default.call(this, kernelY, {
            channels,
            border,
            bitDepth
          });
        case "xy": {
          if (!kernelX)
            throw new Error("kernelX option is missing");
          if (!kernelY)
            throw new Error("kernelY option is missing");
          const gX = _convolution.default.call(this, kernelX, {
            channels,
            border,
            bitDepth: 32
          });
          const gY = _convolution.default.call(this, kernelY, {
            channels,
            border,
            bitDepth: 32
          });
          return gX.hypotenuse(gY, {
            bitDepth,
            channels
          });
        }
        default:
          throw new Error(`Unknown parameter direction: ${direction}`);
      }
    }
  }
});

// node_modules/image-js/lib/image/filter/sobelFilter.js
var require_sobelFilter = __commonJS({
  "node_modules/image-js/lib/image/filter/sobelFilter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = sobelFilter;
    var _kernels = require_kernels();
    var _gradientFilter = _interopRequireDefault(require_gradientFilter());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function sobelFilter(options) {
      return _gradientFilter.default.call(this, Object.assign({}, options, {
        kernelX: _kernels.SOBEL_X,
        kernelY: _kernels.SOBEL_Y
      }));
    }
  }
});

// node_modules/image-js/lib/image/filter/scharrFilter.js
var require_scharrFilter = __commonJS({
  "node_modules/image-js/lib/image/filter/scharrFilter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = scharrFilter;
    var _kernels = require_kernels();
    var _gradientFilter = _interopRequireDefault(require_gradientFilter());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function scharrFilter(options) {
      return _gradientFilter.default.call(this, Object.assign({}, options, {
        kernelX: _kernels.SCHARR_X,
        kernelY: _kernels.SCHARR_Y
      }));
    }
  }
});

// node_modules/new-array/index.js
var require_new_array = __commonJS({
  "node_modules/new-array/index.js"(exports2, module2) {
    module2.exports = newArray;
    function newArray(n, value) {
      n = n || 0;
      var array = new Array(n);
      for (var i = 0; i < n; i++) {
        array[i] = value;
      }
      return array;
    }
  }
});

// node_modules/image-js/lib/image/filter/level.js
var require_level = __commonJS({
  "node_modules/image-js/lib/image/filter/level.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = level;
    var _newArray = _interopRequireDefault(require_new_array());
    var _channel = require_channel();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function level(options = {}) {
      let {
        algorithm = "range",
        channels,
        min = this.min,
        max = this.max
      } = options;
      this.checkProcessable("level", {
        bitDepth: [8, 16, 32]
      });
      channels = (0, _channel.validateArrayOfChannels)(this, {
        channels
      });
      if (channels.length !== this.channel) {
        if (Array.isArray(min) && min.length === this.channels) {
          min = min.filter((a, index) => channels.includes(index));
        }
        if (Array.isArray(max) && max.length === this.channels) {
          max = max.filter((a, index) => channels.includes(index));
        }
      }
      switch (algorithm) {
        case "range":
          if (min < 0) {
            min = 0;
          }
          if (max > this.maxValue) {
            max = this.maxValue;
          }
          if (!Array.isArray(min)) {
            min = (0, _newArray.default)(channels.length, min);
          }
          if (!Array.isArray(max)) {
            max = (0, _newArray.default)(channels.length, max);
          }
          processImage(this, min, max, channels);
          break;
        default:
          throw new Error(`level: algorithm not implement: ${algorithm}`);
      }
      return this;
    }
    function processImage(image, min, max, channels) {
      let delta = 1e-5;
      let factor = new Array(channels.length);
      for (let i = 0; i < channels.length; i++) {
        if (min[i] === 0 && max[i] === image.maxValue) {
          factor[i] = 0;
        } else if (max[i] === min[i]) {
          factor[i] = 0;
        } else {
          factor[i] = (image.maxValue + 1 - delta) / (max[i] - min[i]);
        }
        min[i] += (0.5 - delta / 2) / factor[i];
      }
      for (let j = 0; j < channels.length; j++) {
        let c = channels[j];
        if (factor[j] !== 0) {
          for (let i = 0; i < image.data.length; i += image.channels) {
            image.data[i + c] = Math.min(Math.max(0, (image.data[i + c] - min[j]) * factor[j] + 0.5 | 0), image.maxValue);
          }
        }
      }
    }
  }
});

// node_modules/is-array-type/is-array-type.js
var require_is_array_type = __commonJS({
  "node_modules/is-array-type/is-array-type.js"(exports2, module2) {
    "use strict";
    var toString = Object.prototype.toString;
    module2.exports = function isArrayType(value) {
      return toString.call(value).substr(-6, 5) === "Array";
    };
  }
});

// node_modules/image-js/lib/util/value.js
var require_value = __commonJS({
  "node_modules/image-js/lib/util/value.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.checkNumberArray = checkNumberArray;
    var _isArrayType = _interopRequireDefault(require_is_array_type());
    var _Image = _interopRequireDefault(require_Image());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function checkNumberArray(value) {
      if (!isNaN(value)) {
        if (value <= 0) {
          throw new Error("checkNumberArray: the value must be greater than 0");
        }
        return value;
      } else {
        if (value instanceof _Image.default) {
          return value.data;
        }
        if (!(0, _isArrayType.default)(value)) {
          throw new Error("checkNumberArray: the value should be either a number, array or Image");
        }
        return value;
      }
    }
  }
});

// node_modules/image-js/lib/image/filter/add.js
var require_add = __commonJS({
  "node_modules/image-js/lib/image/filter/add.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = add;
    var _channel = require_channel();
    var _value = require_value();
    function add(value, options = {}) {
      let {
        channels
      } = options;
      this.checkProcessable("add", {
        bitDepth: [8, 16]
      });
      channels = (0, _channel.validateArrayOfChannels)(this, {
        channels
      });
      value = (0, _value.checkNumberArray)(value);
      if (!isNaN(value)) {
        for (let j = 0; j < channels.length; j++) {
          let c = channels[j];
          for (let i = 0; i < this.data.length; i += this.channels) {
            this.data[i + c] = Math.min(this.maxValue, this.data[i + c] + value >> 0);
          }
        }
      } else {
        if (this.data.length !== value.length) {
          throw new Error("add: the data size is different");
        }
        for (let j = 0; j < channels.length; j++) {
          let c = channels[j];
          for (let i = 0; i < this.data.length; i += this.channels) {
            this.data[i + c] = Math.max(0, Math.min(this.maxValue, this.data[i + c] + value[i + c] >> 0));
          }
        }
      }
      return this;
    }
  }
});

// node_modules/image-js/lib/image/filter/subtract.js
var require_subtract = __commonJS({
  "node_modules/image-js/lib/image/filter/subtract.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = subtract;
    var _channel = require_channel();
    var _value = require_value();
    function subtract(value, options = {}) {
      let {
        channels
      } = options;
      this.checkProcessable("subtract", {
        bitDepth: [8, 16]
      });
      channels = (0, _channel.validateArrayOfChannels)(this, {
        channels
      });
      value = (0, _value.checkNumberArray)(value);
      if (!isNaN(value)) {
        for (let j = 0; j < channels.length; j++) {
          let c = channels[j];
          for (let i = 0; i < this.data.length; i += this.channels) {
            this.data[i + c] = Math.max(0, this.data[i + c] - value >> 0);
          }
        }
      } else {
        if (this.data.length !== value.length) {
          throw new Error("subtract: the data size is different");
        }
        for (let j = 0; j < channels.length; j++) {
          let c = channels[j];
          for (let i = 0; i < this.data.length; i += this.channels) {
            this.data[i + c] = Math.max(0, Math.min(this.maxValue, this.data[i + c] - value[i + c] >> 0));
          }
        }
      }
      return this;
    }
  }
});

// node_modules/image-js/lib/image/filter/subtractImage.js
var require_subtractImage = __commonJS({
  "node_modules/image-js/lib/image/filter/subtractImage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = subtractImage;
    var _channel = require_channel();
    function subtractImage(otherImage, options = {}) {
      let {
        channels,
        absolute = false
      } = options;
      this.checkProcessable("subtractImage", {
        bitDepth: [8, 16]
      });
      if (this.width !== otherImage.width || this.height !== otherImage.height) {
        throw new Error("subtractImage: both images must have the same size");
      }
      if (this.alpha !== otherImage.alpha || this.bitDepth !== otherImage.bitDepth) {
        throw new Error("subtractImage: both images must have the same alpha and bitDepth");
      }
      if (this.channels !== otherImage.channels) {
        throw new Error("subtractImage: both images must have the same number of channels");
      }
      let newImage = this.clone();
      channels = (0, _channel.validateArrayOfChannels)(this, {
        channels
      });
      for (let j = 0; j < channels.length; j++) {
        let c = channels[j];
        for (let i = c; i < this.data.length; i += this.channels) {
          let value = this.data[i] - otherImage.data[i];
          if (absolute) {
            newImage.data[i] = Math.abs(value);
          } else {
            newImage.data[i] = Math.max(value, 0);
          }
        }
      }
      return newImage;
    }
  }
});

// node_modules/image-js/lib/image/filter/hypotenuse.js
var require_hypotenuse = __commonJS({
  "node_modules/image-js/lib/image/filter/hypotenuse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = hypotenuse;
    var _channel = require_channel();
    var _Image = _interopRequireDefault(require_Image());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function hypotenuse(otherImage, options = {}) {
      let {
        bitDepth = this.bitDepth,
        channels
      } = options;
      this.checkProcessable("hypotenuse", {
        bitDepth: [8, 16, 32]
      });
      if (this.width !== otherImage.width || this.height !== otherImage.height) {
        throw new Error("hypotenuse: both images must have the same size");
      }
      if (this.alpha !== otherImage.alpha || this.bitDepth !== otherImage.bitDepth) {
        throw new Error("hypotenuse: both images must have the same alpha and bitDepth");
      }
      if (this.channels !== otherImage.channels) {
        throw new Error("hypotenuse: both images must have the same number of channels");
      }
      let newImage = _Image.default.createFrom(this, {
        bitDepth
      });
      channels = (0, _channel.validateArrayOfChannels)(this, {
        channels
      });
      let clamped = newImage.isClamped;
      for (let j = 0; j < channels.length; j++) {
        let c = channels[j];
        for (let i = c; i < this.data.length; i += this.channels) {
          let value = Math.hypot(this.data[i], otherImage.data[i]);
          if (clamped) {
            newImage.data[i] = Math.min(Math.max(Math.round(value), 0), newImage.maxValue);
          } else {
            newImage.data[i] = value;
          }
        }
      }
      return newImage;
    }
  }
});

// node_modules/image-js/lib/image/filter/multiply.js
var require_multiply = __commonJS({
  "node_modules/image-js/lib/image/filter/multiply.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = multiply;
    var _channel = require_channel();
    var _value = require_value();
    function multiply(value, options = {}) {
      let {
        channels
      } = options;
      this.checkProcessable("multiply", {
        bitDepth: [8, 16]
      });
      if (value <= 0) {
        throw new Error("multiply: the value must be greater than 0");
      }
      channels = (0, _channel.validateArrayOfChannels)(this, {
        channels
      });
      value = (0, _value.checkNumberArray)(value);
      if (!isNaN(value)) {
        for (let j = 0; j < channels.length; j++) {
          let c = channels[j];
          for (let i = 0; i < this.data.length; i += this.channels) {
            this.data[i + c] = Math.min(this.maxValue, this.data[i + c] * value >> 0);
          }
        }
      } else {
        if (this.data.length !== value.length) {
          throw new Error("multiply: the data size is different");
        }
        for (let j = 0; j < channels.length; j++) {
          let c = channels[j];
          for (let i = 0; i < this.data.length; i += this.channels) {
            this.data[i + c] = Math.max(0, Math.min(this.maxValue, this.data[i + c] * value[i + c] >> 0));
          }
        }
      }
      return this;
    }
  }
});

// node_modules/image-js/lib/image/filter/divide.js
var require_divide = __commonJS({
  "node_modules/image-js/lib/image/filter/divide.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = divide;
    var _channel = require_channel();
    var _value = require_value();
    function divide(value, options = {}) {
      let {
        channels
      } = options;
      this.checkProcessable("divide", {
        bitDepth: [8, 16]
      });
      channels = (0, _channel.validateArrayOfChannels)(this, {
        channels
      });
      value = (0, _value.checkNumberArray)(value);
      if (!isNaN(value)) {
        for (let j = 0; j < channels.length; j++) {
          let c = channels[j];
          for (let i = 0; i < this.data.length; i += this.channels) {
            this.data[i + c] = Math.min(this.maxValue, this.data[i + c] / value >> 0);
          }
        }
      } else {
        if (this.data.length !== value.length) {
          throw new Error("divide: the: the data size is different");
        }
        for (let j = 0; j < channels.length; j++) {
          let c = channels[j];
          for (let i = 0; i < this.data.length; i += this.channels) {
            this.data[i + c] = Math.max(0, Math.min(this.maxValue, this.data[i + c] / value[i + c] >> 0));
          }
        }
      }
      return this;
    }
  }
});

// node_modules/ml-regression-base/lib/index.js
var require_lib8 = __commonJS({
  "node_modules/ml-regression-base/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var isAnyArray = require_lib4();
    function maybeToPrecision(value, digits) {
      if (value < 0) {
        value = 0 - value;
        if (typeof digits === "number") {
          return `- ${value.toPrecision(digits)}`;
        } else {
          return `- ${value.toString()}`;
        }
      } else {
        if (typeof digits === "number") {
          return value.toPrecision(digits);
        } else {
          return value.toString();
        }
      }
    }
    function checkArraySize(x, y) {
      if (!isAnyArray.isAnyArray(x) || !isAnyArray.isAnyArray(y)) {
        throw new TypeError("x and y must be arrays");
      }
      if (x.length !== y.length) {
        throw new RangeError("x and y arrays must have the same length");
      }
    }
    var BaseRegression = class {
      constructor() {
        if (new.target === BaseRegression) {
          throw new Error("BaseRegression must be subclassed");
        }
      }
      predict(x) {
        if (typeof x === "number") {
          return this._predict(x);
        } else if (isAnyArray.isAnyArray(x)) {
          const y = [];
          for (let i = 0; i < x.length; i++) {
            y.push(this._predict(x[i]));
          }
          return y;
        } else {
          throw new TypeError("x must be a number or array");
        }
      }
      _predict() {
        throw new Error("_predict must be implemented");
      }
      train() {
      }
      toString() {
        return "";
      }
      toLaTeX() {
        return "";
      }
      /**
       * Return the correlation coefficient of determination (r) and chi-square.
       * @param {Array<number>} x
       * @param {Array<number>} y
       * @return {object}
       */
      score(x, y) {
        if (!isAnyArray.isAnyArray(x) || !isAnyArray.isAnyArray(y) || x.length !== y.length) {
          throw new Error("x and y must be arrays of the same length");
        }
        const n = x.length;
        const y2 = new Array(n);
        for (let i = 0; i < n; i++) {
          y2[i] = this._predict(x[i]);
        }
        let xSum = 0;
        let ySum = 0;
        let chi2 = 0;
        let rmsd = 0;
        let xSquared = 0;
        let ySquared = 0;
        let xY = 0;
        for (let i = 0; i < n; i++) {
          xSum += y2[i];
          ySum += y[i];
          xSquared += y2[i] * y2[i];
          ySquared += y[i] * y[i];
          xY += y2[i] * y[i];
          if (y[i] !== 0) {
            chi2 += (y[i] - y2[i]) * (y[i] - y2[i]) / y[i];
          }
          rmsd += (y[i] - y2[i]) * (y[i] - y2[i]);
        }
        const r = (n * xY - xSum * ySum) / Math.sqrt((n * xSquared - xSum * xSum) * (n * ySquared - ySum * ySum));
        return {
          r,
          r2: r * r,
          chi2,
          rmsd: Math.sqrt(rmsd / n)
        };
      }
    };
    exports2.checkArrayLength = checkArraySize;
    exports2["default"] = BaseRegression;
    exports2.maybeToPrecision = maybeToPrecision;
  }
});

// node_modules/ml-regression-polynomial/lib/index.js
var require_lib9 = __commonJS({
  "node_modules/ml-regression-polynomial/lib/index.js"(exports2, module2) {
    "use strict";
    var mlMatrix = require_matrix();
    var BaseRegression = require_lib8();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var BaseRegression__default = /* @__PURE__ */ _interopDefaultLegacy(BaseRegression);
    var PolynomialRegression = class extends BaseRegression__default["default"] {
      constructor(x, y, degree) {
        super();
        if (x === true) {
          this.degree = y.degree;
          this.powers = y.powers;
          this.coefficients = y.coefficients;
        } else {
          BaseRegression.checkArrayLength(x, y);
          regress(this, x, y, degree);
        }
      }
      _predict(x) {
        let y = 0;
        for (let k = 0; k < this.powers.length; k++) {
          y += this.coefficients[k] * Math.pow(x, this.powers[k]);
        }
        return y;
      }
      toJSON() {
        return {
          name: "polynomialRegression",
          degree: this.degree,
          powers: this.powers,
          coefficients: this.coefficients
        };
      }
      toString(precision) {
        return this._toFormula(precision, false);
      }
      toLaTeX(precision) {
        return this._toFormula(precision, true);
      }
      _toFormula(precision, isLaTeX) {
        let sup = "^";
        let closeSup = "";
        let times = " * ";
        if (isLaTeX) {
          sup = "^{";
          closeSup = "}";
          times = "";
        }
        let fn = "";
        let str = "";
        for (let k = 0; k < this.coefficients.length; k++) {
          str = "";
          if (this.coefficients[k] !== 0) {
            if (this.powers[k] === 0) {
              str = BaseRegression.maybeToPrecision(this.coefficients[k], precision);
            } else {
              if (this.powers[k] === 1) {
                str = `${BaseRegression.maybeToPrecision(this.coefficients[k], precision) + times}x`;
              } else {
                str = `${BaseRegression.maybeToPrecision(this.coefficients[k], precision) + times}x${sup}${this.powers[k]}${closeSup}`;
              }
            }
            if (this.coefficients[k] > 0 && k !== this.coefficients.length - 1) {
              str = ` + ${str}`;
            } else if (k !== this.coefficients.length - 1) {
              str = ` ${str}`;
            }
          }
          fn = str + fn;
        }
        if (fn.charAt(0) === "+") {
          fn = fn.slice(1);
        }
        return `f(x) = ${fn}`;
      }
      static load(json) {
        if (json.name !== "polynomialRegression") {
          throw new TypeError("not a polynomial regression model");
        }
        return new PolynomialRegression(true, json);
      }
    };
    function regress(pr, x, y, degree) {
      const n = x.length;
      let powers;
      if (Array.isArray(degree)) {
        powers = degree;
        degree = powers.length;
      } else {
        degree++;
        powers = new Array(degree);
        for (let k = 0; k < degree; k++) {
          powers[k] = k;
        }
      }
      const F = new mlMatrix.Matrix(n, degree);
      const Y = new mlMatrix.Matrix([y]);
      for (let k = 0; k < degree; k++) {
        for (let i = 0; i < n; i++) {
          if (powers[k] === 0) {
            F.set(i, k, 1);
          } else {
            F.set(i, k, Math.pow(x[i], powers[k]));
          }
        }
      }
      const FT = new mlMatrix.MatrixTransposeView(F);
      const A = FT.mmul(F);
      const B = FT.mmul(new mlMatrix.MatrixTransposeView(Y));
      pr.degree = degree - 1;
      pr.powers = powers;
      pr.coefficients = mlMatrix.solve(A, B).to1DArray();
    }
    module2.exports = PolynomialRegression;
  }
});

// node_modules/ml-regression-simple-linear/lib/index.js
var require_lib10 = __commonJS({
  "node_modules/ml-regression-simple-linear/lib/index.js"(exports2, module2) {
    "use strict";
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var BaseRegression = require_lib8();
    var BaseRegression__default = _interopDefault(BaseRegression);
    var SimpleLinearRegression = class extends BaseRegression__default {
      constructor(x, y) {
        super();
        if (x === true) {
          this.slope = y.slope;
          this.intercept = y.intercept;
          this.coefficients = [y.intercept, y.slope];
        } else {
          BaseRegression.checkArrayLength(x, y);
          regress(this, x, y);
        }
      }
      toJSON() {
        return {
          name: "simpleLinearRegression",
          slope: this.slope,
          intercept: this.intercept
        };
      }
      _predict(x) {
        return this.slope * x + this.intercept;
      }
      computeX(y) {
        return (y - this.intercept) / this.slope;
      }
      toString(precision) {
        let result = "f(x) = ";
        if (this.slope !== 0) {
          const xFactor = BaseRegression.maybeToPrecision(this.slope, precision);
          result += `${xFactor === "1" ? "" : `${xFactor} * `}x`;
          if (this.intercept !== 0) {
            const absIntercept = Math.abs(this.intercept);
            const operator = absIntercept === this.intercept ? "+" : "-";
            result += ` ${operator} ${BaseRegression.maybeToPrecision(absIntercept, precision)}`;
          }
        } else {
          result += BaseRegression.maybeToPrecision(this.intercept, precision);
        }
        return result;
      }
      toLaTeX(precision) {
        return this.toString(precision);
      }
      static load(json) {
        if (json.name !== "simpleLinearRegression") {
          throw new TypeError("not a SLR model");
        }
        return new SimpleLinearRegression(true, json);
      }
    };
    function regress(slr, x, y) {
      const n = x.length;
      let xSum = 0;
      let ySum = 0;
      let xSquared = 0;
      let xY = 0;
      for (let i = 0; i < n; i++) {
        xSum += x[i];
        ySum += y[i];
        xSquared += x[i] * x[i];
        xY += x[i] * y[i];
      }
      const numerator = n * xY - xSum * ySum;
      slr.slope = numerator / (n * xSquared - xSum * xSum);
      slr.intercept = 1 / n * ySum - slr.slope * (1 / n) * xSum;
      slr.coefficients = [slr.intercept, slr.slope];
    }
    module2.exports = SimpleLinearRegression;
  }
});

// node_modules/ml-regression-exponential/lib/index.js
var require_lib11 = __commonJS({
  "node_modules/ml-regression-exponential/lib/index.js"(exports2, module2) {
    "use strict";
    var BaseRegression = require_lib8();
    var SimpleLinearRegression = require_lib10();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var BaseRegression__default = /* @__PURE__ */ _interopDefaultLegacy(BaseRegression);
    var SimpleLinearRegression__default = /* @__PURE__ */ _interopDefaultLegacy(SimpleLinearRegression);
    var ExponentialRegression = class extends BaseRegression__default["default"] {
      constructor(x, y) {
        super();
        if (x === true) {
          this.A = y.A;
          this.B = y.B;
        } else {
          BaseRegression.checkArrayLength(x, y);
          regress(this, x, y);
        }
      }
      _predict(input) {
        return this.B * Math.exp(input * this.A);
      }
      toJSON() {
        return {
          name: "exponentialRegression",
          A: this.A,
          B: this.B
        };
      }
      toString(precision) {
        return `f(x) = ${BaseRegression.maybeToPrecision(
          this.B,
          precision
        )} * e^(${BaseRegression.maybeToPrecision(this.A, precision)} * x)`;
      }
      toLaTeX(precision) {
        if (this.A >= 0) {
          return `f(x) = ${BaseRegression.maybeToPrecision(
            this.B,
            precision
          )}e^{${BaseRegression.maybeToPrecision(this.A, precision)}x}`;
        } else {
          return `f(x) = \\frac{${BaseRegression.maybeToPrecision(
            this.B,
            precision
          )}}{e^{${BaseRegression.maybeToPrecision(-this.A, precision)}x}}`;
        }
      }
      static load(json) {
        if (json.name !== "exponentialRegression") {
          throw new TypeError("not a exponential regression model");
        }
        return new ExponentialRegression(true, json);
      }
    };
    function regress(er, x, y) {
      const n = x.length;
      const yl = new Array(n);
      for (let i = 0; i < n; i++) {
        yl[i] = Math.log(y[i]);
      }
      const linear = new SimpleLinearRegression__default["default"](x, yl);
      er.A = linear.slope;
      er.B = Math.exp(linear.intercept);
    }
    module2.exports = ExponentialRegression;
  }
});

// node_modules/ml-regression-power/lib/index.js
var require_lib12 = __commonJS({
  "node_modules/ml-regression-power/lib/index.js"(exports2, module2) {
    "use strict";
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var BaseRegression = require_lib8();
    var BaseRegression__default = _interopDefault(BaseRegression);
    var SimpleLinearRegression = _interopDefault(require_lib10());
    var PowerRegression = class extends BaseRegression__default {
      constructor(x, y) {
        super();
        if (x === true) {
          this.A = y.A;
          this.B = y.B;
        } else {
          BaseRegression.checkArrayLength(x, y);
          regress(this, x, y);
        }
      }
      _predict(newInputs) {
        return this.A * Math.pow(newInputs, this.B);
      }
      toJSON() {
        return {
          name: "powerRegression",
          A: this.A,
          B: this.B
        };
      }
      toString(precision) {
        return `f(x) = ${BaseRegression.maybeToPrecision(
          this.A,
          precision
        )} * x^${BaseRegression.maybeToPrecision(this.B, precision)}`;
      }
      toLaTeX(precision) {
        let latex = "";
        if (this.B >= 0) {
          latex = `f(x) = ${BaseRegression.maybeToPrecision(
            this.A,
            precision
          )}x^{${BaseRegression.maybeToPrecision(this.B, precision)}}`;
        } else {
          latex = `f(x) = \\frac{${BaseRegression.maybeToPrecision(
            this.A,
            precision
          )}}{x^{${BaseRegression.maybeToPrecision(-this.B, precision)}}}`;
        }
        latex = latex.replace(/e([+-]?[0-9]+)/g, "e^{$1}");
        return latex;
      }
      static load(json) {
        if (json.name !== "powerRegression") {
          throw new TypeError("not a power regression model");
        }
        return new PowerRegression(true, json);
      }
    };
    function regress(pr, x, y) {
      const n = x.length;
      const xl = new Array(n);
      const yl = new Array(n);
      for (let i = 0; i < n; i++) {
        xl[i] = Math.log(x[i]);
        yl[i] = Math.log(y[i]);
      }
      const linear = new SimpleLinearRegression(xl, yl);
      pr.A = Math.exp(linear.intercept);
      pr.B = linear.slope;
    }
    module2.exports = PowerRegression;
  }
});

// node_modules/ml-regression-multivariate-linear/lib/index.js
var require_lib13 = __commonJS({
  "node_modules/ml-regression-multivariate-linear/lib/index.js"(exports2, module2) {
    "use strict";
    var mlMatrix = require_matrix();
    var MultivariateLinearRegression = class {
      constructor(x, y, options = {}) {
        const { intercept = true, statistics = true } = options;
        this.statistics = statistics;
        if (x === true) {
          this.weights = y.weights;
          this.inputs = y.inputs;
          this.outputs = y.outputs;
          this.intercept = y.intercept;
        } else {
          x = new mlMatrix.Matrix(x);
          y = new mlMatrix.Matrix(y);
          if (intercept) {
            x.addColumn(new Array(x.rows).fill(1));
          }
          let xt = x.transpose();
          const xx = xt.mmul(x);
          const xy = xt.mmul(y);
          const invxx = new mlMatrix.SVD(xx).inverse();
          const beta = xy.transpose().mmul(invxx).transpose();
          this.weights = beta.to2DArray();
          this.inputs = x.columns;
          this.outputs = y.columns;
          if (intercept)
            this.inputs--;
          this.intercept = intercept;
          if (statistics) {
            const fittedValues = x.mmul(beta);
            const residuals = y.clone().addM(fittedValues.neg());
            const variance = residuals.to2DArray().map((ri) => Math.pow(ri[0], 2)).reduce((a, b) => a + b) / (y.rows - x.columns);
            this.stdError = Math.sqrt(variance);
            this.stdErrorMatrix = mlMatrix.pseudoInverse(xx).mul(variance);
            this.stdErrors = this.stdErrorMatrix.diagonal().map((d) => Math.sqrt(d));
            this.tStats = this.weights.map(
              (d, i) => this.stdErrors[i] === 0 ? 0 : d[0] / this.stdErrors[i]
            );
          }
        }
      }
      predict(x) {
        if (Array.isArray(x)) {
          if (typeof x[0] === "number") {
            return this._predict(x);
          } else if (Array.isArray(x[0])) {
            const y = new Array(x.length);
            for (let i = 0; i < x.length; i++) {
              y[i] = this._predict(x[i]);
            }
            return y;
          }
        } else if (mlMatrix.Matrix.isMatrix(x)) {
          const y = new mlMatrix.Matrix(x.rows, this.outputs);
          for (let i = 0; i < x.rows; i++) {
            y.setRow(i, this._predict(x.getRow(i)));
          }
          return y;
        }
        throw new TypeError("x must be a matrix or array of numbers");
      }
      _predict(x) {
        const result = new Array(this.outputs);
        if (this.intercept) {
          for (let i = 0; i < this.outputs; i++) {
            result[i] = this.weights[this.inputs][i];
          }
        } else {
          result.fill(0);
        }
        for (let i = 0; i < this.inputs; i++) {
          for (let j = 0; j < this.outputs; j++) {
            result[j] += this.weights[i][j] * x[i];
          }
        }
        return result;
      }
      score() {
        throw new Error("score method is not implemented yet");
      }
      toJSON() {
        return {
          name: "multivariateLinearRegression",
          weights: this.weights,
          inputs: this.inputs,
          outputs: this.outputs,
          intercept: this.intercept,
          summary: this.statistics ? {
            regressionStatistics: {
              standardError: this.stdError,
              observations: this.outputs
            },
            variables: this.weights.map((d, i) => {
              return {
                label: i === this.weights.length - 1 ? "Intercept" : `X Variable ${i + 1}`,
                coefficients: d,
                standardError: this.stdErrors[i],
                tStat: this.tStats[i]
              };
            })
          } : void 0
        };
      }
      static load(model) {
        if (model.name !== "multivariateLinearRegression") {
          throw new Error("not a MLR model");
        }
        return new MultivariateLinearRegression(true, model);
      }
    };
    module2.exports = MultivariateLinearRegression;
  }
});

// node_modules/ml-distance-euclidean/lib/euclidean.js
var require_euclidean = __commonJS({
  "node_modules/ml-distance-euclidean/lib/euclidean.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function squaredEuclidean(p, q) {
      let d = 0;
      for (let i = 0; i < p.length; i++) {
        d += (p[i] - q[i]) * (p[i] - q[i]);
      }
      return d;
    }
    exports2.squaredEuclidean = squaredEuclidean;
    function euclidean(p, q) {
      return Math.sqrt(squaredEuclidean(p, q));
    }
    exports2.euclidean = euclidean;
  }
});

// node_modules/ml-kernel-gaussian/gaussian-kernel.js
var require_gaussian_kernel = __commonJS({
  "node_modules/ml-kernel-gaussian/gaussian-kernel.js"(exports2, module2) {
    "use strict";
    var { squaredEuclidean } = require_euclidean();
    var defaultOptions = {
      sigma: 1
    };
    var GaussianKernel = class {
      constructor(options) {
        options = Object.assign({}, defaultOptions, options);
        this.sigma = options.sigma;
        this.divisor = 2 * options.sigma * options.sigma;
      }
      compute(x, y) {
        const distance = squaredEuclidean(x, y);
        return Math.exp(-distance / this.divisor);
      }
    };
    module2.exports = GaussianKernel;
  }
});

// node_modules/ml-kernel-polynomial/polynomial-kernel.js
var require_polynomial_kernel = __commonJS({
  "node_modules/ml-kernel-polynomial/polynomial-kernel.js"(exports2, module2) {
    "use strict";
    var defaultOptions = {
      degree: 1,
      constant: 1,
      scale: 1
    };
    var PolynomialKernel = class {
      constructor(options) {
        options = Object.assign({}, defaultOptions, options);
        this.degree = options.degree;
        this.constant = options.constant;
        this.scale = options.scale;
      }
      compute(x, y) {
        var sum = 0;
        for (var i = 0; i < x.length; i++) {
          sum += x[i] * y[i];
        }
        return Math.pow(this.scale * sum + this.constant, this.degree);
      }
    };
    module2.exports = PolynomialKernel;
  }
});

// node_modules/ml-kernel-sigmoid/sigmoid-kernel.js
var require_sigmoid_kernel = __commonJS({
  "node_modules/ml-kernel-sigmoid/sigmoid-kernel.js"(exports2, module2) {
    "use strict";
    var defaultOptions = {
      alpha: 0.01,
      constant: -Math.E
    };
    var SigmoidKernel = class {
      constructor(options) {
        options = Object.assign({}, defaultOptions, options);
        this.alpha = options.alpha;
        this.constant = options.constant;
      }
      compute(x, y) {
        var sum = 0;
        for (var i = 0; i < x.length; i++) {
          sum += x[i] * y[i];
        }
        return Math.tanh(this.alpha * sum + this.constant);
      }
    };
    module2.exports = SigmoidKernel;
  }
});

// node_modules/ml-kernel/src/kernels/anova-kernel.js
var require_anova_kernel = __commonJS({
  "node_modules/ml-kernel/src/kernels/anova-kernel.js"(exports2, module2) {
    "use strict";
    var defaultOptions = {
      sigma: 1,
      degree: 1
    };
    var ANOVAKernel = class {
      constructor(options) {
        options = Object.assign({}, defaultOptions, options);
        this.sigma = options.sigma;
        this.degree = options.degree;
      }
      compute(x, y) {
        var sum = 0;
        var len = Math.min(x.length, y.length);
        for (var i = 1; i <= len; ++i) {
          sum += Math.pow(
            Math.exp(
              -this.sigma * Math.pow(Math.pow(x[i - 1], i) - Math.pow(y[i - 1], i), 2)
            ),
            this.degree
          );
        }
        return sum;
      }
    };
    module2.exports = ANOVAKernel;
  }
});

// node_modules/ml-kernel/src/kernels/cauchy-kernel.js
var require_cauchy_kernel = __commonJS({
  "node_modules/ml-kernel/src/kernels/cauchy-kernel.js"(exports2, module2) {
    "use strict";
    var { squaredEuclidean } = require_euclidean();
    var defaultOptions = {
      sigma: 1
    };
    var CauchyKernel = class {
      constructor(options) {
        options = Object.assign({}, defaultOptions, options);
        this.sigma = options.sigma;
      }
      compute(x, y) {
        return 1 / (1 + squaredEuclidean(x, y) / (this.sigma * this.sigma));
      }
    };
    module2.exports = CauchyKernel;
  }
});

// node_modules/ml-kernel/src/kernels/exponential-kernel.js
var require_exponential_kernel = __commonJS({
  "node_modules/ml-kernel/src/kernels/exponential-kernel.js"(exports2, module2) {
    "use strict";
    var { euclidean } = require_euclidean();
    var defaultOptions = {
      sigma: 1
    };
    var ExponentialKernel = class {
      constructor(options) {
        options = Object.assign({}, defaultOptions, options);
        this.sigma = options.sigma;
        this.divisor = 2 * options.sigma * options.sigma;
      }
      compute(x, y) {
        const distance = euclidean(x, y);
        return Math.exp(-distance / this.divisor);
      }
    };
    module2.exports = ExponentialKernel;
  }
});

// node_modules/ml-kernel/src/kernels/histogram-intersection-kernel.js
var require_histogram_intersection_kernel = __commonJS({
  "node_modules/ml-kernel/src/kernels/histogram-intersection-kernel.js"(exports2, module2) {
    "use strict";
    var HistogramIntersectionKernel = class {
      compute(x, y) {
        var min = Math.min(x.length, y.length);
        var sum = 0;
        for (var i = 0; i < min; ++i) {
          sum += Math.min(x[i], y[i]);
        }
        return sum;
      }
    };
    module2.exports = HistogramIntersectionKernel;
  }
});

// node_modules/ml-kernel/src/kernels/laplacian-kernel.js
var require_laplacian_kernel = __commonJS({
  "node_modules/ml-kernel/src/kernels/laplacian-kernel.js"(exports2, module2) {
    "use strict";
    var { euclidean } = require_euclidean();
    var defaultOptions = {
      sigma: 1
    };
    var LaplacianKernel = class {
      constructor(options) {
        options = Object.assign({}, defaultOptions, options);
        this.sigma = options.sigma;
      }
      compute(x, y) {
        const distance = euclidean(x, y);
        return Math.exp(-distance / this.sigma);
      }
    };
    module2.exports = LaplacianKernel;
  }
});

// node_modules/ml-kernel/src/kernels/multiquadratic-kernel.js
var require_multiquadratic_kernel = __commonJS({
  "node_modules/ml-kernel/src/kernels/multiquadratic-kernel.js"(exports2, module2) {
    "use strict";
    var { squaredEuclidean } = require_euclidean();
    var defaultOptions = {
      constant: 1
    };
    var MultiquadraticKernel = class {
      constructor(options) {
        options = Object.assign({}, defaultOptions, options);
        this.constant = options.constant;
      }
      compute(x, y) {
        return Math.sqrt(squaredEuclidean(x, y) + this.constant * this.constant);
      }
    };
    module2.exports = MultiquadraticKernel;
  }
});

// node_modules/ml-kernel/src/kernels/rational-quadratic-kernel.js
var require_rational_quadratic_kernel = __commonJS({
  "node_modules/ml-kernel/src/kernels/rational-quadratic-kernel.js"(exports2, module2) {
    "use strict";
    var { squaredEuclidean } = require_euclidean();
    var defaultOptions = {
      constant: 1
    };
    var RationalQuadraticKernel = class {
      constructor(options) {
        options = Object.assign({}, defaultOptions, options);
        this.constant = options.constant;
      }
      compute(x, y) {
        const distance = squaredEuclidean(x, y);
        return 1 - distance / (distance + this.constant);
      }
    };
    module2.exports = RationalQuadraticKernel;
  }
});

// node_modules/ml-kernel/src/kernel.js
var require_kernel2 = __commonJS({
  "node_modules/ml-kernel/src/kernel.js"(exports2, module2) {
    "use strict";
    var { Matrix, MatrixTransposeView } = require_matrix();
    var GaussianKernel = require_gaussian_kernel();
    var PolynomialKernel = require_polynomial_kernel();
    var SigmoidKernel = require_sigmoid_kernel();
    var ANOVAKernel = require_anova_kernel();
    var CauchyKernel = require_cauchy_kernel();
    var ExponentialKernel = require_exponential_kernel();
    var HistogramKernel = require_histogram_intersection_kernel();
    var LaplacianKernel = require_laplacian_kernel();
    var MultiquadraticKernel = require_multiquadratic_kernel();
    var RationalKernel = require_rational_quadratic_kernel();
    var kernelType = {
      gaussian: GaussianKernel,
      rbf: GaussianKernel,
      polynomial: PolynomialKernel,
      poly: PolynomialKernel,
      anova: ANOVAKernel,
      cauchy: CauchyKernel,
      exponential: ExponentialKernel,
      histogram: HistogramKernel,
      min: HistogramKernel,
      laplacian: LaplacianKernel,
      multiquadratic: MultiquadraticKernel,
      rational: RationalKernel,
      sigmoid: SigmoidKernel,
      mlp: SigmoidKernel
    };
    var Kernel = class {
      constructor(type, options) {
        this.kernelType = type;
        if (type === "linear")
          return;
        if (typeof type === "string") {
          type = type.toLowerCase();
          var KernelConstructor = kernelType[type];
          if (KernelConstructor) {
            this.kernelFunction = new KernelConstructor(options);
          } else {
            throw new Error(`unsupported kernel type: ${type}`);
          }
        } else if (typeof type === "object" && typeof type.compute === "function") {
          this.kernelFunction = type;
        } else {
          throw new TypeError(
            "first argument must be a valid kernel type or instance"
          );
        }
      }
      compute(inputs, landmarks) {
        inputs = Matrix.checkMatrix(inputs);
        if (landmarks === void 0) {
          landmarks = inputs;
        } else {
          landmarks = Matrix.checkMatrix(landmarks);
        }
        if (this.kernelType === "linear") {
          return inputs.mmul(new MatrixTransposeView(landmarks));
        }
        const kernelMatrix = new Matrix(inputs.rows, landmarks.rows);
        if (inputs === landmarks) {
          for (let i = 0; i < inputs.rows; i++) {
            for (let j = i; j < inputs.rows; j++) {
              const value = this.kernelFunction.compute(
                inputs.getRow(i),
                inputs.getRow(j)
              );
              kernelMatrix.set(i, j, value);
              kernelMatrix.set(j, i, value);
            }
          }
        } else {
          for (let i = 0; i < inputs.rows; i++) {
            for (let j = 0; j < landmarks.rows; j++) {
              kernelMatrix.set(
                i,
                j,
                this.kernelFunction.compute(inputs.getRow(i), landmarks.getRow(j))
              );
            }
          }
        }
        return kernelMatrix;
      }
    };
    module2.exports = Kernel;
  }
});

// node_modules/ml-array-median/lib/index.js
var require_lib14 = __commonJS({
  "node_modules/ml-array-median/lib/index.js"(exports2, module2) {
    "use strict";
    var isAnyArray = require_lib4();
    var quickSelectMedian = require_median_quickselect_min();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var quickSelectMedian__default = /* @__PURE__ */ _interopDefaultLegacy(quickSelectMedian);
    function median(input) {
      if (!isAnyArray.isAnyArray(input)) {
        throw new TypeError("input must be an array");
      }
      if (input.length === 0) {
        throw new TypeError("input must not be empty");
      }
      return quickSelectMedian__default["default"](input.slice());
    }
    module2.exports = median;
  }
});

// node_modules/ml-regression-theil-sen/lib/index.js
var require_lib15 = __commonJS({
  "node_modules/ml-regression-theil-sen/lib/index.js"(exports2, module2) {
    "use strict";
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var BaseRegression = require_lib8();
    var BaseRegression__default = _interopDefault(BaseRegression);
    var median = _interopDefault(require_lib14());
    var TheilSenRegression = class extends BaseRegression__default {
      /**
       * TheilSen estimator
       * https://en.wikipedia.org/wiki/Theil%E2%80%93Sen_estimator
       * @param {Array<number>|boolean} x
       * @param {Array<number>|object} y
       * @constructor
       */
      constructor(x, y) {
        super();
        if (x === true) {
          this.slope = y.slope;
          this.intercept = y.intercept;
          this.coefficients = y.coefficients;
        } else {
          BaseRegression.checkArrayLength(x, y);
          theilSen(this, x, y);
        }
      }
      toJSON() {
        return {
          name: "TheilSenRegression",
          slope: this.slope,
          intercept: this.intercept
        };
      }
      _predict(input) {
        return this.slope * input + this.intercept;
      }
      computeX(input) {
        return (input - this.intercept) / this.slope;
      }
      toString(precision) {
        var result = "f(x) = ";
        if (this.slope) {
          var xFactor = BaseRegression.maybeToPrecision(this.slope, precision);
          result += `${Math.abs(xFactor - 1) < 1e-5 ? "" : `${xFactor} * `}x`;
          if (this.intercept) {
            var absIntercept = Math.abs(this.intercept);
            var operator = absIntercept === this.intercept ? "+" : "-";
            result += ` ${operator} ${BaseRegression.maybeToPrecision(absIntercept, precision)}`;
          }
        } else {
          result += BaseRegression.maybeToPrecision(this.intercept, precision);
        }
        return result;
      }
      toLaTeX(precision) {
        return this.toString(precision);
      }
      static load(json) {
        if (json.name !== "TheilSenRegression") {
          throw new TypeError("not a Theil-Sen model");
        }
        return new TheilSenRegression(true, json);
      }
    };
    function theilSen(regression, x, y) {
      let len = x.length;
      let slopes = new Array(len * len);
      let count = 0;
      for (let i = 0; i < len; ++i) {
        for (let j = i + 1; j < len; ++j) {
          if (x[i] !== x[j]) {
            slopes[count++] = (y[j] - y[i]) / (x[j] - x[i]);
          }
        }
      }
      slopes.length = count;
      let medianSlope = median(slopes);
      let cuts = new Array(len);
      for (let i = 0; i < len; ++i) {
        cuts[i] = y[i] - medianSlope * x[i];
      }
      regression.slope = medianSlope;
      regression.intercept = median(cuts);
      regression.coefficients = [regression.intercept, regression.slope];
    }
    module2.exports = TheilSenRegression;
  }
});

// node_modules/ml-regression-robust-polynomial/lib/index.js
var require_lib16 = __commonJS({
  "node_modules/ml-regression-robust-polynomial/lib/index.js"(exports2, module2) {
    "use strict";
    var mlMatrix = require_matrix();
    var BaseRegression = require_lib8();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var BaseRegression__default = /* @__PURE__ */ _interopDefaultLegacy(BaseRegression);
    var RobustPolynomialRegression = class extends BaseRegression__default["default"] {
      constructor(x, y, degree) {
        super();
        if (x === true) {
          this.degree = y.degree;
          this.powers = y.powers;
          this.coefficients = y.coefficients;
        } else {
          BaseRegression.checkArrayLength(x, y);
          robustPolynomial(this, x, y, degree);
        }
      }
      toJSON() {
        return {
          name: "robustPolynomialRegression",
          degree: this.degree,
          powers: this.powers,
          coefficients: this.coefficients
        };
      }
      _predict(x) {
        return predict(x, this.powers, this.coefficients);
      }
      /**
       * Display the formula
       * @param {number} precision - precision for the numbers
       * @return {string}
       */
      toString(precision) {
        return this._toFormula(precision, false);
      }
      /**
       * Display the formula in LaTeX format
       * @param {number} precision - precision for the numbers
       * @return {string}
       */
      toLaTeX(precision) {
        return this._toFormula(precision, true);
      }
      _toFormula(precision, isLaTeX) {
        let sup = "^";
        let closeSup = "";
        let times = " * ";
        if (isLaTeX) {
          sup = "^{";
          closeSup = "}";
          times = "";
        }
        let fn = "";
        let str = "";
        for (let k = 0; k < this.coefficients.length; k++) {
          str = "";
          if (this.coefficients[k] !== 0) {
            if (this.powers[k] === 0) {
              str = BaseRegression.maybeToPrecision(this.coefficients[k], precision);
            } else {
              if (this.powers[k] === 1) {
                str = `${BaseRegression.maybeToPrecision(this.coefficients[k], precision) + times}x`;
              } else {
                str = `${BaseRegression.maybeToPrecision(this.coefficients[k], precision) + times}x${sup}${this.powers[k]}${closeSup}`;
              }
            }
            if (this.coefficients[k] > 0 && k !== this.coefficients.length - 1) {
              str = ` + ${str}`;
            } else if (k !== this.coefficients.length - 1) {
              str = ` ${str}`;
            }
          }
          fn = str + fn;
        }
        if (fn.charAt(0) === "+") {
          fn = fn.slice(1);
        }
        return `f(x) = ${fn}`;
      }
      static load(json) {
        if (json.name !== "robustPolynomialRegression") {
          throw new TypeError("not a RobustPolynomialRegression model");
        }
        return new RobustPolynomialRegression(true, json);
      }
    };
    function robustPolynomial(regression, x, y, degree) {
      let powers = Array(degree).fill(0).map((_, index) => index);
      const tuples = getRandomTuples(x, y, degree);
      let min;
      for (let i = 0; i < tuples.length; i++) {
        let tuple = tuples[i];
        let coefficients = calcCoefficients(tuple, powers);
        let residuals = x.slice();
        for (let j = 0; j < x.length; j++) {
          residuals[j] = y[j] - predict(x[j], powers, coefficients);
          residuals[j] = {
            residual: residuals[j] * residuals[j],
            coefficients
          };
        }
        let median = residualsMedian(residuals);
        if (!min || median.residual < min.residual) {
          min = median;
        }
      }
      regression.degree = degree;
      regression.powers = powers;
      regression.coefficients = min.coefficients;
    }
    function getRandomTuples(x, y, degree) {
      let len = Math.floor(x.length / degree);
      let tuples = new Array(len);
      for (let i = 0; i < x.length; i++) {
        let pos = Math.floor(Math.random() * len);
        let counter = 0;
        while (counter < x.length) {
          if (!tuples[pos]) {
            tuples[pos] = [
              {
                x: x[i],
                y: y[i]
              }
            ];
            break;
          } else if (tuples[pos].length < degree) {
            tuples[pos].push({
              x: x[i],
              y: y[i]
            });
            break;
          } else {
            counter++;
            pos = (pos + 1) % len;
          }
        }
        if (counter === x.length) {
          return tuples;
        }
      }
      return tuples;
    }
    function calcCoefficients(tuple, powers) {
      let X = tuple.slice();
      let Y = tuple.slice();
      for (let i = 0; i < X.length; i++) {
        Y[i] = [tuple[i].y];
        X[i] = new Array(powers.length);
        for (let j = 0; j < powers.length; j++) {
          X[i][j] = Math.pow(tuple[i].x, powers[j]);
        }
      }
      return mlMatrix.solve(X, Y).to1DArray();
    }
    function predict(x, powers, coefficients) {
      let y = 0;
      for (let k = 0; k < powers.length; k++) {
        y += coefficients[k] * Math.pow(x, powers[k]);
      }
      return y;
    }
    function residualsMedian(residuals) {
      residuals.sort((a, b) => a.residual - b.residual);
      let l = residuals.length;
      let half = Math.floor(l / 2);
      return l % 2 === 0 ? residuals[half - 1] : residuals[half];
    }
    module2.exports = RobustPolynomialRegression;
  }
});

// node_modules/ml-regression/lib/index.js
var require_lib17 = __commonJS({
  "node_modules/ml-regression/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var BaseRegression = require_lib8();
    var BaseRegression__default = _interopDefault(BaseRegression);
    var PolynomialRegression = _interopDefault(require_lib9());
    var mlRegressionSimpleLinear = _interopDefault(require_lib10());
    var mlRegressionExponential = _interopDefault(require_lib11());
    var mlRegressionPower = _interopDefault(require_lib12());
    var mlRegressionMultivariateLinear = _interopDefault(require_lib13());
    var mlMatrix = require_matrix();
    var Kernel = _interopDefault(require_kernel2());
    var mlRegressionTheilSen = _interopDefault(require_lib15());
    var mlRegressionRobustPolynomial = _interopDefault(require_lib16());
    var PotentialRegression = class extends BaseRegression__default {
      /**
       * @constructor
       * @param x: Independent variable
       * @param y: Dependent variable
       * @param M
       */
      constructor(x, y, M) {
        super();
        if (x === true) {
          this.A = y.A;
          this.M = y.M;
        } else {
          var n = x.length;
          if (n !== y.length) {
            throw new RangeError("input and output array have a different length");
          }
          var linear = new PolynomialRegression(x, y, [M]);
          this.A = linear.coefficients[0];
          this.M = M;
        }
      }
      _predict(x) {
        return this.A * Math.pow(x, this.M);
      }
      toJSON() {
        return {
          name: "potentialRegression",
          A: this.A,
          M: this.M
        };
      }
      toString(precision) {
        return `f(x) = ${BaseRegression.maybeToPrecision(this.A, precision)} * x^${this.M}`;
      }
      toLaTeX(precision) {
        if (this.M >= 0) {
          return `f(x) = ${BaseRegression.maybeToPrecision(this.A, precision)}x^{${this.M}}`;
        } else {
          return `f(x) = \\frac{${BaseRegression.maybeToPrecision(this.A, precision)}}{x^{${-this.M}}}`;
        }
      }
      static load(json) {
        if (json.name !== "potentialRegression") {
          throw new TypeError("not a potential regression model");
        }
        return new PotentialRegression(true, json);
      }
    };
    var defaultOptions = {
      lambda: 0.1,
      kernelType: "gaussian",
      kernelOptions: {},
      computeCoefficient: false
    };
    var KernelRidgeRegression = class extends BaseRegression__default {
      constructor(inputs, outputs, options) {
        super();
        if (inputs === true) {
          this.alpha = outputs.alpha;
          this.inputs = outputs.inputs;
          this.kernelType = outputs.kernelType;
          this.kernelOptions = outputs.kernelOptions;
          this.kernel = new Kernel(outputs.kernelType, outputs.kernelOptions);
        } else {
          inputs = mlMatrix.Matrix.checkMatrix(inputs);
          options = Object.assign({}, defaultOptions, options);
          const kernelFunction = new Kernel(
            options.kernelType,
            options.kernelOptions
          );
          const K = kernelFunction.compute(inputs);
          const n = inputs.rows;
          K.add(mlMatrix.Matrix.eye(n, n).mul(options.lambda));
          this.alpha = mlMatrix.solve(K, outputs);
          this.inputs = inputs;
          this.kernelType = options.kernelType;
          this.kernelOptions = options.kernelOptions;
          this.kernel = kernelFunction;
        }
      }
      _predict(newInputs) {
        return this.kernel.compute([newInputs], this.inputs).mmul(this.alpha).getRow(0);
      }
      toJSON() {
        return {
          name: "kernelRidgeRegression",
          alpha: this.alpha,
          inputs: this.inputs,
          kernelType: this.kernelType,
          kernelOptions: this.kernelOptions
        };
      }
      static load(json) {
        if (json.name !== "kernelRidgeRegression") {
          throw new TypeError("not a KRR model");
        }
        return new KernelRidgeRegression(true, json);
      }
    };
    var defaultOptions$1 = {
      order: 2
    };
    var PolynomialFitRegression2D = class extends BaseRegression__default {
      /**
       * Constructor for the 2D polynomial fitting
       *
       * @param inputs
       * @param outputs
       * @param options
       * @constructor
       */
      constructor(inputs, outputs, options) {
        super();
        if (inputs === true) {
          this.coefficients = mlMatrix.Matrix.columnVector(outputs.coefficients);
          this.order = outputs.order;
          if (outputs.r) {
            this.r = outputs.r;
            this.r2 = outputs.r2;
          }
          if (outputs.chi2) {
            this.chi2 = outputs.chi2;
          }
        } else {
          options = Object.assign({}, defaultOptions$1, options);
          this.order = options.order;
          this.coefficients = [];
          this.X = inputs;
          this.y = outputs;
          this.train(this.X, this.y, options);
        }
      }
      /**
       * Function that fits the model given the data(X) and predictions(y).
       * The third argument is an object with the following options:
       * * order: order of the polynomial to fit.
       *
       * @param {Matrix} X - A matrix with n rows and 2 columns.
       * @param {Matrix} y - A vector of the prediction values.
       */
      train(X, y) {
        if (!mlMatrix.Matrix.isMatrix(X))
          X = new mlMatrix.Matrix(X);
        if (!mlMatrix.Matrix.isMatrix(y))
          y = mlMatrix.Matrix.columnVector(y);
        if (y.rows !== X.rows) {
          y = y.transpose();
        }
        if (X.columns !== 2) {
          throw new RangeError(
            `You give X with ${X.columns} columns and it must be 2`
          );
        }
        if (X.rows !== y.rows) {
          throw new RangeError("X and y must have the same rows");
        }
        var examples = X.rows;
        var coefficients = (this.order + 2) * (this.order + 1) / 2;
        this.coefficients = new Array(coefficients);
        var x1 = X.getColumnVector(0);
        var x2 = X.getColumnVector(1);
        var scaleX1 = 1 / x1.clone().abs().max();
        var scaleX2 = 1 / x2.clone().abs().max();
        var scaleY = 1 / y.clone().abs().max();
        x1.mulColumn(0, scaleX1);
        x2.mulColumn(0, scaleX2);
        y.mulColumn(0, scaleY);
        var A = new mlMatrix.Matrix(examples, coefficients);
        var col = 0;
        for (var i = 0; i <= this.order; ++i) {
          var limit = this.order - i;
          for (var j = 0; j <= limit; ++j) {
            var result = powColVector(x1, i).mulColumnVector(powColVector(x2, j));
            A.setColumn(col, result);
            col++;
          }
        }
        var svd = new mlMatrix.SVD(A.transpose(), {
          computeLeftSingularVectors: true,
          computeRightSingularVectors: true,
          autoTranspose: false
        });
        var qqs = mlMatrix.Matrix.rowVector(svd.diagonal);
        qqs = qqs.apply(function(i2, j2) {
          if (this.get(i2, j2) >= 1e-15)
            this.set(i2, j2, 1 / this.get(i2, j2));
          else
            this.set(i2, j2, 0);
        });
        var qqs1 = mlMatrix.Matrix.zeros(examples, coefficients);
        for (i = 0; i < coefficients; ++i) {
          qqs1.set(i, i, qqs.get(0, i));
        }
        qqs = qqs1;
        var U = svd.rightSingularVectors;
        var V = svd.leftSingularVectors;
        this.coefficients = V.mmul(qqs.transpose()).mmul(U.transpose()).mmul(y);
        col = 0;
        for (i = 0; i <= coefficients; ++i) {
          limit = this.order - i;
          for (j = 0; j <= limit; ++j) {
            this.coefficients.set(
              col,
              0,
              this.coefficients.get(col, 0) * Math.pow(scaleX1, i) * Math.pow(scaleX2, j) / scaleY
            );
            col++;
          }
        }
      }
      _predict(newInputs) {
        var x1 = newInputs[0];
        var x2 = newInputs[1];
        var y = 0;
        var column = 0;
        for (var i = 0; i <= this.order; i++) {
          for (var j = 0; j <= this.order - i; j++) {
            y += Math.pow(x1, i) * Math.pow(x2, j) * this.coefficients.get(column, 0);
            column++;
          }
        }
        return y;
      }
      toJSON() {
        return {
          name: "polyfit2D",
          order: this.order,
          coefficients: this.coefficients
        };
      }
      static load(json) {
        if (json.name !== "polyfit2D") {
          throw new TypeError("not a polyfit2D model");
        }
        return new PolynomialFitRegression2D(true, json);
      }
    };
    function powColVector(x, power) {
      var result = x.clone();
      for (var i = 0; i < x.rows; ++i) {
        result.set(i, 0, Math.pow(result.get(i, 0), power));
      }
      return result;
    }
    var NLR = {
      PotentialRegression
    };
    exports2.PolynomialRegression = PolynomialRegression;
    exports2.SLR = mlRegressionSimpleLinear;
    exports2.SimpleLinearRegression = mlRegressionSimpleLinear;
    exports2.ExponentialRegression = mlRegressionExponential;
    exports2.PowerRegression = mlRegressionPower;
    exports2.MultivariateLinearRegression = mlRegressionMultivariateLinear;
    exports2.TheilSenRegression = mlRegressionTheilSen;
    exports2.RobustPolynomialRegression = mlRegressionRobustPolynomial;
    exports2.KRR = KernelRidgeRegression;
    exports2.KernelRidgeRegression = KernelRidgeRegression;
    exports2.NLR = NLR;
    exports2.NonLinearRegression = NLR;
    exports2.PolinomialFitting2D = PolynomialFitRegression2D;
  }
});

// node_modules/image-js/lib/image/filter/background.js
var require_background = __commonJS({
  "node_modules/image-js/lib/image/filter/background.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = background;
    var _mlRegression = require_lib17();
    var _Image = _interopRequireDefault(require_Image());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function background(coordinates, values, options) {
      const model = new _mlRegression.KernelRidgeRegression(coordinates, values, options);
      const allCoordinates = new Array(this.size);
      for (let i = 0; i < this.width; i++) {
        for (let j = 0; j < this.height; j++) {
          allCoordinates[j * this.width + i] = [i, j];
        }
      }
      const result = model.predict(allCoordinates);
      const background2 = _Image.default.createFrom(this);
      for (let i = 0; i < this.size; i++) {
        background2.data[i] = Math.min(this.maxValue, Math.max(0, result[i][0]));
      }
      return background2;
    }
  }
});

// node_modules/image-js/lib/image/morphology/dilate.js
var require_dilate = __commonJS({
  "node_modules/image-js/lib/image/morphology/dilate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = dilate;
    var _Image = _interopRequireDefault(require_Image());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function dilate(options = {}) {
      let {
        kernel = [[1, 1, 1], [1, 1, 1], [1, 1, 1]],
        iterations = 1
      } = options;
      this.checkProcessable("dilate", {
        bitDepth: [1, 8, 16],
        components: 1,
        alpha: 0
      });
      if (kernel.columns % 2 === 0 || kernel.rows % 2 === 0) {
        throw new TypeError("dilate: The number of rows and columns of the kernel must be odd");
      }
      let onlyOnes = true;
      outer:
        for (const row of kernel) {
          for (const value of row) {
            if (value !== 1) {
              onlyOnes = false;
              break outer;
            }
          }
        }
      let result = this;
      for (let i = 0; i < iterations; i++) {
        if (this.bitDepth === 1) {
          if (onlyOnes) {
            const newImage = result.clone();
            result = dilateOnceBinaryOnlyOnes(result, newImage, kernel.length, kernel[0].length);
          } else {
            const newImage = _Image.default.createFrom(result);
            result = dilateOnceBinary(result, newImage, kernel);
          }
        } else if (onlyOnes) {
          const newImage = _Image.default.createFrom(result);
          result = dilateOnceGreyOnlyOnes(result, newImage, kernel.length, kernel[0].length);
        } else {
          const newImage = _Image.default.createFrom(result);
          result = dilateOnceGrey(result, newImage, kernel);
        }
      }
      return result;
    }
    function dilateOnceGrey(img, newImage, kernel) {
      const kernelWidth = kernel.length;
      const kernelHeight = kernel[0].length;
      let radiusX = (kernelWidth - 1) / 2;
      let radiusY = (kernelHeight - 1) / 2;
      for (let y = 0; y < img.height; y++) {
        for (let x = 0; x < img.width; x++) {
          let max = 0;
          for (let jj = 0; jj < kernelHeight; jj++) {
            for (let ii = 0; ii < kernelWidth; ii++) {
              if (kernel[ii][jj] !== 1)
                continue;
              let i = ii - radiusX + x;
              let j = jj - radiusY + y;
              if (i < 0 || j < 0 || i >= img.width || j >= img.height)
                continue;
              const value = img.getValueXY(i, j, 0);
              if (value > max)
                max = value;
            }
          }
          newImage.setValueXY(x, y, 0, max);
        }
      }
      return newImage;
    }
    function dilateOnceGreyOnlyOnes(img, newImage, kernelWidth, kernelHeight) {
      const radiusX = (kernelWidth - 1) / 2;
      const radiusY = (kernelHeight - 1) / 2;
      const maxList = [];
      for (let x = 0; x < img.width; x++) {
        maxList.push(0);
      }
      for (let y = 0; y < img.height; y++) {
        for (let x = 0; x < img.width; x++) {
          let max = 0;
          for (let h = Math.max(0, y - radiusY); h < Math.min(img.height, y + radiusY + 1); h++) {
            const value = img.getValueXY(x, h, 0);
            if (value > max) {
              max = value;
            }
          }
          maxList[x] = max;
        }
        for (let x = 0; x < img.width; x++) {
          let max = 0;
          for (let i = Math.max(0, x - radiusX); i < Math.min(img.width, x + radiusX + 1); i++) {
            if (maxList[i] > max) {
              max = maxList[i];
            }
          }
          newImage.setValueXY(x, y, 0, max);
        }
      }
      return newImage;
    }
    function dilateOnceBinary(img, newImage, kernel) {
      const kernelWidth = kernel.length;
      const kernelHeight = kernel[0].length;
      let radiusX = (kernelWidth - 1) / 2;
      let radiusY = (kernelHeight - 1) / 2;
      for (let y = 0; y < img.height; y++) {
        for (let x = 0; x < img.width; x++) {
          let max = 0;
          intLoop:
            for (let jj = 0; jj < kernelHeight; jj++) {
              for (let ii = 0; ii < kernelWidth; ii++) {
                if (kernel[ii][jj] !== 1)
                  continue;
                let i = ii - radiusX + x;
                let j = jj - radiusY + y;
                if (j < 0 || i < 0 || i >= img.width || j >= img.height)
                  continue;
                const value = img.getBitXY(i, j);
                if (value === 1) {
                  max = 1;
                  break intLoop;
                }
              }
            }
          if (max === 1) {
            newImage.setBitXY(x, y);
          }
        }
      }
      return newImage;
    }
    function dilateOnceBinaryOnlyOnes(img, newImage, kernelWidth, kernelHeight) {
      const radiusX = (kernelWidth - 1) / 2;
      const radiusY = (kernelHeight - 1) / 2;
      const maxList = [];
      for (let x = 0; x < img.width; x++) {
        maxList.push(1);
      }
      for (let y = 0; y < img.height; y++) {
        for (let x = 0; x < img.width; x++) {
          maxList[x] = 0;
          for (let h = Math.max(0, y - radiusY); h < Math.min(img.height, y + radiusY + 1); h++) {
            if (img.getBitXY(x, h) === 1) {
              maxList[x] = 1;
              break;
            }
          }
        }
        for (let x = 0; x < img.width; x++) {
          if (newImage.getBitXY(x, y) === 1)
            continue;
          for (let i = Math.max(0, x - radiusX); i < Math.min(img.width, x + radiusX + 1); i++) {
            if (maxList[i] === 1) {
              newImage.setBitXY(x, y);
              break;
            }
          }
        }
      }
      return newImage;
    }
  }
});

// node_modules/image-js/lib/image/morphology/erode.js
var require_erode = __commonJS({
  "node_modules/image-js/lib/image/morphology/erode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = erode;
    var _Image = _interopRequireDefault(require_Image());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function erode(options = {}) {
      let {
        kernel = [[1, 1, 1], [1, 1, 1], [1, 1, 1]],
        iterations = 1
      } = options;
      this.checkProcessable("erode", {
        bitDepth: [1, 8, 16],
        components: 1,
        alpha: 0
      });
      if (kernel.columns % 2 === 0 || kernel.rows % 2 === 0) {
        throw new TypeError("erode: The number of rows and columns of the kernel must be odd");
      }
      let onlyOnes = true;
      outer:
        for (const row of kernel) {
          for (const value of row) {
            if (value !== 1) {
              onlyOnes = false;
              break outer;
            }
          }
        }
      let result = this;
      for (let i = 0; i < iterations; i++) {
        if (this.bitDepth === 1) {
          if (onlyOnes) {
            const newImage = result.clone();
            result = erodeOnceBinaryOnlyOnes(result, newImage, kernel.length, kernel[0].length);
          } else {
            const newImage = _Image.default.createFrom(result);
            result = erodeOnceBinary(result, newImage, kernel);
          }
        } else if (onlyOnes) {
          const newImage = _Image.default.createFrom(result);
          result = erodeOnceGreyOnlyOnes(result, newImage, kernel.length, kernel[0].length);
        } else {
          const newImage = _Image.default.createFrom(result);
          result = erodeOnceGrey(result, newImage, kernel);
        }
      }
      return result;
    }
    function erodeOnceGrey(img, newImage, kernel) {
      const kernelWidth = kernel.length;
      const kernelHeight = kernel[0].length;
      let radiusX = (kernelWidth - 1) / 2;
      let radiusY = (kernelHeight - 1) / 2;
      for (let y = 0; y < img.height; y++) {
        for (let x = 0; x < img.width; x++) {
          let min = img.maxValue;
          for (let jj = 0; jj < kernelHeight; jj++) {
            for (let ii = 0; ii < kernelWidth; ii++) {
              if (kernel[ii][jj] !== 1)
                continue;
              let i = ii - radiusX + x;
              let j = jj - radiusY + y;
              if (i < 0 || j < 0 || i >= img.width || j >= img.height)
                continue;
              const value = img.getValueXY(i, j, 0);
              if (value < min)
                min = value;
            }
          }
          newImage.setValueXY(x, y, 0, min);
        }
      }
      return newImage;
    }
    function erodeOnceGreyOnlyOnes(img, newImage, kernelWidth, kernelHeight) {
      const radiusX = (kernelWidth - 1) / 2;
      const radiusY = (kernelHeight - 1) / 2;
      const minList = [];
      for (let x = 0; x < img.width; x++) {
        minList.push(0);
      }
      for (let y = 0; y < img.height; y++) {
        for (let x = 0; x < img.width; x++) {
          let min = img.maxValue;
          for (let h = Math.max(0, y - radiusY); h < Math.min(img.height, y + radiusY + 1); h++) {
            const value = img.getValueXY(x, h, 0);
            if (value < min) {
              min = value;
            }
          }
          minList[x] = min;
        }
        for (let x = 0; x < img.width; x++) {
          let min = img.maxValue;
          for (let i = Math.max(0, x - radiusX); i < Math.min(img.width, x + radiusX + 1); i++) {
            if (minList[i] < min) {
              min = minList[i];
            }
          }
          newImage.setValueXY(x, y, 0, min);
        }
      }
      return newImage;
    }
    function erodeOnceBinary(img, newImage, kernel) {
      const kernelWidth = kernel.length;
      const kernelHeight = kernel[0].length;
      let radiusX = (kernelWidth - 1) / 2;
      let radiusY = (kernelHeight - 1) / 2;
      for (let y = 0; y < img.height; y++) {
        for (let x = 0; x < img.width; x++) {
          let min = 1;
          intLoop:
            for (let jj = 0; jj < kernelHeight; jj++) {
              for (let ii = 0; ii < kernelWidth; ii++) {
                if (kernel[ii][jj] !== 1)
                  continue;
                let i = ii - radiusX + x;
                let j = jj - radiusY + y;
                if (j < 0 || i < 0 || i >= img.width || j >= img.height)
                  continue;
                const value = img.getBitXY(i, j);
                if (value === 0) {
                  min = 0;
                  break intLoop;
                }
              }
            }
          if (min === 1) {
            newImage.setBitXY(x, y);
          }
        }
      }
      return newImage;
    }
    function erodeOnceBinaryOnlyOnes(img, newImage, kernelWidth, kernelHeight) {
      const radiusX = (kernelWidth - 1) / 2;
      const radiusY = (kernelHeight - 1) / 2;
      const minList = [];
      for (let x = 0; x < img.width; x++) {
        minList.push(0);
      }
      for (let y = 0; y < img.height; y++) {
        for (let x = 0; x < img.width; x++) {
          minList[x] = 1;
          for (let h = Math.max(0, y - radiusY); h < Math.min(img.height, y + radiusY + 1); h++) {
            if (img.getBitXY(x, h) === 0) {
              minList[x] = 0;
              break;
            }
          }
        }
        for (let x = 0; x < img.width; x++) {
          if (newImage.getBitXY(x, y) === 0)
            continue;
          for (let i = Math.max(0, x - radiusX); i < Math.min(img.width, x + radiusX + 1); i++) {
            if (minList[i] === 0) {
              newImage.clearBitXY(x, y);
              break;
            }
          }
        }
      }
      return newImage;
    }
  }
});

// node_modules/image-js/lib/image/morphology/open.js
var require_open = __commonJS({
  "node_modules/image-js/lib/image/morphology/open.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = open;
    function open(options = {}) {
      let {
        kernel = [[1, 1, 1], [1, 1, 1], [1, 1, 1]],
        iterations = 1
      } = options;
      this.checkProcessable("open", {
        bitDepth: [8, 16],
        components: 1,
        alpha: 0
      });
      if (kernel.columns % 2 === 0 || kernel.rows % 2 === 0) {
        throw new TypeError("open: The number of rows and columns of the kernel must be odd");
      }
      let newImage = this;
      for (let i = 0; i < iterations; i++) {
        newImage = newImage.erode({
          kernel
        });
        newImage = newImage.dilate({
          kernel
        });
      }
      return newImage;
    }
  }
});

// node_modules/image-js/lib/image/morphology/close.js
var require_close = __commonJS({
  "node_modules/image-js/lib/image/morphology/close.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = close;
    function close(options = {}) {
      let {
        kernel = [[1, 1, 1], [1, 1, 1], [1, 1, 1]],
        iterations = 1
      } = options;
      this.checkProcessable("close", {
        bitDepth: [1, 8, 16],
        components: 1,
        alpha: 0
      });
      if (kernel.columns % 2 === 0 || kernel.rows % 2 === 0) {
        throw new TypeError("close: The number of rows and columns of the kernel must be odd");
      }
      let newImage = this;
      for (let i = 0; i < iterations; i++) {
        newImage = newImage.dilate({
          kernel
        }).erode({
          kernel
        });
      }
      return newImage;
    }
  }
});

// node_modules/image-js/lib/image/morphology/topHat.js
var require_topHat = __commonJS({
  "node_modules/image-js/lib/image/morphology/topHat.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = topHat;
    function topHat(options = {}) {
      let {
        kernel = [[1, 1, 1], [1, 1, 1], [1, 1, 1]],
        iterations = 1
      } = options;
      this.checkProcessable("topHat", {
        bitDepth: [8, 16],
        components: 1,
        alpha: 0
      });
      if (kernel.length % 2 === 0 || kernel[0].length % 2 === 0) {
        throw new TypeError("topHat: The number of rows and columns of the kernel must be odd");
      }
      let newImage = this;
      for (let i = 0; i < iterations; i++) {
        let openImage = newImage.open({
          kernel
        });
        newImage = openImage.subtractImage(newImage, {
          absolute: true
        });
      }
      return newImage;
    }
  }
});

// node_modules/image-js/lib/image/morphology/blackHat.js
var require_blackHat = __commonJS({
  "node_modules/image-js/lib/image/morphology/blackHat.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = blackHat;
    function blackHat(options = {}) {
      let {
        kernel = [[1, 1, 1], [1, 1, 1], [1, 1, 1]],
        iterations = 1
      } = options;
      this.checkProcessable("blackHat", {
        bitDepth: [8, 16],
        components: 1,
        alpha: 0
      });
      if (kernel.columns % 2 === 0 || kernel.rows % 2 === 0) {
        throw new TypeError("blackHat: The number of rows and columns of the kernel must be odd");
      }
      let newImage = this;
      for (let i = 0; i < iterations; i++) {
        const closeImage = newImage.close({
          kernel
        });
        newImage = closeImage.subtractImage(newImage, {
          absolute: true
        });
      }
      return newImage;
    }
  }
});

// node_modules/image-js/lib/image/morphology/morphologicalGradient.js
var require_morphologicalGradient = __commonJS({
  "node_modules/image-js/lib/image/morphology/morphologicalGradient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = morphologicalGradient;
    function morphologicalGradient(options = {}) {
      let {
        kernel = [[1, 1, 1], [1, 1, 1], [1, 1, 1]],
        iterations = 1
      } = options;
      this.checkProcessable("morphologicalGradient", {
        bitDepth: [8, 16],
        components: 1,
        alpha: 0
      });
      if (kernel.columns % 2 === 0 || kernel.rows % 2 === 0) {
        throw new TypeError("morphologicalGradient: The number of rows and columns of the kernel must be odd");
      }
      let newImage = this;
      for (let i = 0; i < iterations; i++) {
        let dilatedImage = newImage.dilate({
          kernel
        });
        let erodedImage = newImage.erode({
          kernel
        });
        newImage = dilatedImage.subtractImage(erodedImage, {
          absolute: true
        });
      }
      return newImage;
    }
  }
});

// node_modules/image-js/lib/image/transform/warping.js
var require_warping = __commonJS({
  "node_modules/image-js/lib/image/transform/warping.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = warpingFourPoints;
    var _mlMatrix = require_matrix();
    var _Image = _interopRequireDefault(require_Image());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function order4Points(pts) {
      let tl = 0;
      let tr = 0;
      let br = 0;
      let bl = 0;
      let minX = pts[0][0];
      let indexMinX = 0;
      for (let i = 1; i < pts.length; i++) {
        if (pts[i][0] < minX) {
          minX = pts[i][0];
          indexMinX = i;
        }
      }
      let minX2 = pts[(indexMinX + 1) % pts.length][0];
      let indexMinX2 = (indexMinX + 1) % pts.length;
      for (let i = 1; i < pts.length; i++) {
        if (pts[i][0] < minX2 && i !== indexMinX) {
          minX2 = pts[i][0];
          indexMinX2 = i;
        }
      }
      if (pts[indexMinX2][1] < pts[indexMinX][1]) {
        tl = pts[indexMinX2];
        bl = pts[indexMinX];
        if (indexMinX !== (indexMinX2 + 1) % 4) {
          tr = pts[(indexMinX2 + 1) % 4];
          br = pts[(indexMinX2 + 2) % 4];
        } else {
          tr = pts[(indexMinX2 + 2) % 4];
          br = pts[(indexMinX2 + 3) % 4];
        }
      } else {
        bl = pts[indexMinX2];
        tl = pts[indexMinX];
        if (indexMinX2 !== (indexMinX + 1) % 4) {
          tr = pts[(indexMinX + 1) % 4];
          br = pts[(indexMinX + 2) % 4];
        } else {
          tr = pts[(indexMinX + 2) % 4];
          br = pts[(indexMinX + 3) % 4];
        }
      }
      return [tl, tr, br, bl];
    }
    function distance2Points(p1, p2) {
      return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));
    }
    function crossVect(u, v) {
      let result = [u[1] * v[2] - u[2] * v[1], u[2] * v[0] - u[0] * v[2], u[0] * v[1] - u[1] * v[0]];
      return result;
    }
    function dotVect(u, v) {
      let result = u[0] * v[0] + u[1] * v[1] + u[2] * v[2];
      return result;
    }
    function computeWidthAndHeigth(tl, tr, br, bl, widthImage, heightImage) {
      let w = Math.max(distance2Points(tl, tr), distance2Points(bl, br));
      let h = Math.max(distance2Points(tl, bl), distance2Points(tr, br));
      let finalW = 0;
      let finalH = 0;
      let u0 = Math.ceil(widthImage / 2);
      let v0 = Math.ceil(heightImage / 2);
      let arVis = w / h;
      let m1 = [tl[0], tl[1], 1];
      let m2 = [tr[0], tr[1], 1];
      let m3 = [bl[0], bl[1], 1];
      let m4 = [br[0], br[1], 1];
      let k2 = dotVect(crossVect(m1, m4), m3) / dotVect(crossVect(m2, m4), m3);
      let k3 = dotVect(crossVect(m1, m4), m2) / dotVect(crossVect(m3, m4), m2);
      let n2 = [k2 * m2[0] - m1[0], k2 * m2[1] - m1[1], k2 * m2[2] - m1[2]];
      let n3 = [k3 * m3[0] - m1[0], k3 * m3[1] - m1[1], k3 * m3[2] - m1[2]];
      let n21 = n2[0];
      let n22 = n2[1];
      let n23 = n2[2];
      let n31 = n3[0];
      let n32 = n3[1];
      let n33 = n3[2];
      let f = 1 / (n23 * n33) * (n21 * n31 - (n21 * n33 + n23 * n31) * u0 + n23 * n33 * u0 * u0 + (n22 * n32 - (n22 * n33 + n23 * n32) * v0 + n23 * n33 * v0 * v0));
      if (f >= 0) {
        f = Math.sqrt(f);
      } else {
        f = Math.sqrt(-f);
      }
      let A = new _mlMatrix.Matrix([[f, 0, u0], [0, f, v0], [0, 0, 1]]);
      let At = A.transpose();
      let Ati = (0, _mlMatrix.inverse)(At);
      let Ai = (0, _mlMatrix.inverse)(A);
      let n2R = _mlMatrix.Matrix.rowVector(n2);
      let n3R = _mlMatrix.Matrix.rowVector(n3);
      let arReal = Math.sqrt(dotVect(n2R.mmul(Ati).mmul(Ai).to1DArray(), n2) / dotVect(n3R.mmul(Ati).mmul(Ai).to1DArray(), n3));
      if (arReal === 0 || arVis === 0) {
        finalW = Math.ceil(w);
        finalH = Math.ceil(h);
      } else if (arReal < arVis) {
        finalW = Math.ceil(w);
        finalH = Math.ceil(finalW / arReal);
      } else {
        finalH = Math.ceil(h);
        finalW = Math.ceil(arReal * finalH);
      }
      return [finalW, finalH];
    }
    function projectionPoint(x, y, a, b, c, d, e, f, g, h, image, channel) {
      let [newX, newY] = [(a * x + b * y + c) / (g * x + h * y + 1), (d * x + e * y + f) / (g * x + h * y + 1)];
      return image.getValueXY(Math.floor(newX), Math.floor(newY), channel);
    }
    function warpingFourPoints(pts, options = {}) {
      let {
        calculateRatio = true
      } = options;
      if (pts.length !== 4) {
        throw new Error(`The array pts must have four elements, which are the four corners. Currently, pts have ${pts.length} elements`);
      }
      let [pt1, pt2, pt3, pt4] = pts;
      let quadrilaterial = [pt1, pt2, pt3, pt4];
      let [tl, tr, br, bl] = order4Points(quadrilaterial);
      let widthRect;
      let heightRect;
      if (calculateRatio) {
        [widthRect, heightRect] = computeWidthAndHeigth(tl, tr, br, bl, this.width, this.height);
      } else {
        widthRect = Math.ceil(Math.max(distance2Points(tl, tr), distance2Points(bl, br)));
        heightRect = Math.ceil(Math.max(distance2Points(tl, bl), distance2Points(tr, br)));
      }
      let newImage = _Image.default.createFrom(this, {
        width: widthRect,
        height: heightRect
      });
      let [X1, Y1] = tl;
      let [X2, Y2] = tr;
      let [X3, Y3] = br;
      let [X4, Y4] = bl;
      let [x1, y1] = [0, 0];
      let [x2, y2] = [0, widthRect - 1];
      let [x3, y3] = [heightRect - 1, widthRect - 1];
      let [x4, y4] = [heightRect - 1, 0];
      let S = new _mlMatrix.Matrix([[x1, y1, 1, 0, 0, 0, -x1 * X1, -y1 * X1], [x2, y2, 1, 0, 0, 0, -x2 * X2, -y2 * X2], [x3, y3, 1, 0, 0, 0, -x3 * X3, -y1 * X3], [x4, y4, 1, 0, 0, 0, -x4 * X4, -y4 * X4], [0, 0, 0, x1, y1, 1, -x1 * Y1, -y1 * Y1], [0, 0, 0, x2, y2, 1, -x2 * Y2, -y2 * Y2], [0, 0, 0, x3, y3, 1, -x3 * Y3, -y3 * Y3], [0, 0, 0, x4, y4, 1, -x4 * Y4, -y4 * Y4]]);
      let D = _mlMatrix.Matrix.columnVector([X1, X2, X3, X4, Y1, Y2, Y3, Y4]);
      let svd = new _mlMatrix.SingularValueDecomposition(S);
      let T = svd.solve(D);
      let [a, b, c, d, e, f, g, h] = T.to1DArray();
      let Xt = new _mlMatrix.Matrix(heightRect, widthRect);
      for (let channel = 0; channel < this.channels; channel++) {
        for (let i = 0; i < heightRect; i++) {
          for (let j = 0; j < widthRect; j++) {
            Xt.set(i, j, projectionPoint(i, j, a, b, c, d, e, f, g, h, this, channel));
          }
        }
        newImage.setMatrix(Xt, {
          channel
        });
      }
      return newImage;
    }
  }
});

// node_modules/image-js/lib/image/transform/crop.js
var require_crop = __commonJS({
  "node_modules/image-js/lib/image/transform/crop.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = crop;
    var _Image = _interopRequireDefault(require_Image());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function crop(options = {}) {
      let {
        x = 0,
        y = 0,
        width = this.width - x,
        height = this.height - y
      } = options;
      this.checkProcessable("crop", {
        bitDepth: [1, 8, 16]
      });
      x = Math.round(x);
      y = Math.round(y);
      width = Math.round(width);
      height = Math.round(height);
      if (x > this.width - 1 || y > this.height - 1) {
        throw new RangeError(`crop: origin (x:${x}, y:${y}) out of range (${this.width - 1}; ${this.height - 1})`);
      }
      if (width <= 0 || height <= 0) {
        throw new RangeError(`crop: width and height (width:${width}; height:${height}) must be positive numbers`);
      }
      if (x < 0 || y < 0) {
        throw new RangeError(`crop: x and y (x:${x}, y:${y}) must be positive numbers`);
      }
      if (width > this.width - x || height > this.height - y) {
        throw new RangeError(`crop: (x: ${x}, y:${y}, width:${width}, height:${height}) size is out of range`);
      }
      let result = this;
      if (this.bitDepth === 1) {
        const newImage = new _Image.default(width, height, {
          kind: "BINARY",
          parent: this
        });
        result = cropBinary(this, newImage, x, y, width, height);
      } else {
        const newImage = _Image.default.createFrom(this, {
          width,
          height,
          position: [x, y]
        });
        result = cropDefault(this, newImage, x, y, width, height);
      }
      return result;
    }
    function cropDefault(img, newImage, x, y, width, height) {
      let xWidth = width * img.channels;
      let y1 = y + height;
      let ptr = 0;
      let jLeft = x * img.channels;
      for (let i = y; i < y1; i++) {
        let j = i * img.width * img.channels + jLeft;
        let jL = j + xWidth;
        for (; j < jL; j++) {
          newImage.data[ptr++] = img.data[j];
        }
      }
      return newImage;
    }
    function cropBinary(img, newImage, x, y, width, height) {
      let xWidth = width * img.channels;
      let y1 = y + height;
      let ptr = 0;
      let jLeft = x * img.channels;
      for (let i = y; i < y1; i++) {
        let j = i * img.width * img.channels + jLeft;
        let jL = j + xWidth;
        for (; j < jL; j++) {
          if (img.getBit(j)) {
            newImage.setBit(ptr);
          }
          ++ptr;
        }
      }
      return newImage;
    }
  }
});

// node_modules/image-js/lib/image/transform/cropAlpha.js
var require_cropAlpha = __commonJS({
  "node_modules/image-js/lib/image/transform/cropAlpha.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = cropAlpha;
    function cropAlpha(options = {}) {
      this.checkProcessable("cropAlpha", {
        alpha: 1
      });
      const {
        threshold = this.maxValue
      } = options;
      let left = findLeft(this, threshold, this.components);
      if (left === -1) {
        throw new Error("Could not find new dimensions. Threshold may be too high.");
      }
      let top = findTop(this, threshold, this.components, left);
      let bottom = findBottom(this, threshold, this.components, left);
      let right = findRight(this, threshold, this.components, left, top, bottom);
      return this.crop({
        x: left,
        y: top,
        width: right - left + 1,
        height: bottom - top + 1
      });
    }
    function findLeft(image, threshold, channel) {
      for (let x = 0; x < image.width; x++) {
        for (let y = 0; y < image.height; y++) {
          if (image.getValueXY(x, y, channel) >= threshold) {
            return x;
          }
        }
      }
      return -1;
    }
    function findTop(image, threshold, channel, left) {
      for (let y = 0; y < image.height; y++) {
        for (let x = left; x < image.width; x++) {
          if (image.getValueXY(x, y, channel) >= threshold) {
            return y;
          }
        }
      }
      return -1;
    }
    function findBottom(image, threshold, channel, left) {
      for (let y = image.height - 1; y >= 0; y--) {
        for (let x = left; x < image.width; x++) {
          if (image.getValueXY(x, y, channel) >= threshold) {
            return y;
          }
        }
      }
      return -1;
    }
    function findRight(image, threshold, channel, left, top, bottom) {
      for (let x = image.width - 1; x >= left; x--) {
        for (let y = top; y <= bottom; y++) {
          if (image.getValueXY(x, y, channel) >= threshold) {
            return x;
          }
        }
      }
      return -1;
    }
  }
});

// node_modules/image-js/lib/util/converter.js
var require_converter = __commonJS({
  "node_modules/image-js/lib/util/converter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.factorDimensions = factorDimensions;
    exports2.getFactor = getFactor;
    exports2.getThreshold = getThreshold;
    function getFactor(value) {
      if (typeof value === "string") {
        const last = value[value.length - 1];
        value = parseFloat(value);
        if (last === "%") {
          value /= 100;
        }
      }
      return value;
    }
    function getThreshold(value, maxValue) {
      if (!maxValue) {
        throw Error("getThreshold : the maxValue should be specified");
      }
      if (typeof value === "string") {
        let last = value[value.length - 1];
        if (last !== "%") {
          throw Error("getThreshold : if the value is a string it must finish by %");
        }
        return parseFloat(value) / 100 * maxValue;
      } else if (typeof value === "number") {
        if (value < 1) {
          return value * maxValue;
        }
        return value;
      } else {
        throw Error("getThreshold : the value is not valid");
      }
    }
    function factorDimensions(factor, width, height) {
      factor = getFactor(factor);
      let newWidth = Math.round(factor * width);
      let newHeight = Math.round(factor * height);
      if (newWidth <= 0) {
        newWidth = 1;
      }
      if (newHeight <= 0) {
        newHeight = 1;
      }
      return {
        width: newWidth,
        height: newHeight
      };
    }
  }
});

// node_modules/image-js/lib/image/internal/checks.js
var require_checks = __commonJS({
  "node_modules/image-js/lib/image/internal/checks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.checkChannel = checkChannel;
    exports2.checkColumn = checkColumn;
    exports2.checkInterpolation = checkInterpolation;
    exports2.checkRow = checkRow;
    exports2.validInterpolations = void 0;
    function checkRow(image, row) {
      if (row < 0 || row >= image.height) {
        throw new RangeError(`row must be included between 0 and ${image.height - 1}. Current value: ${row}`);
      }
    }
    function checkColumn(image, column) {
      if (column < 0 || column >= image.width) {
        throw new RangeError(`column must be included between 0 and ${image.width - 1}. Current value: ${column}`);
      }
    }
    function checkChannel(image, channel) {
      if (channel < 0 || channel >= image.channels) {
        throw new RangeError(`channel must be included between 0 and ${image.channels - 1}. Current value: ${channel}`);
      }
    }
    var validInterpolations = exports2.validInterpolations = {
      nearestneighbor: "nearestNeighbor",
      nearestneighbour: "nearestNeighbor",
      bilinear: "bilinear"
    };
    function checkInterpolation(interpolation) {
      if (typeof interpolation !== "string") {
        throw new TypeError("interpolation must be a string");
      }
      interpolation = interpolation.toLowerCase();
      if (!validInterpolations[interpolation]) {
        throw new RangeError(`invalid interpolation algorithm: ${interpolation}`);
      }
      return validInterpolations[interpolation];
    }
  }
});

// node_modules/image-js/lib/image/transform/resize/nearestNeighbor.js
var require_nearestNeighbor = __commonJS({
  "node_modules/image-js/lib/image/transform/resize/nearestNeighbor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = nearestNeighbor;
    function nearestNeighbor(newImage, newWidth, newHeight) {
      const wRatio = this.width / newWidth;
      const hRatio = this.height / newHeight;
      if (this.bitDepth > 1) {
        for (let i = 0; i < newWidth; i++) {
          const w = Math.floor((i + 0.5) * wRatio);
          for (let j = 0; j < newHeight; j++) {
            const h = Math.floor((j + 0.5) * hRatio);
            for (let c = 0; c < this.channels; c++) {
              newImage.setValueXY(i, j, c, this.getValueXY(w, h, c));
            }
          }
        }
      } else {
        for (let i = 0; i < newWidth; i++) {
          const w = Math.floor((i + 0.5) * wRatio);
          for (let j = 0; j < newHeight; j++) {
            const h = Math.floor((j + 0.5) * hRatio);
            if (this.getBitXY(w, h)) {
              newImage.setBitXY(i, j);
            }
          }
        }
      }
    }
  }
});

// node_modules/image-js/lib/image/transform/resize/resize.js
var require_resize = __commonJS({
  "node_modules/image-js/lib/image/transform/resize/resize.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = resize;
    var _converter = require_converter();
    var _Image = _interopRequireDefault(require_Image());
    var _checks = require_checks();
    var _nearestNeighbor = _interopRequireDefault(require_nearestNeighbor());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function resize(options = {}) {
      const {
        factor = 1,
        interpolation = _checks.validInterpolations.nearestneighbor,
        preserveAspectRatio = true
      } = options;
      const interpolationToUse = (0, _checks.checkInterpolation)(interpolation);
      let width = options.width;
      let height = options.height;
      if (!width) {
        if (height && preserveAspectRatio) {
          width = Math.round(height * (this.width / this.height));
        } else {
          width = this.width;
        }
      }
      if (!height) {
        if (preserveAspectRatio) {
          height = Math.round(width * (this.height / this.width));
        } else {
          height = this.height;
        }
      }
      ({
        width,
        height
      } = (0, _converter.factorDimensions)(factor, width, height));
      if (width === this.width && height === this.height) {
        const newImage2 = this.clone();
        newImage2.position = [0, 0];
        return newImage2;
      }
      let shiftX = Math.round((this.width - width) / 2);
      let shiftY = Math.round((this.height - height) / 2);
      const newImage = _Image.default.createFrom(this, {
        width,
        height,
        position: [shiftX, shiftY]
      });
      switch (interpolationToUse) {
        case _checks.validInterpolations.nearestneighbor:
          _nearestNeighbor.default.call(this, newImage, width, height);
          break;
        default:
          throw new Error(`unsupported resize interpolation: ${interpolationToUse}`);
      }
      return newImage;
    }
  }
});

// node_modules/image-js/lib/image/transform/hsv.js
var require_hsv = __commonJS({
  "node_modules/image-js/lib/image/transform/hsv.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = hsv;
    var _Image = _interopRequireDefault(require_Image());
    var _model = require_model();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function hsv() {
      this.checkProcessable("hsv", {
        bitDepth: [8, 16],
        alpha: [0, 1],
        colorModel: [_model.RGB]
      });
      let newImage = _Image.default.createFrom(this, {
        colorModel: _model.HSV
      });
      let ptr = 0;
      let data = this.data;
      for (let i = 0; i < data.length; i += this.channels) {
        let red = data[i];
        let green = data[i + 1];
        let blue = data[i + 2];
        let min = Math.min(red, green, blue);
        let max = Math.max(red, green, blue);
        let delta = max - min;
        let hue = 0;
        let saturation = max === 0 ? 0 : delta / max;
        let value = max;
        if (max !== min) {
          switch (max) {
            case red:
              hue = (green - blue) / delta + (green < blue ? 6 : 0);
              break;
            case green:
              hue = (blue - red) / delta + 2;
              break;
            case blue:
              hue = (red - green) / delta + 4;
              break;
            default:
              throw new Error("unreachable");
          }
          hue /= 6;
        }
        newImage.data[ptr++] = hue * this.maxValue;
        newImage.data[ptr++] = saturation * this.maxValue;
        newImage.data[ptr++] = value;
        if (this.alpha) {
          newImage.data[ptr++] = data[i + 3];
        }
      }
      return newImage;
    }
  }
});

// node_modules/image-js/lib/image/transform/hsl.js
var require_hsl = __commonJS({
  "node_modules/image-js/lib/image/transform/hsl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = hsl;
    var _Image = _interopRequireDefault(require_Image());
    var _model = require_model();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function hsl() {
      this.checkProcessable("hsl", {
        bitDepth: [8, 16],
        alpha: [0, 1],
        colorModel: [_model.RGB]
      });
      let newImage = _Image.default.createFrom(this, {
        colorModel: _model.HSL
      });
      let threshold = Math.floor(this.maxValue / 2);
      let ptr = 0;
      let data = this.data;
      for (let i = 0; i < data.length; i += this.channels) {
        let red = data[i];
        let green = data[i + 1];
        let blue = data[i + 2];
        let max = Math.max(red, green, blue);
        let min = Math.min(red, green, blue);
        let hue = 0;
        let saturation = 0;
        let luminance = (max + min) / 2;
        if (max !== min) {
          let delta = max - min;
          saturation = luminance > threshold ? delta / (2 - max - min) : delta / (max + min);
          switch (max) {
            case red:
              hue = (green - blue) / delta + (green < blue ? 6 : 0);
              break;
            case green:
              hue = (blue - red) / delta + 2;
              break;
            case blue:
              hue = (red - green) / delta + 4;
              break;
            default:
              throw new Error("unreachable");
          }
          hue /= 6;
        }
        newImage.data[ptr++] = hue * this.maxValue;
        newImage.data[ptr++] = saturation * this.maxValue;
        newImage.data[ptr++] = luminance;
        if (this.alpha) {
          newImage.data[ptr++] = data[i + 3];
        }
      }
      return newImage;
    }
  }
});

// node_modules/image-js/lib/image/transform/cmyk.js
var require_cmyk = __commonJS({
  "node_modules/image-js/lib/image/transform/cmyk.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = cmyk;
    var _Image = _interopRequireDefault(require_Image());
    var _model = require_model();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function cmyk() {
      this.checkProcessable("cmyk", {
        bitDepth: [8, 16],
        alpha: [0, 1],
        colorModel: [_model.RGB]
      });
      let newImage = _Image.default.createFrom(this, {
        components: 4,
        colorModel: _model.CMYK
      });
      let ptr = 0;
      let data = this.data;
      for (let i = 0; i < data.length; i += this.channels) {
        let red = data[i];
        let green = data[i + 1];
        let blue = data[i + 2];
        let black = Math.min(this.maxValue - red, this.maxValue - green, this.maxValue - blue);
        let cyan = (this.maxValue - red - black) / (1 - black / this.maxValue);
        let magenta = (this.maxValue - green - black) / (1 - black / this.maxValue);
        let yellow = (this.maxValue - blue - black) / (1 - black / this.maxValue);
        newImage.data[ptr++] = Math.round(cyan);
        newImage.data[ptr++] = Math.round(magenta);
        newImage.data[ptr++] = Math.round(yellow);
        newImage.data[ptr++] = Math.round(black);
        if (this.alpha) {
          newImage.data[ptr++] = data[i + 3];
        }
      }
      return newImage;
    }
  }
});

// node_modules/image-js/lib/image/transform/rgba8.js
var require_rgba8 = __commonJS({
  "node_modules/image-js/lib/image/transform/rgba8.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = rgba8;
    var _Image = _interopRequireDefault(require_Image());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function rgba8() {
      return new _Image.default(this.width, this.height, this.getRGBAData(), {
        kind: "RGBA",
        parent: this
      });
    }
  }
});

// node_modules/image-js/lib/image/transform/greyAlgorithms.js
var require_greyAlgorithms = __commonJS({
  "node_modules/image-js/lib/image/transform/greyAlgorithms.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.names = exports2.methods = void 0;
    var methods = exports2.methods = {
      luma709(red, green, blue) {
        return red * 6966 + green * 23436 + blue * 2366 >> 15;
      },
      luma601(red, green, blue) {
        return red * 9798 + green * 19235 + blue * 3735 >> 15;
      },
      maximum(red, green, blue) {
        return Math.max(red, green, blue);
      },
      minimum(red, green, blue) {
        return Math.min(red, green, blue);
      },
      average(red, green, blue) {
        return (red + green + blue) / 3 >> 0;
      },
      minmax(red, green, blue) {
        return (Math.max(red, green, blue) + Math.min(red, green, blue)) / 2;
      },
      red(red) {
        return red;
      },
      green(red, green) {
        return green;
      },
      blue(red, green, blue) {
        return blue;
      },
      cyan(red, green, blue, image) {
        let black = methods.black(red, green, blue, image);
        return (image.maxValue - red - black) / (1 - black / image.maxValue) >> 0;
      },
      magenta(red, green, blue, image) {
        let black = methods.black(red, green, blue, image);
        return (image.maxValue - green - black) / (1 - black / image.maxValue) >> 0;
      },
      yellow(red, green, blue, image) {
        let black = methods.black(red, green, blue, image);
        return (image.maxValue - blue - black) / (1 - black / image.maxValue) >> 0;
      },
      black(red, green, blue, image) {
        return Math.min(image.maxValue - red, image.maxValue - green, image.maxValue - blue);
      },
      hue(red, green, blue, image) {
        let min = methods.min(red, green, blue);
        let max = methods.max(red, green, blue);
        if (max === min) {
          return 0;
        }
        let hue = 0;
        let delta = max - min;
        switch (max) {
          case red:
            hue = (green - blue) / delta + (green < blue ? 6 : 0);
            break;
          case green:
            hue = (blue - red) / delta + 2;
            break;
          case blue:
            hue = (red - green) / delta + 4;
            break;
          default:
            throw new Error("unreachable");
        }
        return hue / 6 * image.maxValue >> 0;
      },
      saturation(red, green, blue, image) {
        let min = methods.min(red, green, blue);
        let max = methods.max(red, green, blue);
        let delta = max - min;
        return max === 0 ? 0 : delta / max * image.maxValue;
      },
      lightness(red, green, blue) {
        let min = methods.min(red, green, blue);
        let max = methods.max(red, green, blue);
        return (max + min) / 2;
      }
    };
    Object.defineProperty(methods, "luminosity", {
      enumerable: false,
      value: methods.lightness
    });
    Object.defineProperty(methods, "luminance", {
      enumerable: false,
      value: methods.lightness
    });
    Object.defineProperty(methods, "min", {
      enumerable: false,
      value: methods.minimum
    });
    Object.defineProperty(methods, "max", {
      enumerable: false,
      value: methods.maximum
    });
    Object.defineProperty(methods, "brightness", {
      enumerable: false,
      value: methods.maximum
    });
    var names = exports2.names = {};
    Object.keys(methods).forEach((name) => {
      names[name] = name;
    });
  }
});

// node_modules/image-js/lib/image/transform/grey.js
var require_grey = __commonJS({
  "node_modules/image-js/lib/image/transform/grey.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = grey;
    var _clamp = require_clamp();
    var _getOutputImage = require_getOutputImage();
    var _model = require_model();
    var _greyAlgorithms = require_greyAlgorithms();
    function grey(options = {}) {
      let {
        algorithm = "luma709",
        keepAlpha = false,
        mergeAlpha = true
      } = options;
      if (typeof algorithm !== "string" && typeof algorithm !== "function") {
        throw new TypeError("algorithm must be a string or a function");
      }
      this.checkProcessable("grey", {
        bitDepth: [8, 16],
        alpha: [0, 1]
      });
      if (this.components === 1) {
        algorithm = "red";
      }
      keepAlpha &= this.alpha;
      mergeAlpha &= this.alpha;
      if (keepAlpha) {
        mergeAlpha = false;
      }
      let newImage = (0, _getOutputImage.getOutputImage)(this, options, {
        components: 1,
        alpha: keepAlpha,
        colorModel: _model.GREY
      });
      let method;
      if (typeof algorithm === "function") {
        method = algorithm;
      } else {
        method = _greyAlgorithms.methods[algorithm.toLowerCase()];
        if (!method) {
          throw new Error(`unsupported grey algorithm: ${algorithm}`);
        }
      }
      let ptr = 0;
      for (let i = 0; i < this.data.length; i += this.channels) {
        if (mergeAlpha) {
          newImage.data[ptr++] = (0, _clamp.clamp)(method(this.data[i], this.data[i + 1], this.data[i + 2], this) * this.data[i + this.components] / this.maxValue, this);
        } else {
          newImage.data[ptr++] = (0, _clamp.clamp)(method(this.data[i], this.data[i + 1], this.data[i + 2], this), this);
          if (newImage.alpha) {
            newImage.data[ptr++] = this.data[i + this.components];
          }
        }
      }
      return newImage;
    }
  }
});

// node_modules/image-js/lib/image/transform/mask/huang.js
var require_huang = __commonJS({
  "node_modules/image-js/lib/image/transform/mask/huang.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = huang;
    function huang(histogram) {
      let firstBin = 0;
      for (let ih = 0; ih < histogram.length; ih++) {
        if (histogram[ih] !== 0) {
          firstBin = ih;
          break;
        }
      }
      let lastBin = histogram.length - 1;
      for (let ih = histogram.length - 1; ih >= firstBin; ih--) {
        if (histogram[ih] !== 0) {
          lastBin = ih;
          break;
        }
      }
      let term = 1 / (lastBin - firstBin);
      let mu0 = new Array(histogram.length);
      let sumPix = 0;
      let numPix = 0;
      for (let ih = firstBin; ih < histogram.length; ih++) {
        sumPix += ih * histogram[ih];
        numPix += histogram[ih];
        mu0[ih] = sumPix / numPix;
      }
      let mu1 = new Array(histogram.length);
      sumPix = numPix = 0;
      for (let ih = lastBin; ih > 0; ih--) {
        sumPix += ih * histogram[ih];
        numPix += histogram[ih];
        mu1[ih - 1] = sumPix / numPix;
      }
      let threshold = -1;
      let minEnt = Number.MAX_VALUE;
      for (let it = 0; it < histogram.length; it++) {
        let ent = 0;
        let muX;
        for (let ih = 0; ih <= it; ih++) {
          muX = 1 / (1 + term * Math.abs(ih - mu0[it]));
          if (!(muX < 1e-6 || muX > 0.999999)) {
            ent += histogram[ih] * (-muX * Math.log(muX) - (1 - muX) * Math.log(1 - muX));
          }
        }
        for (let ih = it + 1; ih < histogram.length; ih++) {
          muX = 1 / (1 + term * Math.abs(ih - mu1[it]));
          if (!(muX < 1e-6 || muX > 0.999999)) {
            ent += histogram[ih] * (-muX * Math.log(muX) - (1 - muX) * Math.log(1 - muX));
          }
        }
        if (ent < minEnt) {
          minEnt = ent;
          threshold = it;
        }
      }
      return threshold;
    }
  }
});

// node_modules/image-js/lib/image/transform/mask/intermodes.js
var require_intermodes = __commonJS({
  "node_modules/image-js/lib/image/transform/mask/intermodes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = intermodes;
    function intermodes(histogram) {
      let iHisto = histogram.slice();
      let iter = 0;
      while (!bimodalTest(iHisto)) {
        let previous = 0;
        let current = 0;
        let next = iHisto[0];
        for (let i = 0; i < histogram.length - 1; i++) {
          previous = current;
          current = next;
          next = iHisto[i + 1];
          iHisto[i] = (previous + current + next) / 3;
        }
        iHisto[histogram.length - 1] = (current + next) / 3;
        iter++;
        if (iter > 1e4) {
          throw new Error("Intermodes Threshold not found after 10000 iterations");
        }
      }
      let tt = 0;
      for (let i = 1; i < histogram.length - 1; i++) {
        if (iHisto[i - 1] < iHisto[i] && iHisto[i + 1] < iHisto[i]) {
          tt += i;
        }
      }
      return Math.floor(tt / 2);
    }
    function bimodalTest(iHisto) {
      let b = false;
      let modes = 0;
      for (let k = 1; k < iHisto.length - 1; k++) {
        if (iHisto[k - 1] < iHisto[k] && iHisto[k + 1] < iHisto[k]) {
          modes++;
          if (modes > 2) {
            return false;
          }
        }
      }
      if (modes === 2) {
        b = true;
      }
      return b;
    }
  }
});

// node_modules/image-js/lib/image/transform/mask/isodata.js
var require_isodata = __commonJS({
  "node_modules/image-js/lib/image/transform/mask/isodata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isodata;
    function isodata(histogram) {
      let l;
      let toth;
      let totl;
      let h;
      let g = 0;
      for (let i = 1; i < histogram.length; i++) {
        if (histogram[i] > 0) {
          g = i + 1;
          break;
        }
      }
      while (true) {
        l = 0;
        totl = 0;
        for (let i = 0; i < g; i++) {
          totl = totl + histogram[i];
          l = l + histogram[i] * i;
        }
        h = 0;
        toth = 0;
        for (let i = g + 1; i < histogram.length; i++) {
          toth += histogram[i];
          h += histogram[i] * i;
        }
        if (totl > 0 && toth > 0) {
          l /= totl;
          h /= toth;
          if (g === Math.round((l + h) / 2)) {
            break;
          }
        }
        g++;
        if (g > histogram.length - 2) {
          throw new Error("Threshold not found");
        }
      }
      return g;
    }
  }
});

// node_modules/image-js/lib/image/transform/mask/li.js
var require_li = __commonJS({
  "node_modules/image-js/lib/image/transform/mask/li.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = li;
    function li(histogram, total) {
      let threshold;
      let sumBack;
      let sumObj;
      let numBack;
      let numObj;
      let oldThresh;
      let newThresh;
      let meanBack;
      let meanObj;
      let mean;
      let tolerance;
      let temp;
      tolerance = 0.5;
      mean = 0;
      for (let ih = 0; ih < histogram.length; ih++) {
        mean += ih * histogram[ih];
      }
      mean /= total;
      newThresh = mean;
      do {
        oldThresh = newThresh;
        threshold = oldThresh + 0.5 | 0;
        sumBack = 0;
        numBack = 0;
        for (let ih = 0; ih <= threshold; ih++) {
          sumBack += ih * histogram[ih];
          numBack += histogram[ih];
        }
        meanBack = numBack === 0 ? 0 : sumBack / numBack;
        sumObj = 0;
        numObj = 0;
        for (let ih = threshold + 1; ih < histogram.length; ih++) {
          sumObj += ih * histogram[ih];
          numObj += histogram[ih];
        }
        meanObj = numObj === 0 ? 0 : sumObj / numObj;
        temp = (meanBack - meanObj) / (Math.log(meanBack) - Math.log(meanObj));
        if (temp < -Number.EPSILON) {
          newThresh = temp - 0.5 | 0;
        } else {
          newThresh = temp + 0.5 | 0;
        }
      } while (Math.abs(newThresh - oldThresh) > tolerance);
      return threshold;
    }
  }
});

// node_modules/image-js/lib/image/transform/mask/maxEntropy.js
var require_maxEntropy = __commonJS({
  "node_modules/image-js/lib/image/transform/mask/maxEntropy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = maxEntropy;
    function maxEntropy(histogram, total) {
      let normHisto = new Array(histogram.length);
      for (let ih = 0; ih < histogram.length; ih++) {
        normHisto[ih] = histogram[ih] / total;
      }
      let P1 = new Array(histogram.length);
      let P2 = new Array(histogram.length);
      P1[0] = normHisto[0];
      P2[0] = 1 - P1[0];
      for (let ih = 1; ih < histogram.length; ih++) {
        P1[ih] = P1[ih - 1] + normHisto[ih];
        P2[ih] = 1 - P1[ih];
      }
      let firstBin = 0;
      for (let ih = 0; ih < histogram.length; ih++) {
        if (Math.abs(P1[ih]) >= Number.EPSILON) {
          firstBin = ih;
          break;
        }
      }
      let lastBin = histogram.length - 1;
      for (let ih = histogram.length - 1; ih >= firstBin; ih--) {
        if (Math.abs(P2[ih]) >= Number.EPSILON) {
          lastBin = ih;
          break;
        }
      }
      let threshold = -1;
      let totEnt;
      let maxEnt = Number.MIN_VALUE;
      let entBack;
      let entObj;
      for (let it = firstBin; it <= lastBin; it++) {
        entBack = 0;
        for (let ih = 0; ih <= it; ih++) {
          if (histogram[ih] !== 0) {
            entBack -= normHisto[ih] / P1[it] * Math.log(normHisto[ih] / P1[it]);
          }
        }
        entObj = 0;
        for (let ih = it + 1; ih < histogram.length; ih++) {
          if (histogram[ih] !== 0) {
            entObj -= normHisto[ih] / P2[it] * Math.log(normHisto[ih] / P2[it]);
          }
        }
        totEnt = entBack + entObj;
        if (maxEnt < totEnt) {
          maxEnt = totEnt;
          threshold = it;
        }
      }
      return threshold;
    }
  }
});

// node_modules/image-js/lib/image/transform/mask/mean.js
var require_mean = __commonJS({
  "node_modules/image-js/lib/image/transform/mask/mean.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = mean;
    function mean(histogram, total) {
      let sum = 0;
      for (let i = 0; i < histogram.length; i++) {
        sum += i * histogram[i];
      }
      return Math.floor(sum / total);
    }
  }
});

// node_modules/image-js/lib/image/transform/mask/minError.js
var require_minError = __commonJS({
  "node_modules/image-js/lib/image/transform/mask/minError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = minError;
    function minError(histogram, total) {
      let threshold;
      let Tprev = -2;
      let mu, nu, p, q, sigma2, tau2, w0, w1, w2, sqterm, temp;
      let mean = 0;
      for (let ih = 0; ih < histogram.length; ih++) {
        mean += ih * histogram[ih];
      }
      mean /= total;
      threshold = mean;
      while (threshold !== Tprev) {
        let sumA1 = sumA(histogram, threshold);
        let sumA2 = sumA(histogram, histogram.length - 1);
        let sumB1 = sumB(histogram, threshold);
        let sumB2 = sumB(histogram, histogram.length - 1);
        let sumC1 = sumC(histogram, threshold);
        let sumC2 = sumC(histogram, histogram.length - 1);
        mu = sumB1 / sumA1;
        nu = (sumB2 - sumB1) / (sumA2 - sumA1);
        p = sumA1 / sumA2;
        q = (sumA2 - sumA1) / sumA2;
        sigma2 = sumC1 / sumA1 - mu * mu;
        tau2 = (sumC2 - sumC1) / (sumA2 - sumA1) - nu * nu;
        w0 = 1 / sigma2 - 1 / tau2;
        w1 = mu / sigma2 - nu / tau2;
        w2 = mu * mu / sigma2 - nu * nu / tau2 + Math.log10(sigma2 * (q * q) / (tau2 * (p * p)));
        sqterm = w1 * w1 - w0 * w2;
        if (sqterm < 0) {
          return threshold;
        }
        Tprev = threshold;
        temp = (w1 + Math.sqrt(sqterm)) / w0;
        if (isNaN(temp)) {
          threshold = Tprev;
        } else {
          threshold = Math.floor(temp);
        }
      }
      return threshold;
    }
    function sumA(y, j) {
      let x = 0;
      for (let i = 0; i <= j; i++) {
        x += y[i];
      }
      return x;
    }
    function sumB(y, j) {
      let x = 0;
      for (let i = 0; i <= j; i++) {
        x += i * y[i];
      }
      return x;
    }
    function sumC(y, j) {
      let x = 0;
      for (let i = 0; i <= j; i++) {
        x += i * i * y[i];
      }
      return x;
    }
  }
});

// node_modules/image-js/lib/image/transform/mask/minimum.js
var require_minimum = __commonJS({
  "node_modules/image-js/lib/image/transform/mask/minimum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = minimum;
    function minimum(histogram) {
      if (histogram.length < 2) {
        return 0;
      }
      let iterations = 0;
      let threshold = -1;
      let max = -1;
      let histogramCopy = new Array(histogram.length);
      for (let i = 0; i < histogram.length; i++) {
        histogramCopy[i] = histogram[i];
        if (histogram[i] > 0) {
          max = i;
        }
      }
      while (!bimodalTest(histogramCopy)) {
        histogramCopy = smoothed(histogramCopy);
        iterations++;
        if (iterations > 1e4) {
          return threshold;
        }
      }
      threshold = minimumBetweenPeeks(histogramCopy, max);
      return threshold;
    }
    function smoothed(histogram) {
      let auHistogram = new Array(histogram.length);
      for (let i = 1; i < histogram.length - 1; i++) {
        auHistogram[i] = (histogram[i - 1] + histogram[i] + histogram[i + 1]) / 3;
      }
      auHistogram[0] = (histogram[0] + histogram[1]) / 3;
      auHistogram[histogram.length - 1] = (histogram[histogram.length - 2] + histogram[histogram.length - 1]) / 3;
      return auHistogram;
    }
    function minimumBetweenPeeks(histogramBimodal, max) {
      let threshold;
      for (let i = 1; i < max; i++) {
        if (histogramBimodal[i - 1] > histogramBimodal[i] && histogramBimodal[i + 1] >= histogramBimodal[i]) {
          threshold = i;
          break;
        }
      }
      return threshold;
    }
    function bimodalTest(histogram) {
      let len = histogram.length;
      let isBimodal = false;
      let peaks = 0;
      for (let k = 1; k < len - 1; k++) {
        if (histogram[k - 1] < histogram[k] && histogram[k + 1] < histogram[k]) {
          peaks++;
          if (peaks > 2) {
            return false;
          }
        }
      }
      if (peaks === 2) {
        isBimodal = true;
      }
      return isBimodal;
    }
  }
});

// node_modules/image-js/lib/image/transform/mask/moments.js
var require_moments = __commonJS({
  "node_modules/image-js/lib/image/transform/mask/moments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = moments;
    function moments(histogram, total) {
      let m0 = 1;
      let m1 = 0;
      let m2 = 0;
      let m3 = 0;
      let sum = 0;
      let p0;
      let cd, c0, c1, z0, z1;
      let threshold = -1;
      let histogramLength = histogram.length;
      let normalizedHistogram = new Array(histogramLength);
      for (let i = 0; i < histogramLength; i++) {
        normalizedHistogram[i] = histogram[i] / total;
      }
      for (let i = 0; i < histogramLength; i++) {
        m1 += i * normalizedHistogram[i];
        m2 += i * i * normalizedHistogram[i];
        m3 += i * i * i * normalizedHistogram[i];
      }
      cd = m0 * m2 - m1 * m1;
      c0 = (-m2 * m2 + m1 * m3) / cd;
      c1 = (m0 * -m3 + m2 * m1) / cd;
      z0 = 0.5 * (-c1 - Math.sqrt(c1 * c1 - 4 * c0));
      z1 = 0.5 * (-c1 + Math.sqrt(c1 * c1 - 4 * c0));
      p0 = (z1 - m1) / (z1 - z0);
      for (let i = 0; i < histogramLength; i++) {
        sum += normalizedHistogram[i];
        if (sum > p0) {
          threshold = i;
          break;
        }
      }
      return threshold;
    }
  }
});

// node_modules/image-js/lib/image/transform/mask/otsu.js
var require_otsu = __commonJS({
  "node_modules/image-js/lib/image/transform/mask/otsu.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = otsu;
    function otsu(histogramCounts, total) {
      let sumB = 0;
      let wB = 0;
      let maximum = 0;
      let level = 0;
      let sum1 = 0;
      for (let i = 0; i < histogramCounts.length; i++) {
        sum1 += i * histogramCounts[i];
      }
      for (let ii = 0; ii < histogramCounts.length; ii++) {
        wB = wB + histogramCounts[ii];
        const wF = total - wB;
        if (wB === 0 || wF === 0) {
          continue;
        }
        sumB = sumB + ii * histogramCounts[ii];
        const mF = (sum1 - sumB) / wF;
        const between = wB * wF * (sumB / wB - mF) * (sumB / wB - mF);
        if (between >= maximum) {
          level = ii;
          maximum = between;
        }
      }
      return level;
    }
  }
});

// node_modules/image-js/lib/image/transform/mask/percentile.js
var require_percentile = __commonJS({
  "node_modules/image-js/lib/image/transform/mask/percentile.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = percentile;
    function percentile(histogram) {
      let threshold = -1;
      let percentile2 = 0.5;
      let avec = new Array(histogram.length);
      let total = partialSum(histogram, histogram.length - 1);
      let temp = 1;
      for (let i = 0; i < histogram.length; i++) {
        avec[i] = Math.abs(partialSum(histogram, i) / total - percentile2);
        if (avec[i] < temp) {
          temp = avec[i];
          threshold = i;
        }
      }
      return threshold;
    }
    function partialSum(histogram, endIndex) {
      let x = 0;
      for (let i = 0; i <= endIndex; i++) {
        x += histogram[i];
      }
      return x;
    }
  }
});

// node_modules/image-js/lib/image/transform/mask/renyiEntropy.js
var require_renyiEntropy = __commonJS({
  "node_modules/image-js/lib/image/transform/mask/renyiEntropy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = renyiEntropy;
    function renyiEntropy(histogram, total) {
      let optThreshold;
      let firstBin;
      let lastBin;
      let normHisto = new Array(histogram.length);
      let P1 = new Array(histogram.length);
      let P2 = new Array(histogram.length);
      let threshold1 = 0;
      let threshold2 = 0;
      let threshold3 = 0;
      let maxEnt1 = 0;
      let maxEnt2 = 0;
      let maxEnt3 = 0;
      let alpha2 = 0.5;
      let term2 = 1 / (1 - alpha2);
      let alpha3 = 2;
      let term3 = 1 / (1 - alpha3);
      for (let ih = 0; ih < histogram.length; ih++) {
        normHisto[ih] = histogram[ih] / total;
      }
      P1[0] = normHisto[0];
      P2[0] = 1 - P1[0];
      for (let ih = 1; ih < histogram.length; ih++) {
        P1[ih] = P1[ih - 1] + normHisto[ih];
        P2[ih] = 1 - P1[ih];
      }
      firstBin = 0;
      for (let ih = 0; ih < histogram.length; ih++) {
        if (Math.abs(P1[ih]) >= Number.EPSILON) {
          firstBin = ih;
          break;
        }
      }
      lastBin = histogram.length - 1;
      for (let ih = histogram.length - 1; ih >= firstBin; ih--) {
        if (Math.abs(P2[ih]) >= Number.EPSILON) {
          lastBin = ih;
          break;
        }
      }
      for (let it = firstBin; it <= lastBin; it++) {
        let entBack1 = 0;
        let entBack2 = 0;
        let entBack3 = 0;
        for (let ih = 0; ih <= it; ih++) {
          if (histogram[ih] !== 0) {
            entBack1 -= normHisto[ih] / P1[it] * Math.log(normHisto[ih] / P1[it]);
          }
          entBack2 += Math.sqrt(normHisto[ih] / P1[it]);
          entBack3 += normHisto[ih] * normHisto[ih] / (P1[it] * P1[it]);
        }
        let entObj1 = 0;
        let entObj2 = 0;
        let entObj3 = 0;
        for (let ih = it + 1; ih < histogram.length; ih++) {
          if (histogram[ih] !== 0) {
            entObj1 -= normHisto[ih] / P2[it] * Math.log(normHisto[ih] / P2[it]);
          }
          entObj2 += Math.sqrt(normHisto[ih] / P2[it]);
          entObj3 += normHisto[ih] * normHisto[ih] / (P2[it] * P2[it]);
        }
        let totEnt1 = entBack1 + entObj1;
        let totEnt2 = term2 * (entBack2 * entObj2 > 0 ? Math.log(entBack2 * entObj2) : 0);
        let totEnt3 = term3 * (entBack3 * entObj3 > 0 ? Math.log(entBack3 * entObj3) : 0);
        if (totEnt1 > maxEnt1) {
          maxEnt1 = totEnt1;
          threshold1 = it;
        }
        if (totEnt2 > maxEnt2) {
          maxEnt2 = totEnt2;
          threshold2 = it;
        }
        if (totEnt3 > maxEnt3) {
          maxEnt3 = totEnt3;
          threshold3 = it;
        }
      }
      let tStars = [threshold1, threshold2, threshold3];
      tStars.sort((a, b) => a - b);
      let betas;
      if (Math.abs(tStars[0] - tStars[1]) <= 5) {
        if (Math.abs(tStars[1] - tStars[2]) <= 5) {
          betas = [1, 2, 1];
        } else {
          betas = [0, 1, 3];
        }
      } else {
        if (Math.abs(tStars[1] - tStars[2]) <= 5) {
          betas = [3, 1, 0];
        } else {
          betas = [1, 2, 1];
        }
      }
      let omega = P1[tStars[2]] - P1[tStars[0]];
      optThreshold = Math.round(tStars[0] * (P1[tStars[0]] + 0.25 * omega * betas[0]) + 0.25 * tStars[1] * omega * betas[1] + tStars[2] * (P2[tStars[2]] + 0.25 * omega * betas[2]));
      return optThreshold;
    }
  }
});

// node_modules/image-js/lib/image/transform/mask/shanbhag.js
var require_shanbhag = __commonJS({
  "node_modules/image-js/lib/image/transform/mask/shanbhag.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = shanbhag;
    function shanbhag(histogram, total) {
      let normHisto = new Array(histogram.length);
      for (let ih = 0; ih < histogram.length; ih++) {
        normHisto[ih] = histogram[ih] / total;
      }
      let P1 = new Array(histogram.length);
      let P2 = new Array(histogram.length);
      P1[0] = normHisto[0];
      P2[0] = 1 - P1[0];
      for (let ih = 1; ih < histogram.length; ih++) {
        P1[ih] = P1[ih - 1] + normHisto[ih];
        P2[ih] = 1 - P1[ih];
      }
      let firstBin = 0;
      for (let ih = 0; ih < histogram.length; ih++) {
        if (Math.abs(P1[ih]) >= Number.EPSILON) {
          firstBin = ih;
          break;
        }
      }
      let lastBin = histogram.length - 1;
      for (let ih = histogram.length - 1; ih >= firstBin; ih--) {
        if (Math.abs(P2[ih]) >= Number.EPSILON) {
          lastBin = ih;
          break;
        }
      }
      let threshold = -1;
      let minEnt = Number.MAX_VALUE;
      let term;
      let totEnt;
      let entBack;
      let entObj;
      for (let it = firstBin; it <= lastBin; it++) {
        entBack = 0;
        term = 0.5 / P1[it];
        for (let ih = 1; ih <= it; ih++) {
          entBack -= normHisto[ih] * Math.log(1 - term * P1[ih - 1]);
        }
        entBack *= term;
        entObj = 0;
        term = 0.5 / P2[it];
        for (let ih = it + 1; ih < histogram.length; ih++) {
          entObj -= normHisto[ih] * Math.log(1 - term * P2[ih]);
        }
        entObj *= term;
        totEnt = Math.abs(entBack - entObj);
        if (totEnt < minEnt) {
          minEnt = totEnt;
          threshold = it;
        }
      }
      return threshold;
    }
  }
});

// node_modules/image-js/lib/image/transform/mask/triangle.js
var require_triangle = __commonJS({
  "node_modules/image-js/lib/image/transform/mask/triangle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = triangle;
    function triangle(histogram) {
      let min = 0;
      let dmax = 0;
      let max = 0;
      let min2 = 0;
      for (let i = 0; i < histogram.length; i++) {
        if (histogram[i] > 0) {
          min = i;
          break;
        }
      }
      if (min > 0) {
        min--;
      }
      for (let i = histogram.length - 1; i > 0; i--) {
        if (histogram[i] > 0) {
          min2 = i;
          break;
        }
      }
      if (min2 < histogram.length - 1) {
        min2++;
      }
      for (let i = 0; i < histogram.length; i++) {
        if (histogram[i] > dmax) {
          max = i;
          dmax = histogram[i];
        }
      }
      let inverted = false;
      if (max - min < min2 - max) {
        inverted = true;
        let left = 0;
        let right = histogram.length - 1;
        while (left < right) {
          let temp = histogram[left];
          histogram[left] = histogram[right];
          histogram[right] = temp;
          left++;
          right--;
        }
        min = histogram.length - 1 - min2;
        max = histogram.length - 1 - max;
      }
      if (min === max) {
        return min;
      }
      let nx, ny, d;
      nx = histogram[max];
      ny = min - max;
      d = Math.sqrt(nx * nx + ny * ny);
      nx /= d;
      ny /= d;
      d = nx * min + ny * histogram[min];
      let split = min;
      let splitDistance = 0;
      for (let i = min + 1; i <= max; i++) {
        let newDistance = nx * i + ny * histogram[i] - d;
        if (newDistance > splitDistance) {
          split = i;
          splitDistance = newDistance;
        }
      }
      split--;
      if (inverted) {
        let left = 0;
        let right = histogram.length - 1;
        while (left < right) {
          let temp = histogram[left];
          histogram[left] = histogram[right];
          histogram[right] = temp;
          left++;
          right--;
        }
        return histogram.length - 1 - split;
      } else {
        return split;
      }
    }
  }
});

// node_modules/image-js/lib/image/transform/mask/yen.js
var require_yen = __commonJS({
  "node_modules/image-js/lib/image/transform/mask/yen.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = yen;
    function yen(histogram, total) {
      let normHisto = new Array(histogram.length);
      for (let ih = 0; ih < histogram.length; ih++) {
        normHisto[ih] = histogram[ih] / total;
      }
      let P1 = new Array(histogram.length);
      P1[0] = normHisto[0];
      for (let ih = 1; ih < histogram.length; ih++) {
        P1[ih] = P1[ih - 1] + normHisto[ih];
      }
      let P1Sq = new Array(histogram.length);
      P1Sq[0] = normHisto[0] * normHisto[0];
      for (let ih = 1; ih < histogram.length; ih++) {
        P1Sq[ih] = P1Sq[ih - 1] + normHisto[ih] * normHisto[ih];
      }
      let P2Sq = new Array(histogram.length);
      P2Sq[histogram.length - 1] = 0;
      for (let ih = histogram.length - 2; ih >= 0; ih--) {
        P2Sq[ih] = P2Sq[ih + 1] + normHisto[ih + 1] * normHisto[ih + 1];
      }
      let threshold = -1;
      let maxCrit = Number.MIN_VALUE;
      let crit;
      for (let it = 0; it < histogram.length; it++) {
        crit = -1 * (P1Sq[it] * P2Sq[it] > 0 ? Math.log(P1Sq[it] * P2Sq[it]) : 0) + 2 * (P1[it] * (1 - P1[it]) > 0 ? Math.log(P1[it] * (1 - P1[it])) : 0);
        if (crit > maxCrit) {
          maxCrit = crit;
          threshold = it;
        }
      }
      return threshold;
    }
  }
});

// node_modules/image-js/lib/image/transform/mask/thresholdAlgorithms.js
var require_thresholdAlgorithms = __commonJS({
  "node_modules/image-js/lib/image/transform/mask/thresholdAlgorithms.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.names = exports2.methods = void 0;
    var _huang = _interopRequireDefault(require_huang());
    var _intermodes = _interopRequireDefault(require_intermodes());
    var _isodata = _interopRequireDefault(require_isodata());
    var _li = _interopRequireDefault(require_li());
    var _maxEntropy = _interopRequireDefault(require_maxEntropy());
    var _mean = _interopRequireDefault(require_mean());
    var _minError = _interopRequireDefault(require_minError());
    var _minimum = _interopRequireDefault(require_minimum());
    var _moments = _interopRequireDefault(require_moments());
    var _otsu = _interopRequireDefault(require_otsu());
    var _percentile = _interopRequireDefault(require_percentile());
    var _renyiEntropy = _interopRequireDefault(require_renyiEntropy());
    var _shanbhag = _interopRequireDefault(require_shanbhag());
    var _triangle = _interopRequireDefault(require_triangle());
    var _yen = _interopRequireDefault(require_yen());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var methods = exports2.methods = {
      huang: _huang.default,
      intermodes: _intermodes.default,
      isodata: _isodata.default,
      li: _li.default,
      maxentropy: _maxEntropy.default,
      mean: _mean.default,
      minerror: _minError.default,
      minimum: _minimum.default,
      moments: _moments.default,
      otsu: _otsu.default,
      percentile: _percentile.default,
      renyientropy: _renyiEntropy.default,
      shanbhag: _shanbhag.default,
      triangle: _triangle.default,
      yen: _yen.default
    };
    var names = exports2.names = {};
    Object.keys(methods).forEach((name) => {
      names[name] = name;
    });
  }
});

// node_modules/image-js/lib/image/utility/getThreshold.js
var require_getThreshold = __commonJS({
  "node_modules/image-js/lib/image/utility/getThreshold.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = getThreshold;
    var _thresholdAlgorithms = require_thresholdAlgorithms();
    function getThreshold(options = {}) {
      let {
        algorithm = _thresholdAlgorithms.names.otsu
      } = options;
      this.checkProcessable("getThreshold", {
        components: 1,
        bitDepth: [8, 16]
      });
      let method = _thresholdAlgorithms.methods[algorithm.toLowerCase()];
      if (method) {
        let histogram = this.getHistogram();
        return method(histogram, this.size);
      } else {
        throw new Error(`unknown thresholding algorithm: ${algorithm}`);
      }
    }
  }
});

// node_modules/image-js/lib/image/transform/mask/mask.js
var require_mask = __commonJS({
  "node_modules/image-js/lib/image/transform/mask/mask.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = mask;
    var _converter = require_converter();
    var _Image = _interopRequireDefault(require_Image());
    var _getThreshold = _interopRequireDefault(require_getThreshold());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var THRESHOLD = "threshold";
    function mask(options = {}) {
      let {
        algorithm = THRESHOLD,
        threshold = 0.5,
        useAlpha = true,
        invert = false
      } = options;
      this.checkProcessable("mask", {
        components: 1,
        bitDepth: [8, 16]
      });
      if (algorithm === THRESHOLD) {
        threshold = (0, _converter.getThreshold)(threshold, this.maxValue);
      } else {
        threshold = _getThreshold.default.call(this, options);
      }
      let newImage = new _Image.default(this.width, this.height, {
        kind: "BINARY",
        parent: this
      });
      let ptr = 0;
      if (this.alpha && useAlpha) {
        for (let i = 0; i < this.data.length; i += this.channels) {
          let value = this.data[i] + (this.maxValue - this.data[i]) * (this.maxValue - this.data[i + 1]) / this.maxValue;
          if (invert && value <= threshold || !invert && value >= threshold) {
            newImage.setBit(ptr);
          }
          ptr++;
        }
      } else {
        for (let i = 0; i < this.data.length; i += this.channels) {
          if (invert && this.data[i] <= threshold || !invert && this.data[i] >= threshold) {
            newImage.setBit(ptr);
          }
          ptr++;
        }
      }
      return newImage;
    }
  }
});

// node_modules/image-js/lib/image/internal/copy.js
var require_copy = __commonJS({
  "node_modules/image-js/lib/image/internal/copy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = copyImage;
    function copyImage(fromImage, toImage2, x, y) {
      let fromWidth = fromImage.width;
      let fromHeight = fromImage.height;
      let toWidth = toImage2.width;
      let channels = fromImage.channels;
      for (let i = 0; i < fromWidth; i++) {
        for (let j = 0; j < fromHeight; j++) {
          for (let k = 0; k < channels; k++) {
            let source = (j * fromWidth + i) * channels + k;
            let target = ((y + j) * toWidth + x + i) * channels + k;
            toImage2.data[target] = fromImage.data[source];
          }
        }
      }
    }
  }
});

// node_modules/image-js/lib/image/transform/pad.js
var require_pad = __commonJS({
  "node_modules/image-js/lib/image/transform/pad.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = pad;
    var _newArray = _interopRequireDefault(require_new_array());
    var _Image = _interopRequireDefault(require_Image());
    var _copy = _interopRequireDefault(require_copy());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function pad(options = {}) {
      let {
        size = 0,
        algorithm = "copy",
        color
      } = options;
      this.checkProcessable("pad", {
        bitDepth: [8, 16]
      });
      if (algorithm === "set") {
        if (color.length !== this.channels) {
          throw new Error(`pad: the color array must have the same length as the number of channels. Here: ${this.channels}`);
        }
        for (let i = 0; i < color.length; i++) {
          if (color[i] === 0) {
            color[i] = 1e-3;
          }
        }
      } else {
        color = (0, _newArray.default)(this.channels, null);
      }
      if (!Array.isArray(size)) {
        size = [size, size];
      }
      let newWidth = this.width + size[0] * 2;
      let newHeight = this.height + size[1] * 2;
      let channels = this.channels;
      let newImage = _Image.default.createFrom(this, {
        width: newWidth,
        height: newHeight
      });
      (0, _copy.default)(this, newImage, size[0], size[1]);
      for (let i = size[0]; i < newWidth - size[0]; i++) {
        for (let k = 0; k < channels; k++) {
          let value = color[k] || newImage.data[(size[1] * newWidth + i) * channels + k];
          for (let j = 0; j < size[1]; j++) {
            newImage.data[(j * newWidth + i) * channels + k] = value;
          }
          value = color[k] || newImage.data[((newHeight - size[1] - 1) * newWidth + i) * channels + k];
          for (let j = newHeight - size[1]; j < newHeight; j++) {
            newImage.data[(j * newWidth + i) * channels + k] = value;
          }
        }
      }
      for (let j = 0; j < newHeight; j++) {
        for (let k = 0; k < channels; k++) {
          let value = color[k] || newImage.data[(j * newWidth + size[0]) * channels + k];
          for (let i = 0; i < size[0]; i++) {
            newImage.data[(j * newWidth + i) * channels + k] = value;
          }
          value = color[k] || newImage.data[(j * newWidth + newWidth - size[0] - 1) * channels + k];
          for (let i = newWidth - size[0]; i < newWidth; i++) {
            newImage.data[(j * newWidth + i) * channels + k] = value;
          }
        }
      }
      return newImage;
    }
  }
});

// node_modules/image-js/lib/image/transform/colorDepth.js
var require_colorDepth = __commonJS({
  "node_modules/image-js/lib/image/transform/colorDepth.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = colorDepth;
    var _Image = _interopRequireDefault(require_Image());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function colorDepth(newColorDepth = 8) {
      this.checkProcessable("colorDepth", {
        bitDepth: [1, 8, 16]
      });
      if (![8, 16].includes(newColorDepth)) {
        throw Error("You need to specify the new colorDepth as 8 or 16");
      }
      if (this.bitDepth === newColorDepth) {
        return this.clone();
      }
      let newImage = _Image.default.createFrom(this, {
        bitDepth: newColorDepth
      });
      switch (newColorDepth) {
        case 8:
          if (this.bitDepth === 1) {
            for (let i = 0; i < this.size; i++) {
              if (this.getBit(i)) {
                newImage.data[i] = 255;
              }
            }
          } else {
            for (let i = 0; i < this.data.length; i++) {
              newImage.data[i] = this.data[i] >> 8;
            }
          }
          break;
        case 16:
          if (this.bitDepth === 1) {
            for (let i = 0; i < this.size; i++) {
              if (this.getBit(i)) {
                newImage.data[i] = 65535;
              }
            }
          } else {
            for (let i = 0; i < this.data.length; i++) {
              newImage.data[i] = this.data[i] << 8 | this.data[i];
            }
          }
          break;
        default:
          throw new Error("colorDepth conversion unexpected case");
      }
      return newImage;
    }
  }
});

// node_modules/image-js/lib/image/transform/rotateFree.js
var require_rotateFree = __commonJS({
  "node_modules/image-js/lib/image/transform/rotateFree.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = rotateFree;
    var _Image = _interopRequireDefault(require_Image());
    var _checks = require_checks();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function rotateFree(degrees, options = {}) {
      const {
        interpolation = _checks.validInterpolations.nearestneighbor,
        width = this.width,
        height = this.height
      } = options;
      if (typeof degrees !== "number") {
        throw new TypeError("degrees must be a number");
      }
      const interpolationToUse = (0, _checks.checkInterpolation)(interpolation);
      const radians = degrees * Math.PI / 180;
      const newWidth = Math.floor(Math.abs(width * Math.cos(radians)) + Math.abs(height * Math.sin(radians)));
      const newHeight = Math.floor(Math.abs(height * Math.cos(radians)) + Math.abs(width * Math.sin(radians)));
      const cos = Math.cos(-radians);
      const sin = Math.sin(-radians);
      let x0 = newWidth / 2;
      let y0 = newHeight / 2;
      if (newWidth % 2 === 0) {
        x0 = x0 - 0.5;
        if (newHeight % 2 === 0) {
          y0 = y0 - 0.5;
        } else {
          y0 = Math.floor(y0);
        }
      } else {
        x0 = Math.floor(x0);
        if (newHeight % 2 === 0) {
          y0 = y0 - 0.5;
        } else {
          y0 = Math.floor(y0);
        }
      }
      const incrementX = Math.floor(width / 2 - x0);
      const incrementY = Math.floor(height / 2 - y0);
      if (this.bitDepth === 1) {
        const newImage = new _Image.default(newWidth, newHeight, {
          kind: "BINARY",
          parent: this
        });
        switch (interpolationToUse) {
          case _checks.validInterpolations.nearestneighbor:
            return rotateBinaryNearestNeighbor(this, newImage, incrementX, incrementY, x0, y0, cos, sin);
          case _checks.validInterpolations.bilinear:
            return rotateBinaryBilinear(this, newImage, incrementX, incrementY, x0, y0, cos, sin);
          default:
            throw new Error(`unsupported rotate interpolation: ${interpolationToUse}`);
        }
      } else {
        const newImage = _Image.default.createFrom(this, {
          width: newWidth,
          height: newHeight
        });
        switch (interpolationToUse) {
          case _checks.validInterpolations.nearestneighbor:
            return rotateNearestNeighbor(this, newImage, incrementX, incrementY, x0, y0, cos, sin);
          case _checks.validInterpolations.bilinear:
            return rotateBilinear(this, newImage, incrementX, incrementY, x0, y0, cos, sin);
          default:
            throw new Error(`unsupported rotate interpolation: ${interpolationToUse}`);
        }
      }
    }
    function rotateNearestNeighbor(thisImage, newImage, incrementX, incrementY, x0, y0, cos, sin) {
      for (let i = 0; i < newImage.width; i += 1) {
        for (let j = 0; j < newImage.height; j += 1) {
          for (let c = 0; c < thisImage.channels; c++) {
            let x = Math.round((i - x0) * cos - (j - y0) * sin + x0) + incrementX;
            let y = Math.round((j - y0) * cos + (i - x0) * sin + y0) + incrementY;
            if (x < 0 || x >= thisImage.width || y < 0 || y >= thisImage.height) {
              if (thisImage.alpha === 1 && c === thisImage.channels - 1) {
                newImage.setValueXY(i, j, c, 0);
              } else {
                newImage.setValueXY(i, j, c, thisImage.maxValue);
              }
            } else {
              newImage.setValueXY(i, j, c, thisImage.getValueXY(x, y, c));
            }
          }
        }
      }
      return newImage;
    }
    function rotateBinaryNearestNeighbor(thisImage, newImage, incrementX, incrementY, x0, y0, cos, sin) {
      for (let i = 0; i < newImage.width; i += 1) {
        for (let j = 0; j < newImage.height; j += 1) {
          let x = Math.round((i - x0) * cos - (j - y0) * sin + x0) + incrementX;
          let y = Math.round((j - y0) * cos + (i - x0) * sin + y0) + incrementY;
          if (x < 0 || x >= thisImage.width || y < 0 || y >= thisImage.height || thisImage.getBitXY(x, y)) {
            newImage.setBitXY(i, j);
          }
        }
      }
      return newImage;
    }
    function rotateBilinear(thisImage, newImage, incrementX, incrementY, x0, y0, cos, sin) {
      let stride = thisImage.width * thisImage.channels;
      for (let j = 0; j < newImage.height; j++) {
        for (let i = 0; i < newImage.width; i++) {
          let x = (i - x0) * cos - (j - y0) * sin + x0 + incrementX;
          let y = (j - y0) * cos + (i - x0) * sin + y0 + incrementY;
          let x1 = x | 0;
          let y1 = y | 0;
          let xDiff = x - x1;
          let yDiff = y - y1;
          for (let c = 0; c < thisImage.channels; c++) {
            if (x < 0 || x >= thisImage.width || y < 0 || y >= thisImage.height) {
              if (thisImage.alpha === 1 && c === thisImage.channels - 1) {
                newImage.setValueXY(i, j, c, 0);
              } else {
                newImage.setValueXY(i, j, c, thisImage.maxValue);
              }
            } else {
              let index = (y1 * thisImage.width + x1) * thisImage.channels + c;
              let A = thisImage.data[index];
              let B = thisImage.data[index + thisImage.channels];
              let C = thisImage.data[index + stride];
              let D = thisImage.data[index + stride + thisImage.channels];
              let result = A + xDiff * (B - A) + yDiff * (C - A) + xDiff * yDiff * (A - B - C + D) | 0;
              newImage.setValueXY(i, j, c, result);
            }
          }
        }
      }
      return newImage;
    }
    function rotateBinaryBilinear(thisImage, newImage, incrementX, incrementY, x0, y0, cos, sin) {
      let stride = thisImage.width;
      for (let j = 0; j < newImage.height; j++) {
        for (let i = 0; i < newImage.width; i++) {
          let x = (i - x0) * cos - (j - y0) * sin + x0 + incrementX;
          let y = (j - y0) * cos + (i - x0) * sin + y0 + incrementY;
          let x1 = x | 0;
          let y1 = y | 0;
          let xDiff = x - x1;
          let yDiff = y - y1;
          if (x < 0 || x >= thisImage.width || y < 0 || y >= thisImage.height) {
            newImage.setBitXY(i, j);
          } else {
            let index = y1 * thisImage.width + x1;
            let A = thisImage.getBit(index);
            let B = thisImage.getBit(index + 1);
            let C = thisImage.getBit(index + stride);
            let D = thisImage.getBit(index + 1 + stride);
            let result = A | xDiff & B - A | yDiff & C - A | xDiff & yDiff & A - B - C + D;
            if (result > 0)
              newImage.setBitXY(i, j);
          }
        }
      }
      return newImage;
    }
  }
});

// node_modules/image-js/lib/image/transform/rotate.js
var require_rotate = __commonJS({
  "node_modules/image-js/lib/image/transform/rotate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.rotate = rotate;
    exports2.rotateLeft = rotateLeft;
    exports2.rotateRight = rotateRight;
    var _Image = _interopRequireDefault(require_Image());
    var _rotateFree = _interopRequireDefault(require_rotateFree());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function rotate(angle, options) {
      this.checkProcessable("rotate", {
        bitDepth: [1, 8, 16]
      });
      if (typeof angle !== "number") {
        throw new TypeError("angle must be a number");
      }
      if (angle < 0) {
        angle = Math.ceil(-angle / 360) * 360 + angle;
      }
      switch (angle % 360) {
        case 0:
          return this.clone();
        case 90:
          return rotateRight.call(this);
        case 180:
          return rotate180.call(this);
        case 270:
          return rotateLeft.call(this);
        default:
          return _rotateFree.default.call(this, angle, options);
      }
    }
    function rotateLeft() {
      if (this.bitDepth === 1) {
        const newImage = new _Image.default(this.height, this.width, {
          kind: "BINARY",
          parent: this
        });
        const newMaxHeight = newImage.height - 1;
        for (let i = 0; i < this.height; i++) {
          for (let j = 0; j < this.width; j++) {
            if (this.getBitXY(j, i)) {
              newImage.setBitXY(i, newMaxHeight - j);
            }
          }
        }
        return newImage;
      } else {
        const newImage = _Image.default.createFrom(this, {
          width: this.height,
          height: this.width
        });
        const newMaxHeight = newImage.height - 1;
        for (let i = 0; i < this.height; i++) {
          for (let j = 0; j < this.width; j++) {
            for (let k = 0; k < this.channels; k++) {
              newImage.setValueXY(i, newMaxHeight - j, k, this.getValueXY(j, i, k));
            }
          }
        }
        return newImage;
      }
    }
    function rotateRight() {
      if (this.bitDepth === 1) {
        const newImage = new _Image.default(this.height, this.width, {
          kind: "BINARY",
          parent: this
        });
        const newMaxWidth = newImage.width - 1;
        for (let i = 0; i < this.height; i++) {
          for (let j = 0; j < this.width; j++) {
            if (this.getBitXY(j, i)) {
              newImage.setBitXY(newMaxWidth - i, j);
            }
          }
        }
        return newImage;
      } else {
        const newImage = _Image.default.createFrom(this, {
          width: this.height,
          height: this.width
        });
        const newMaxWidth = newImage.width - 1;
        for (let i = 0; i < this.height; i++) {
          for (let j = 0; j < this.width; j++) {
            for (let k = 0; k < this.channels; k++) {
              newImage.setValueXY(newMaxWidth - i, j, k, this.getValueXY(j, i, k));
            }
          }
        }
        return newImage;
      }
    }
    function rotate180() {
      if (this.bitDepth === 1) {
        const newImage = new _Image.default(this.width, this.height, {
          kind: "BINARY",
          parent: this
        });
        const newMaxWidth = newImage.width - 1;
        const newMaxHeight = newImage.height - 1;
        for (let i = 0; i < this.height; i++) {
          for (let j = 0; j < this.width; j++) {
            if (this.getBitXY(j, i)) {
              newImage.setBitXY(newMaxWidth - j, newMaxHeight - i);
            }
          }
        }
        return newImage;
      } else {
        const newImage = _Image.default.createFrom(this);
        const newMaxWidth = newImage.width - 1;
        const newMaxHeight = newImage.height - 1;
        for (let i = 0; i < this.height; i++) {
          for (let j = 0; j < this.width; j++) {
            for (let k = 0; k < this.channels; k++) {
              newImage.setValueXY(newMaxWidth - j, newMaxHeight - i, k, this.getValueXY(j, i, k));
            }
          }
        }
        return newImage;
      }
    }
  }
});

// node_modules/image-js/lib/image/transform/insert.js
var require_insert = __commonJS({
  "node_modules/image-js/lib/image/transform/insert.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = insert;
    var _getImageParameters = _interopRequireDefault(require_getImageParameters());
    var _getOutputImage = require_getOutputImage();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function insert(toInsert, options = {}) {
      const parameters = (0, _getImageParameters.default)(toInsert);
      this.checkProcessable("insert", parameters);
      let {
        x = 0,
        y = 0
      } = options;
      const out = (0, _getOutputImage.getOutputImageOrInPlace)(this, options, {
        copy: true
      });
      const maxY = Math.min(out.height, y + toInsert.height);
      const maxX = Math.min(out.width, x + toInsert.width);
      if (out.bitDepth === 1) {
        for (let j = y; j < maxY; j++) {
          for (let i = x; i < maxX; i++) {
            const val = toInsert.getBitXY(i - x, j - y);
            if (val)
              out.setBitXY(i, j);
            else
              out.clearBitXY(i, j);
          }
        }
      } else {
        for (let j = y; j < maxY; j++) {
          for (let i = x; i < maxX; i++) {
            out.setPixelXY(i, j, toInsert.getPixelXY(i - x, j - y));
          }
        }
      }
      return out;
    }
  }
});

// node_modules/image-js/lib/image/utility/setBorder.js
var require_setBorder = __commonJS({
  "node_modules/image-js/lib/image/utility/setBorder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = setBorder;
    var _newArray = _interopRequireDefault(require_new_array());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function setBorder(options = {}) {
      let {
        size = 0,
        algorithm = "copy",
        color
      } = options;
      this.checkProcessable("setBorder", {
        bitDepth: [8, 16, 32, 64]
      });
      if (algorithm === "set") {
        if (color.length !== this.channels) {
          throw new Error(`setBorder: the color array must have the same length as the number of channels. Here: ${this.channels}`);
        }
        for (let i = 0; i < color.length; i++) {
          if (color[i] === 0) {
            color[i] = 1e-3;
          }
        }
      } else {
        color = (0, _newArray.default)(this.channels, null);
      }
      if (!Array.isArray(size)) {
        size = [size, size];
      }
      let leftRightSize = size[0];
      let topBottomSize = size[1];
      let channels = this.channels;
      for (let i = leftRightSize; i < this.width - leftRightSize; i++) {
        for (let k = 0; k < channels; k++) {
          let value = color[k] || this.data[(i + this.width * topBottomSize) * channels + k];
          for (let j = 0; j < topBottomSize; j++) {
            this.data[(j * this.width + i) * channels + k] = value;
          }
          value = color[k] || this.data[(i + this.width * (this.height - topBottomSize - 1)) * channels + k];
          for (let j = this.height - topBottomSize; j < this.height; j++) {
            this.data[(j * this.width + i) * channels + k] = value;
          }
        }
      }
      for (let j = 0; j < this.height; j++) {
        for (let k = 0; k < channels; k++) {
          let value = color[k] || this.data[(j * this.width + leftRightSize) * channels + k];
          for (let i = 0; i < leftRightSize; i++) {
            this.data[(j * this.width + i) * channels + k] = value;
          }
          value = color[k] || this.data[(j * this.width + this.width - leftRightSize - 1) * channels + k];
          for (let i = this.width - leftRightSize; i < this.width; i++) {
            this.data[(j * this.width + i) * channels + k] = value;
          }
        }
      }
      return this;
    }
  }
});

// node_modules/image-js/lib/image/utility/split.js
var require_split = __commonJS({
  "node_modules/image-js/lib/image/utility/split.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = split;
    var _Stack = _interopRequireDefault(require_Stack());
    var _Image = _interopRequireDefault(require_Image());
    var _model = require_model();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function split(options = {}) {
      let {
        preserveAlpha = true
      } = options;
      this.checkProcessable("split", {
        bitDepth: [8, 16]
      });
      if (this.components === 1) {
        return new _Stack.default([this.clone()]);
      }
      let images = new _Stack.default();
      let data = this.data;
      if (this.alpha && preserveAlpha) {
        for (let i = 0; i < this.components; i++) {
          let newImage = _Image.default.createFrom(this, {
            components: 1,
            alpha: true,
            colorModel: _model.GREY
          });
          let ptr = 0;
          for (let j = 0; j < data.length; j += this.channels) {
            newImage.data[ptr++] = data[j + i];
            newImage.data[ptr++] = data[j + this.components];
          }
          images.push(newImage);
        }
      } else {
        for (let i = 0; i < this.channels; i++) {
          let newImage = _Image.default.createFrom(this, {
            components: 1,
            alpha: false,
            colorModel: _model.GREY
          });
          let ptr = 0;
          for (let j = 0; j < data.length; j += this.channels) {
            newImage.data[ptr++] = data[j + i];
          }
          images.push(newImage);
        }
      }
      return images;
    }
  }
});

// node_modules/image-js/lib/image/utility/getChannel.js
var require_getChannel = __commonJS({
  "node_modules/image-js/lib/image/utility/getChannel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = getChannel;
    var _channel = require_channel();
    var _Image = _interopRequireDefault(require_Image());
    var _model = require_model();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function getChannel(channel, options = {}) {
      let {
        keepAlpha = false,
        mergeAlpha = false
      } = options;
      keepAlpha &= this.alpha;
      mergeAlpha &= this.alpha;
      this.checkProcessable("getChannel", {
        bitDepth: [8, 16]
      });
      channel = (0, _channel.validateChannel)(this, channel);
      let newImage = _Image.default.createFrom(this, {
        components: 1,
        alpha: keepAlpha,
        colorModel: _model.GREY
      });
      let ptr = 0;
      for (let j = 0; j < this.data.length; j += this.channels) {
        if (mergeAlpha) {
          newImage.data[ptr++] = this.data[j + channel] * this.data[j + this.components] / this.maxValue;
        } else {
          newImage.data[ptr++] = this.data[j + channel];
          if (keepAlpha) {
            newImage.data[ptr++] = this.data[j + this.components];
          }
        }
      }
      return newImage;
    }
  }
});

// node_modules/image-js/lib/image/utility/combineChannels.js
var require_combineChannels = __commonJS({
  "node_modules/image-js/lib/image/utility/combineChannels.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = combineChannels;
    var _Image = _interopRequireDefault(require_Image());
    var _model = require_model();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function combineChannels(method = defaultCombineMethod, options = {}) {
      let {
        mergeAlpha = false,
        keepAlpha = false
      } = options;
      mergeAlpha &= this.alpha;
      keepAlpha &= this.alpha;
      this.checkProcessable("combineChannels", {
        bitDepth: [8, 16]
      });
      let newImage = _Image.default.createFrom(this, {
        components: 1,
        alpha: keepAlpha,
        colorModel: _model.GREY
      });
      let ptr = 0;
      for (let i = 0; i < this.size; i++) {
        let value = method(this.getPixel(i));
        if (mergeAlpha) {
          newImage.data[ptr++] = value * this.data[i * this.channels + this.components] / this.maxValue;
        } else {
          newImage.data[ptr++] = value;
          if (keepAlpha) {
            newImage.data[ptr++] = this.data[i * this.channels + this.components];
          }
        }
      }
      return newImage;
    }
    function defaultCombineMethod(pixel) {
      return (pixel[0] + pixel[1] + pixel[2]) / 3;
    }
  }
});

// node_modules/image-js/lib/image/utility/setChannel.js
var require_setChannel = __commonJS({
  "node_modules/image-js/lib/image/utility/setChannel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = setChannel;
    var _channel = require_channel();
    function setChannel(channel, image) {
      this.checkProcessable("setChannel", {
        bitDepth: [8, 16]
      });
      image.checkProcessable("setChannel (image parameter check)", {
        bitDepth: [this.bitDepth],
        alpha: [0],
        components: [1]
      });
      if (image.width !== this.width || image.height !== this.height) {
        throw new Error("Images must have exactly the same width and height");
      }
      channel = (0, _channel.validateChannel)(this, channel);
      let ptr = channel;
      for (let i = 0; i < image.data.length; i++) {
        this.data[ptr] = image.data[i];
        ptr += this.channels;
      }
      return this;
    }
  }
});

// node_modules/image-js/lib/image/utility/getSimilarity.js
var require_getSimilarity = __commonJS({
  "node_modules/image-js/lib/image/utility/getSimilarity.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = getSimilarity;
    var _newArray = _interopRequireDefault(require_new_array());
    var _channel = require_channel();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function getSimilarity(image, options = {}) {
      let {
        shift = [0, 0],
        average,
        channels,
        defaultAlpha,
        normalize,
        border = [0, 0]
      } = options;
      this.checkProcessable("getSimilarity", {
        bitDepth: [8, 16]
      });
      if (!Array.isArray(border)) {
        border = [border, border];
      }
      channels = (0, _channel.validateArrayOfChannels)(this, {
        channels,
        defaultAlpha
      });
      if (this.bitDepth !== image.bitDepth) {
        throw new Error("Both images must have the same bitDepth");
      }
      if (this.channels !== image.channels) {
        throw new Error("Both images must have the same number of channels");
      }
      if (this.colorModel !== image.colorModel) {
        throw new Error("Both images must have the same colorModel");
      }
      if (typeof average === "undefined") {
        average = true;
      }
      let minX = Math.max(border[0], -shift[0]);
      let maxX = Math.min(this.width - border[0], this.width - shift[0]);
      let minY = Math.max(border[1], -shift[1]);
      let maxY = Math.min(this.height - border[1], this.height - shift[1]);
      let results = (0, _newArray.default)(channels.length, 0);
      for (let i = 0; i < channels.length; i++) {
        let c = channels[i];
        let sumThis = normalize ? this.sum[c] : Math.max(this.sum[c], image.sum[c]);
        let sumImage = normalize ? image.sum[c] : Math.max(this.sum[c], image.sum[c]);
        if (sumThis !== 0 && sumImage !== 0) {
          for (let x = minX; x < maxX; x++) {
            for (let y = minY; y < maxY; y++) {
              let indexThis = x * this.multiplierX + y * this.multiplierY + c;
              let indexImage = indexThis + shift[0] * this.multiplierX + shift[1] * this.multiplierY;
              results[i] += Math.min(this.data[indexThis] / sumThis, image.data[indexImage] / sumImage);
            }
          }
        }
      }
      if (average) {
        return results.reduce((sum, x) => sum + x) / results.length;
      }
      return results;
    }
  }
});

// node_modules/image-js/lib/image/utility/getPixelsGrid.js
var require_getPixelsGrid = __commonJS({
  "node_modules/image-js/lib/image/utility/getPixelsGrid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = getPixelsGrid;
    function getPixelsGrid(options = {}) {
      let {
        sampling = [10, 10],
        painted = false,
        mask
      } = options;
      this.checkProcessable("getPixelsGrid", {
        bitDepth: [8, 16],
        channels: 1
      });
      if (!Array.isArray(sampling)) {
        sampling = [sampling, sampling];
      }
      const xSampling = sampling[0];
      const ySampling = sampling[1];
      const xyS = [];
      const zS = [];
      const xStep = this.width / xSampling;
      const yStep = this.height / ySampling;
      let currentX = Math.floor(xStep / 2);
      for (let i = 0; i < xSampling; i++) {
        let currentY = Math.floor(yStep / 2);
        for (let j = 0; j < ySampling; j++) {
          let x = Math.round(currentX);
          let y = Math.round(currentY);
          if (!mask || mask.getBitXY(x, y)) {
            xyS.push([x, y]);
            zS.push(this.getPixelXY(x, y));
          }
          currentY += yStep;
        }
        currentX += xStep;
      }
      const toReturn = {
        xyS,
        zS
      };
      if (painted) {
        toReturn.painted = this.rgba8().paintPoints(xyS);
      }
      return toReturn;
    }
  }
});

// node_modules/image-js/lib/util/matrix.js
var require_matrix2 = __commonJS({
  "node_modules/image-js/lib/util/matrix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = Matrix;
    function Matrix(width, height, defaultValue) {
      const matrix = new Array(width);
      for (let x = 0; x < width; x++) {
        matrix[x] = new Array(height);
      }
      if (defaultValue) {
        for (let x = 0; x < width; x++) {
          for (let y = 0; y < height; y++) {
            matrix[x][y] = defaultValue;
          }
        }
      }
      matrix.width = width;
      matrix.height = height;
      Object.setPrototypeOf(matrix, Matrix.prototype);
      return matrix;
    }
    Matrix.prototype.localMin = function(x, y) {
      let min = this[x][y];
      let position = [x, y];
      for (let i = Math.max(0, x - 1); i < Math.min(this.length, x + 2); i++) {
        for (let j = Math.max(0, y - 1); j < Math.min(this[0].length, y + 2); j++) {
          if (this[i][j] < min) {
            min = this[i][j];
            position = [i, j];
          }
        }
      }
      return {
        position,
        value: min
      };
    };
    Matrix.prototype.localMax = function(x, y) {
      let max = this[x][y];
      let position = [x, y];
      for (let i = Math.max(0, x - 1); i < Math.min(this.length, x + 2); i++) {
        for (let j = Math.max(0, y - 1); j < Math.min(this[0].length, y + 2); j++) {
          if (this[i][j] > max) {
            max = this[i][j];
            position = [i, j];
          }
        }
      }
      return {
        position,
        value: max
      };
    };
    Matrix.prototype.localSearch = function(x, y, value) {
      let results = [];
      for (let i = Math.max(0, x - 1); i < Math.min(this.length, x + 2); i++) {
        for (let j = Math.max(0, y - 1); j < Math.min(this[0].length, y + 2); j++) {
          if (this[i][j] === value) {
            results.push([i, j]);
          }
        }
      }
      return results;
    };
  }
});

// node_modules/image-js/lib/image/utility/getBestMatch.js
var require_getBestMatch = __commonJS({
  "node_modules/image-js/lib/image/utility/getBestMatch.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = getBestMatch;
    var _matrix = _interopRequireDefault(require_matrix2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function getBestMatch(image, options = {}) {
      let {
        border
      } = options;
      this.checkProcessable("getChannel", {
        bitDepth: [8, 16]
      });
      if (this.bitDepth !== image.bitDepth) {
        throw new Error("Both images must have the same bitDepth");
      }
      if (this.channels !== image.channels) {
        throw new Error("Both images must have the same number of channels");
      }
      if (this.colorModel !== image.colorModel) {
        throw new Error("Both images must have the same colorModel");
      }
      let similarityMatrix = new _matrix.default(image.width, image.height, -Infinity);
      let currentX = Math.floor(image.width / 2);
      let currentY = Math.floor(image.height / 2);
      let middleX = currentX;
      let middleY = currentY;
      let theEnd = false;
      while (!theEnd) {
        let toCalculatePositions = similarityMatrix.localSearch(currentX, currentY, -Infinity);
        for (let i = 0; i < toCalculatePositions.length; i++) {
          let position = toCalculatePositions[i];
          let similarity = this.getSimilarity(image, {
            border,
            shift: [middleX - position[0], middleY - position[1]]
          });
          similarityMatrix[position[0]][position[1]] = similarity;
        }
        let max = similarityMatrix.localMax(currentX, currentY);
        if (max.position[0] !== currentX || max.position[1] !== currentY) {
          currentX = max.position[0];
          currentY = max.position[1];
        } else {
          theEnd = true;
        }
      }
      return [currentX - middleX, currentY - middleY];
    }
  }
});

// node_modules/image-js/lib/image/utility/getRow.js
var require_getRow = __commonJS({
  "node_modules/image-js/lib/image/utility/getRow.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = getRow;
    var _checks = require_checks();
    function getRow(row, channel = 0) {
      this.checkProcessable("getRow", {
        bitDepth: [8, 16]
      });
      (0, _checks.checkRow)(this, row);
      (0, _checks.checkChannel)(this, channel);
      let array = new Array(this.width);
      let ptr = 0;
      let begin = row * this.width * this.channels + channel;
      let end = begin + this.width * this.channels;
      for (let j = begin; j < end; j += this.channels) {
        array[ptr++] = this.data[j];
      }
      return array;
    }
  }
});

// node_modules/image-js/lib/image/utility/getColumn.js
var require_getColumn = __commonJS({
  "node_modules/image-js/lib/image/utility/getColumn.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = getColumn;
    var _checks = require_checks();
    function getColumn(column, channel = 0) {
      this.checkProcessable("getColumn", {
        bitDepth: [8, 16]
      });
      (0, _checks.checkColumn)(this, column);
      (0, _checks.checkChannel)(this, channel);
      let array = new Array(this.height);
      let ptr = 0;
      let step = this.width * this.channels;
      for (let j = channel + column * this.channels; j < this.data.length; j += step) {
        array[ptr++] = this.data[j];
      }
      return array;
    }
  }
});

// node_modules/image-js/lib/image/utility/getMatrix.js
var require_getMatrix = __commonJS({
  "node_modules/image-js/lib/image/utility/getMatrix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = getMatrix;
    var _mlMatrix = require_matrix();
    function getMatrix(options = {}) {
      let {
        channel
      } = options;
      this.checkProcessable("getMatrix", {
        bitDepth: [8, 16]
      });
      if (channel === void 0) {
        if (this.components > 1) {
          throw new RangeError("You need to define the channel for an image that contains more than one channel");
        }
        channel = 0;
      }
      let matrix = new _mlMatrix.Matrix(this.height, this.width);
      for (let x = 0; x < this.height; x++) {
        for (let y = 0; y < this.width; y++) {
          matrix.set(x, y, this.getValueXY(y, x, channel));
        }
      }
      return matrix;
    }
  }
});

// node_modules/image-js/lib/image/utility/setMatrix.js
var require_setMatrix = __commonJS({
  "node_modules/image-js/lib/image/utility/setMatrix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = setMatrix;
    var _mlMatrix = require_matrix();
    function setMatrix(matrix, options = {}) {
      matrix = new _mlMatrix.Matrix(matrix);
      let {
        channel
      } = options;
      this.checkProcessable("getMatrix", {
        bitDepth: [8, 16]
      });
      if (channel === void 0) {
        if (this.components > 1) {
          throw new RangeError("You need to define the channel for an image that contains more than one channel");
        }
        channel = 0;
      }
      if (this.width !== matrix.columns || this.height !== matrix.rows) {
        throw new RangeError("The size of the matrix must be equal to the size of the image");
      }
      for (let x = 0; x < this.height; x++) {
        for (let y = 0; y < this.width; y++) {
          this.setValueXY(y, x, channel, matrix.get(x, y));
        }
      }
      return this;
    }
  }
});

// node_modules/image-js/lib/image/utility/getPixelsArray.js
var require_getPixelsArray = __commonJS({
  "node_modules/image-js/lib/image/utility/getPixelsArray.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = getPixelsArray;
    function getPixelsArray() {
      this.checkProcessable("getPixelsArray", {
        bitDepth: [8, 16, 32]
      });
      let array = new Array(this.size);
      let ptr = 0;
      for (let i = 0; i < this.data.length; i += this.channels) {
        let pixel = new Array(this.components);
        for (let j = 0; j < this.components; j++) {
          pixel[j] = this.data[i + j];
        }
        array[ptr++] = pixel;
      }
      return array;
    }
  }
});

// node_modules/image-js/lib/image/utility/getIntersection.js
var require_getIntersection = __commonJS({
  "node_modules/image-js/lib/image/utility/getIntersection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = getIntersection;
    function getIntersection(mask2) {
      let mask1 = this;
      let closestParent = mask1.getClosestCommonParent(mask2);
      let startPos1 = mask1.getRelativePosition(closestParent, {
        defaultFurther: true
      });
      let allRelPos1 = getRelativePositionForAllPixels(mask1, startPos1);
      let startPos2 = mask2.getRelativePosition(closestParent, {
        defaultFurther: true
      });
      let allRelPos2 = getRelativePositionForAllPixels(mask2, startPos2);
      let commonSurface = getCommonSurface(allRelPos1, allRelPos2);
      let intersection = {
        whitePixelsMask1: [],
        whitePixelsMask2: [],
        commonWhitePixels: []
      };
      for (let i = 0; i < commonSurface.length; i++) {
        let currentRelativePos = commonSurface[i];
        let realPos1 = [currentRelativePos[0] - startPos1[0], currentRelativePos[1] - startPos1[1]];
        let realPos2 = [currentRelativePos[0] - startPos2[0], currentRelativePos[1] - startPos2[1]];
        let valueBitMask1 = mask1.getBitXY(realPos1[0], realPos1[1]);
        let valueBitMask2 = mask2.getBitXY(realPos2[0], realPos2[1]);
        if (valueBitMask1 === 1 && valueBitMask2 === 1) {
          intersection.commonWhitePixels.push(currentRelativePos);
        }
      }
      for (let i = 0; i < allRelPos1.length; i++) {
        let posX;
        let posY;
        if (i !== 0) {
          posX = Math.floor(i / mask1.width);
          posY = i % mask1.width;
        }
        if (mask1.getBitXY(posX, posY) === 1) {
          intersection.whitePixelsMask1.push(allRelPos1[i]);
        }
      }
      for (let i = 0; i < allRelPos2.length; i++) {
        let posX = 0;
        let posY = 0;
        if (i !== 0) {
          posX = Math.floor(i / mask2.width);
          posY = i % mask2.width;
        }
        if (mask2.getBitXY(posX, posY) === 1) {
          intersection.whitePixelsMask2.push(allRelPos2[i]);
        }
      }
      return intersection;
    }
    function getRelativePositionForAllPixels(mask, startPosition) {
      let relativePositions = [];
      for (let i = 0; i < mask.height; i++) {
        for (let j = 0; j < mask.width; j++) {
          let originalPos = [i, j];
          relativePositions.push([originalPos[0] + startPosition[0], originalPos[1] + startPosition[1]]);
        }
      }
      return relativePositions;
    }
    function getCommonSurface(positionArray1, positionArray2) {
      let i = 0;
      let j = 0;
      let commonSurface = [];
      while (i < positionArray1.length && j < positionArray2.length) {
        if (positionArray1[i][0] === positionArray2[j][0] && positionArray1[i][1] === positionArray2[j][1]) {
          commonSurface.push(positionArray1[i]);
          i++;
          j++;
        } else if (positionArray1[i][0] < positionArray2[j][0] || positionArray1[i][0] === positionArray2[j][0] && positionArray1[i][1] < positionArray2[j][1]) {
          i++;
        } else {
          j++;
        }
      }
      return commonSurface;
    }
  }
});

// node_modules/image-js/lib/image/utility/getClosestCommonParent.js
var require_getClosestCommonParent = __commonJS({
  "node_modules/image-js/lib/image/utility/getClosestCommonParent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = getClosestCommonParent;
    function getClosestCommonParent(mask) {
      let depthMask1 = getDepth(this);
      let depthMask2 = getDepth(mask);
      let furthestParent;
      if (depthMask1 >= depthMask2) {
        furthestParent = getFurthestParent(this, depthMask1);
      } else {
        furthestParent = getFurthestParent(mask, depthMask2);
      }
      if (depthMask1 === 0 || depthMask2 === 0) {
        return furthestParent;
      }
      let m1 = this;
      let m2 = mask;
      while (depthMask1 !== depthMask2) {
        if (depthMask1 > depthMask2) {
          m1 = m1.parent;
          if (m1 === null) {
            return furthestParent;
          }
          depthMask1 = depthMask1 - 1;
        } else {
          m2 = m2.parent;
          if (m2 === null) {
            return furthestParent;
          }
          depthMask2 = depthMask2 - 1;
        }
      }
      while (m1 !== m2 && m1 !== null && m2 !== null) {
        m1 = m1.parent;
        m2 = m2.parent;
        if (m1 === null || m2 === null) {
          return furthestParent;
        }
      }
      if (m1 !== m2) {
        return furthestParent;
      }
      return m1;
    }
    function getDepth(mask) {
      let d = 0;
      let m = mask;
      while (m.parent != null) {
        m = m.parent;
        d++;
      }
      return d;
    }
    function getFurthestParent(mask, depth) {
      let m = mask;
      while (depth > 0) {
        m = m.parent;
        depth = depth - 1;
      }
      return m;
    }
  }
});

// node_modules/canny-edge-detector/lib/index.js
var require_lib18 = __commonJS({
  "node_modules/canny-edge-detector/lib/index.js"(exports2, module2) {
    "use strict";
    var defaultOptions = {
      lowThreshold: 10,
      highThreshold: 30,
      gaussianBlur: 1.1
    };
    var Gx = [
      [-1, 0, 1],
      [-2, 0, 2],
      [-1, 0, 1]
    ];
    var Gy = [
      [-1, -2, -1],
      [0, 0, 0],
      [1, 2, 1]
    ];
    var convOptions = {
      bitDepth: 32,
      mode: "periodic"
    };
    function cannyEdgeDetector(image, options) {
      image.checkProcessable("Canny edge detector", {
        bitDepth: 8,
        channels: 1,
        components: 1
      });
      options = Object.assign({}, defaultOptions, options);
      const width = image.width;
      const height = image.height;
      const brightness = image.maxValue;
      const gfOptions = {
        sigma: options.gaussianBlur,
        radius: 3
      };
      const gf = image.gaussianFilter(gfOptions);
      const gradientX = gf.convolution(Gy, convOptions);
      const gradientY = gf.convolution(Gx, convOptions);
      const G = gradientY.hypotenuse(gradientX);
      const Image2 = image.constructor;
      const nms = new Image2(width, height, {
        kind: "GREY",
        bitDepth: 32
      });
      const edges = new Image2(width, height, {
        kind: "GREY",
        bitDepth: 32
      });
      const finalImage = new Image2(width, height, {
        kind: "GREY"
      });
      for (var i = 1; i < width - 1; i++) {
        for (var j = 1; j < height - 1; j++) {
          var dir = (Math.round(Math.atan2(gradientY.getValueXY(i, j, 0), gradientX.getValueXY(i, j, 0)) * (5 / Math.PI)) + 5) % 5;
          if (!(dir === 0 && (G.getValueXY(i, j, 0) <= G.getValueXY(i, j - 1, 0) || G.getValueXY(i, j, 0) <= G.getValueXY(i, j + 1, 0)) || dir === 1 && (G.getValueXY(i, j, 0) <= G.getValueXY(i - 1, j + 1, 0) || G.getValueXY(i, j, 0) <= G.getValueXY(i + 1, j - 1, 0)) || dir === 2 && (G.getValueXY(i, j, 0) <= G.getValueXY(i - 1, j, 0) || G.getValueXY(i, j, 0) <= G.getValueXY(i + 1, j, 0)) || dir === 3 && (G.getValueXY(i, j, 0) <= G.getValueXY(i - 1, j - 1, 0) || G.getValueXY(i, j, 0) <= G.getValueXY(i + 1, j + 1, 0)))) {
            nms.setValueXY(i, j, 0, G.getValueXY(i, j, 0));
          }
        }
      }
      for (i = 0; i < width * height; ++i) {
        var currentNms = nms.data[i];
        var currentEdge = 0;
        if (currentNms > options.highThreshold) {
          currentEdge++;
          finalImage.data[i] = brightness;
        }
        if (currentNms > options.lowThreshold) {
          currentEdge++;
        }
        edges.data[i] = currentEdge;
      }
      var currentPixels = [];
      for (i = 1; i < width - 1; ++i) {
        for (j = 1; j < height - 1; ++j) {
          if (edges.getValueXY(i, j, 0) !== 1) {
            continue;
          }
          outer:
            for (var k = i - 1; k < i + 2; ++k) {
              for (var l = j - 1; l < j + 2; ++l) {
                if (edges.getValueXY(k, l, 0) === 2) {
                  currentPixels.push([i, j]);
                  finalImage.setValueXY(i, j, 0, brightness);
                  break outer;
                }
              }
            }
        }
      }
      while (currentPixels.length > 0) {
        var newPixels = [];
        for (i = 0; i < currentPixels.length; ++i) {
          for (j = -1; j < 2; ++j) {
            for (k = -1; k < 2; ++k) {
              if (j === 0 && k === 0) {
                continue;
              }
              var row = currentPixels[i][0] + j;
              var col = currentPixels[i][1] + k;
              if (edges.getValueXY(row, col, 0) === 1 && finalImage.getValueXY(row, col, 0) === 0) {
                newPixels.push([row, col]);
                finalImage.setValueXY(row, col, 0, brightness);
              }
            }
          }
        }
        currentPixels = newPixels;
      }
      return finalImage;
    }
    module2.exports = cannyEdgeDetector;
  }
});

// node_modules/image-js/lib/image/operator/cannyEdge.js
var require_cannyEdge = __commonJS({
  "node_modules/image-js/lib/image/operator/cannyEdge.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = cannyEdge;
    var _cannyEdgeDetector = _interopRequireDefault(require_lib18());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function cannyEdge(options) {
      return (0, _cannyEdgeDetector.default)(this, options);
    }
  }
});

// node_modules/image-js/lib/image/operator/extract.js
var require_extract = __commonJS({
  "node_modules/image-js/lib/image/operator/extract.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = extract;
    var _Image = _interopRequireDefault(require_Image());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function extract(mask, options = {}) {
      let {
        position
      } = options;
      this.checkProcessable("extract", {
        bitDepth: [1, 8, 16]
      });
      if (!position) {
        position = mask.getRelativePosition(this);
        if (!position) {
          throw new Error("extract : can not extract an image because the relative position can not be determined, try to specify manually the position as an array of 2 elements [x,y].");
        }
      }
      if (this.bitDepth > 1) {
        let extract2 = _Image.default.createFrom(this, {
          width: mask.width,
          height: mask.height,
          alpha: 1,
          // we force the alpha, otherwise difficult to extract a mask ...
          position,
          parent: this
        });
        for (let x = 0; x < mask.width; x++) {
          for (let y = 0; y < mask.height; y++) {
            for (let channel = 0; channel < this.channels; channel++) {
              let value = this.getValueXY(x + position[0], y + position[1], channel);
              extract2.setValueXY(x, y, channel, value);
            }
            if (!mask.getBitXY(x, y)) {
              extract2.setValueXY(x, y, this.components, 0);
            }
          }
        }
        return extract2;
      } else {
        let extract2 = _Image.default.createFrom(this, {
          width: mask.width,
          height: mask.height,
          position,
          parent: this
        });
        for (let y = 0; y < mask.height; y++) {
          for (let x = 0; x < mask.width; x++) {
            if (mask.getBitXY(x, y)) {
              if (this.getBitXY(x + position[0], y + position[1])) {
                extract2.setBitXY(x, y);
              }
            }
          }
        }
        return extract2;
      }
    }
  }
});

// node_modules/fast-list/fast-list.js
var require_fast_list = __commonJS({
  "node_modules/fast-list/fast-list.js"(exports2, module2) {
    (function() {
      function Item(data, prev, next) {
        this.next = next;
        if (next)
          next.prev = this;
        this.prev = prev;
        if (prev)
          prev.next = this;
        this.data = data;
      }
      function FastList() {
        if (!(this instanceof FastList))
          return new FastList();
        this._head = null;
        this._tail = null;
        this.length = 0;
      }
      FastList.prototype = {
        push: function(data) {
          this._tail = new Item(data, this._tail, null);
          if (!this._head)
            this._head = this._tail;
          this.length++;
        },
        pop: function() {
          if (this.length === 0)
            return void 0;
          var t = this._tail;
          this._tail = t.prev;
          if (t.prev) {
            t.prev = this._tail.next = null;
          }
          this.length--;
          if (this.length === 1)
            this._head = this._tail;
          else if (this.length === 0)
            this._head = this._tail = null;
          return t.data;
        },
        unshift: function(data) {
          this._head = new Item(data, null, this._head);
          if (!this._tail)
            this._tail = this._head;
          this.length++;
        },
        shift: function() {
          if (this.length === 0)
            return void 0;
          var h = this._head;
          this._head = h.next;
          if (h.next) {
            h.next = this._head.prev = null;
          }
          this.length--;
          if (this.length === 1)
            this._tail = this._head;
          else if (this.length === 0)
            this._head = this._tail = null;
          return h.data;
        },
        item: function(n) {
          if (n < 0)
            n = this.length + n;
          var h = this._head;
          while (n-- > 0 && h)
            h = h.next;
          return h ? h.data : void 0;
        },
        slice: function(n, m) {
          if (!n)
            n = 0;
          if (!m)
            m = this.length;
          if (m < 0)
            m = this.length + m;
          if (n < 0)
            n = this.length + n;
          if (m === n) {
            return [];
          }
          if (m < n) {
            throw new Error("invalid offset: " + n + "," + m + " (length=" + this.length + ")");
          }
          var len = m - n, ret = new Array(len), i = 0, h = this._head;
          while (n-- > 0 && h)
            h = h.next;
          while (i < len && h) {
            ret[i++] = h.data;
            h = h.next;
          }
          return ret;
        },
        drop: function() {
          FastList.call(this);
        },
        forEach: function(fn, thisp) {
          var p = this._head, i = 0, len = this.length;
          while (i < len && p) {
            fn.call(thisp || this, p.data, i, this);
            p = p.next;
            i++;
          }
        },
        map: function(fn, thisp) {
          var n = new FastList();
          this.forEach(function(v, i, me) {
            n.push(fn.call(thisp || me, v, i, me));
          });
          return n;
        },
        filter: function(fn, thisp) {
          var n = new FastList();
          this.forEach(function(v, i, me) {
            if (fn.call(thisp || me, v, i, me))
              n.push(v);
          });
          return n;
        },
        reduce: function(fn, val, thisp) {
          var i = 0, p = this._head, len = this.length;
          if (!val) {
            i = 1;
            val = p && p.data;
            p = p && p.next;
          }
          while (i < len && p) {
            val = fn.call(thisp || this, val, p.data, this);
            i++;
            p = p.next;
          }
          return val;
        }
      };
      if ("undefined" !== typeof exports2)
        module2.exports = FastList;
      else if ("function" === typeof define && define.amd) {
        define("FastList", function() {
          return FastList;
        });
      } else
        (function() {
          return this;
        })().FastList = FastList;
    })();
  }
});

// node_modules/image-js/lib/image/operator/floodFill.js
var require_floodFill = __commonJS({
  "node_modules/image-js/lib/image/operator/floodFill.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = floodFill;
    var _fastList = _interopRequireDefault(require_fast_list());
    var _Image = _interopRequireDefault(require_Image());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function floodFill(options = {}) {
      const {
        x = 0,
        y = 0,
        inPlace = true
      } = options;
      const destination = inPlace ? this : _Image.default.createFrom(this);
      this.checkProcessable("floodFill", {
        bitDepth: 1
      });
      const bit = this.getBitXY(x, y);
      if (bit)
        return destination;
      const queue = new _fastList.default();
      queue.push(new Node(x, y));
      while (queue.length > 0) {
        const node = queue.shift();
        destination.setBitXY(node.x, node.y);
        for (let i = node.x + 1; i < this.width; i++) {
          if (!destination.getBitXY(i, node.y) && !this.getBitXY(i, node.y)) {
            destination.setBitXY(i, node.y);
            if (node.y + 1 < this.height && !this.getBitXY(i, node.y + 1)) {
              queue.push(new Node(i, node.y + 1));
            }
            if (node.y - 1 >= 0 && !this.getBitXY(i, node.y - 1)) {
              queue.push(new Node(i, node.y - 1));
            }
          } else {
            break;
          }
        }
        for (let i = node.x - 1; i >= 0; i++) {
          if (!destination.getBitXY(i, node.y) && !this.getBitXY(i, node.y)) {
            destination.setBitXY(i, node.y);
            if (node.y + 1 < this.height && !this.getBitXY(i, node.y + 1)) {
              queue.push(new Node(i, node.y + 1));
            }
            if (node.y - 1 >= 0 && !this.getBitXY(i, node.y - 1)) {
              queue.push(new Node(i, node.y - 1));
            }
          } else {
            break;
          }
        }
      }
      return destination;
    }
    function Node(x, y) {
      this.x = x;
      this.y = y;
    }
  }
});

// node_modules/@babel/runtime/helpers/extends.js
var require_extends = __commonJS({
  "node_modules/@babel/runtime/helpers/extends.js"(exports2, module2) {
    function _extends() {
      module2.exports = _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
      return _extends.apply(this, arguments);
    }
    module2.exports = _extends, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@swiftcarrot/color-fns/dist/index.cjs.js
var require_index_cjs = __commonJS({
  "node_modules/@swiftcarrot/color-fns/dist/index.cjs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var _extends = _interopDefault(require_extends());
    function hex2rgb(hex) {
      if (hex[0] === "#")
        hex = hex.substr(1);
      if (hex.length === 3) {
        return {
          r: parseInt(hex[0] + hex[0], 16),
          g: parseInt(hex[1] + hex[1], 16),
          b: parseInt(hex[2] + hex[2], 16)
        };
      }
      return {
        r: parseInt(hex.substr(0, 2), 16),
        g: parseInt(hex.substr(2, 2), 16),
        b: parseInt(hex.substr(4, 2), 16)
      };
    }
    function hsv2rgb(h, s, v) {
      s = s / 100;
      v = v / 100;
      var rgb2 = [];
      var c = v * s;
      var hh = h / 60;
      var x = c * (1 - Math.abs(hh % 2 - 1));
      var m = v - c;
      if (hh >= 0 && hh < 1) {
        rgb2 = [c, x, 0];
      } else if (hh >= 1 && hh < 2) {
        rgb2 = [x, c, 0];
      } else if (hh >= 2 && hh < 3) {
        rgb2 = [0, c, x];
      } else if (h >= 3 && hh < 4) {
        rgb2 = [0, x, c];
      } else if (h >= 4 && hh < 5) {
        rgb2 = [x, 0, c];
      } else if (h >= 5 && hh <= 6) {
        rgb2 = [c, 0, x];
      } else {
        rgb2 = [0, 0, 0];
      }
      return {
        r: Math.round(255 * (rgb2[0] + m)),
        g: Math.round(255 * (rgb2[1] + m)),
        b: Math.round(255 * (rgb2[2] + m))
      };
    }
    function convert(num) {
      var hex = num.toString(16);
      return hex.length === 1 ? "0" + hex : hex;
    }
    function rgb2hex(r, g, b) {
      return "#" + [convert(r), convert(g), convert(b)].join("");
    }
    function hsv2hex(h, s, v) {
      var rgb2 = hsv2rgb(h, s, v);
      return rgb2hex(rgb2.r, rgb2.g, rgb2.b);
    }
    function rgb2hsv(r, g, b) {
      var h, s, v;
      var max = Math.max(r, g, b);
      var min = Math.min(r, g, b);
      var delta = max - min;
      if (delta === 0) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta % 6;
      } else if (g === max) {
        h = (b - r) / delta + 2;
      } else {
        h = (r - g) / delta + 4;
      }
      h = Math.round(h * 60);
      if (h < 0)
        h += 360;
      s = Math.round((max === 0 ? 0 : delta / max) * 100);
      v = Math.round(max / 255 * 100);
      return {
        h,
        s,
        v
      };
    }
    function rgba(r, g, b, a) {
      return "rgba(" + [r, g, b, a / 100].join(",") + ")";
    }
    function rgba2rgb(r, g, b, a) {
      a = a / 100;
      return {
        r: parseInt((1 - a) * 255 + a * r, 10),
        g: parseInt((1 - a) * 255 + a * g, 10),
        b: parseInt((1 - a) * 255 + a * b, 10)
      };
    }
    function rgba2hex(r, g, b, a) {
      var rgb2 = rgba2rgb(r, g, b, a);
      return rgb2hex(rgb2.r, rgb2.g, rgb2.b);
    }
    function hsl2hsv(h, s, l) {
      s *= (l < 50 ? l : 100 - l) / 100;
      return {
        h,
        s: 2 * s / (l + s) * 100,
        v: l + s
      };
    }
    function hsv2hsl(h, s, v) {
      var hh = (200 - s) * v / 100;
      return {
        h,
        s: s * v / (hh < 100 ? hh : 200 - hh),
        l: hh / 2
      };
    }
    function hsl2rgb(h, s, l) {
      var hsv = hsl2hsv(h, s, l);
      return hsv2rgb(hsv.h, hsv.s, hsv.v);
    }
    var colors = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 132, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 255, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 203],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [119, 128, 144],
      slategrey: [119, 128, 144],
      snow: [255, 255, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 5]
    };
    function parse(str) {
      return named(str) || hex3(str) || hex6(str) || rgb(str) || rgba$1(str) || hsl(str) || hsla(str);
    }
    function named(str) {
      var c = colors[str.toLowerCase()];
      if (!c)
        return;
      return {
        r: c[0],
        g: c[1],
        b: c[2],
        a: 100
      };
    }
    function rgb(str) {
      var m = str.match(/rgb\(([^)]+)\)/);
      if (m) {
        var parts = m[1].split(/ *, */).map(Number);
        return {
          r: parts[0],
          g: parts[1],
          b: parts[2],
          a: 100
        };
      }
    }
    function rgba$1(str) {
      var m = str.match(/rgba\(([^)]+)\)/);
      if (m) {
        var parts = m[1].split(/ *, */).map(Number);
        return {
          r: parts[0],
          g: parts[1],
          b: parts[2],
          a: parts[3] * 100
        };
      }
    }
    function hex6(str) {
      if ("#" === str[0] && 7 === str.length) {
        return {
          r: parseInt(str.slice(1, 3), 16),
          g: parseInt(str.slice(3, 5), 16),
          b: parseInt(str.slice(5, 7), 16),
          a: 100
        };
      }
    }
    function hex3(str) {
      if ("#" === str[0] && 4 === str.length) {
        return {
          r: parseInt(str[1] + str[1], 16),
          g: parseInt(str[2] + str[2], 16),
          b: parseInt(str[3] + str[3], 16),
          a: 100
        };
      }
    }
    function hsl(str) {
      var m = str.match(/hsl\(([^)]+)\)/);
      if (m) {
        var parts = m[1].split(/ *, */);
        var h = parseInt(parts[0], 10);
        var s = parseInt(parts[1], 10);
        var l = parseInt(parts[2], 10);
        var _rgb = hsl2rgb(h, s, l);
        return _extends({}, _rgb, {
          a: 100
        });
      }
    }
    function hsla(str) {
      var m = str.match(/hsla\(([^)]+)\)/);
      if (m) {
        var parts = m[1].split(/ *, */);
        var h = parseInt(parts[0], 10);
        var s = parseInt(parts[1], 10);
        var l = parseInt(parts[2], 10);
        var a = parseInt(parseFloat(parts[3]) * 100, 10);
        var _rgb2 = hsl2rgb(h, s, l);
        return _extends({}, _rgb2, {
          a
        });
      }
    }
    function hex2hsv(hex) {
      var _hex2rgb = hex2rgb(hex), r = _hex2rgb.r, g = _hex2rgb.g, b = _hex2rgb.b;
      return rgb2hsv(r, g, b);
    }
    function hex2hsl(hex) {
      var _hex2hsv = hex2hsv(hex), h = _hex2hsv.h, s = _hex2hsv.s, v = _hex2hsv.v;
      return hsv2hsl(h, s, v);
    }
    function hex2alpha(aa) {
      return Math.round(parseInt("0x" + aa, 16) / 255 * 100);
    }
    exports2.cssColor = parse;
    exports2.hex2alpha = hex2alpha;
    exports2.hex2hsl = hex2hsl;
    exports2.hex2hsv = hex2hsv;
    exports2.hex2rgb = hex2rgb;
    exports2.hsl2hsv = hsl2hsv;
    exports2.hsl2rgb = hsl2rgb;
    exports2.hsv2hex = hsv2hex;
    exports2.hsv2hsl = hsv2hsl;
    exports2.hsv2rgb = hsv2rgb;
    exports2.rgb2hex = rgb2hex;
    exports2.rgb2hsv = rgb2hsv;
    exports2.rgba = rgba;
    exports2.rgba2hex = rgba2hex;
    exports2.rgba2rgb = rgba2rgb;
  }
});

// node_modules/image-js/lib/util/color.js
var require_color = __commonJS({
  "node_modules/image-js/lib/util/color.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.css2array = css2array;
    exports2.getColors = getColors;
    exports2.getDistinctColors = getDistinctColors;
    exports2.getRandomColor = getRandomColor;
    var _colorFns = require_index_cjs();
    function css2array(string) {
      let color = (0, _colorFns.cssColor)(string);
      return [color.r, color.g, color.b, Math.round(color.a * 255 / 100)];
    }
    function hue2rgb(p, q, t) {
      if (t < 0) {
        t += 1;
      }
      if (t > 1) {
        t -= 1;
      }
      if (t < 1 / 6) {
        return p + (q - p) * 6 * t;
      }
      if (t < 1 / 2) {
        return q;
      }
      if (t < 2 / 3) {
        return p + (q - p) * (2 / 3 - t) * 6;
      }
      return p;
    }
    function hsl2rgb(h, s, l) {
      let m1, m2, hue, r, g, b;
      s /= 100;
      l /= 100;
      if (s === 0) {
        r = g = b = l * 255;
      } else {
        if (l <= 0.5) {
          m2 = l * (s + 1);
        } else {
          m2 = l + s - l * s;
        }
        m1 = l * 2 - m2;
        hue = h / 360;
        r = hue2rgb(m1, m2, hue + 1 / 3);
        g = hue2rgb(m1, m2, hue);
        b = hue2rgb(m1, m2, hue - 1 / 3);
      }
      return {
        r,
        g,
        b
      };
    }
    function getDistinctColors(numColors) {
      let colors = new Array(numColors);
      let j = 0;
      for (let i = 0; i < 360; i += 360 / numColors) {
        j++;
        let color = hsl2rgb(i, 100, 30 + j % 4 * 15);
        colors[j - 1] = [Math.round(color.r * 255), Math.round(color.g * 255), Math.round(color.b * 255)];
      }
      return colors;
    }
    function getRandomColor() {
      return [Math.floor(Math.random() * 256), Math.floor(Math.random() * 256), Math.floor(Math.random() * 256)];
    }
    function getColors(options) {
      let {
        color,
        colors,
        randomColors,
        // true / false
        numberColors = 50
      } = options;
      if (color && !Array.isArray(color)) {
        color = css2array(color);
      }
      if (color) {
        return [color];
      }
      if (colors) {
        colors = colors.map(function(color2) {
          if (!Array.isArray(color2)) {
            return css2array(color2);
          }
          return color2;
        });
        return colors;
      }
      if (randomColors) {
        colors = new Array(numberColors);
        for (let i = 0; i < numberColors; i++) {
          colors[i] = getRandomColor();
        }
      }
      return getDistinctColors(numberColors);
    }
  }
});

// node_modules/image-js/lib/image/operator/paintLabels.js
var require_paintLabels = __commonJS({
  "node_modules/image-js/lib/image/operator/paintLabels.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = paintLabels;
    var _color = require_color();
    var _model = require_model();
    function paintLabels(labels, positions, options = {}) {
      let {
        color = "blue",
        colors,
        font = "12px Helvetica",
        rotate = 0
      } = options;
      this.checkProcessable("paintMasks", {
        channels: [3, 4],
        bitDepth: [8, 16],
        colorModel: _model.RGB
      });
      if (!Array.isArray(labels)) {
        throw Error("paintLabels: labels must be an array");
      }
      if (!Array.isArray(positions)) {
        throw Error("paintLabels: positions must be an array");
      }
      if (color && !Array.isArray(color)) {
        color = (0, _color.css2array)(color);
      }
      if (colors) {
        colors = colors.map(function(color2) {
          if (!Array.isArray(color2)) {
            return (0, _color.css2array)(color2);
          }
          return color2;
        });
      } else {
        colors = [color];
      }
      if (labels.length !== positions.length) {
        throw Error("paintLabels: positions and labels must be arrays from the same size");
      }
      if (!Array.isArray(font))
        font = [font];
      if (!Array.isArray(rotate))
        rotate = [rotate];
      let canvas = this.getCanvas();
      let ctx = canvas.getContext("2d");
      for (let i = 0; i < labels.length; i++) {
        ctx.save();
        let color2 = colors[i % colors.length];
        ctx.fillStyle = `rgba(${color2[0]},${color2[1]},${color2[2]},${color2[3] / this.maxValue})`;
        ctx.font = font[i % font.length];
        let position = positions[i];
        ctx.translate(position[0], position[1]);
        ctx.rotate(rotate[i % rotate.length] / 180 * Math.PI);
        ctx.fillText(labels[i], 0, 0);
        ctx.restore();
      }
      this.data = Uint8Array.from(ctx.getImageData(0, 0, this.width, this.height).data);
      return this;
    }
  }
});

// node_modules/image-js/lib/image/operator/paintMasks.js
var require_paintMasks = __commonJS({
  "node_modules/image-js/lib/image/operator/paintMasks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = paintMasks;
    var _color = require_color();
    var _model = require_model();
    function paintMasks(masks, options = {}) {
      let {
        alpha = 255,
        labels = [],
        labelsPosition = [],
        labelColor = "blue",
        labelFont = "12px Helvetica"
      } = options;
      this.checkProcessable("paintMasks", {
        channels: [3, 4],
        bitDepth: [8, 16],
        colorModel: _model.RGB
      });
      let colors = (0, _color.getColors)(Object.assign({}, options, {
        numberColors: masks.length
      }));
      if (!Array.isArray(masks)) {
        masks = [masks];
      }
      for (let i = 0; i < masks.length; i++) {
        let mask = masks[i];
        let color = colors[i % colors.length];
        for (let x = 0; x < mask.width; x++) {
          for (let y = 0; y < mask.height; y++) {
            if (mask.getBitXY(x, y)) {
              for (let component = 0; component < Math.min(this.components, color.length); component++) {
                if (alpha === 255) {
                  this.setValueXY(x + mask.position[0], y + mask.position[1], component, color[component]);
                } else {
                  let value = this.getValueXY(x + mask.position[0], y + mask.position[1], component);
                  value = Math.round((value * (255 - alpha) + color[component] * alpha) / 255);
                  this.setValueXY(x + mask.position[0], y + mask.position[1], component, value);
                }
              }
            }
          }
        }
      }
      if (Array.isArray(labels) && labels.length > 0) {
        let canvas = this.getCanvas();
        let ctx = canvas.getContext("2d");
        ctx.fillStyle = labelColor;
        ctx.font = labelFont;
        for (let i = 0; i < Math.min(masks.length, labels.length); i++) {
          let position = labelsPosition[i] ? labelsPosition[i] : masks[i].position;
          ctx.fillText(labels[i], position[0], position[1]);
        }
        this.data = Uint8Array.from(ctx.getImageData(0, 0, this.width, this.height).data);
      }
      return this;
    }
  }
});

// node_modules/image-js/lib/util/zerosMatrix.js
var require_zerosMatrix = __commonJS({
  "node_modules/image-js/lib/util/zerosMatrix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = zerosMatrix;
    function zerosMatrix(height, width) {
      let matrix = new Array(height);
      for (let i = 0; i < height; i++) {
        matrix[i] = new Array(width).fill(0);
      }
      return matrix;
    }
  }
});

// node_modules/image-js/lib/util/Shape.js
var require_Shape = __commonJS({
  "node_modules/image-js/lib/util/Shape.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _Image = _interopRequireDefault(require_Image());
    var _kindNames = require_kindNames();
    var _zerosMatrix = _interopRequireDefault(require_zerosMatrix());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var cross = [[0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [1, 1, 1, 1, 1], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0]];
    var smallCross = [[0, 1, 0], [1, 1, 1], [0, 1, 0]];
    var Shape = class {
      constructor(options = {}) {
        let {
          kind = "cross",
          shape,
          size,
          width,
          height,
          filled = true
        } = options;
        if (size) {
          width = size;
          height = size;
        }
        if (shape) {
          switch (shape.toLowerCase()) {
            case "square":
            case "rectangle":
              this.matrix = rectangle(width, height, {
                filled
              });
              break;
            case "circle":
            case "ellipse":
              this.matrix = ellipse(width, height, {
                filled
              });
              break;
            case "triangle":
              this.matrix = triangle(width, height, {
                filled
              });
              break;
            default:
              throw new Error(`Shape: unexpected shape: ${shape}`);
          }
        } else if (kind) {
          switch (kind.toLowerCase()) {
            case "cross":
              this.matrix = cross;
              break;
            case "smallcross":
              this.matrix = smallCross;
              break;
            default:
              throw new Error(`Shape: unexpected kind: ${kind}`);
          }
        } else {
          throw new Error("Shape: expected a kind or a shape option");
        }
        this.height = this.matrix.length;
        this.width = this.matrix[0].length;
        this.halfHeight = this.height / 2 >> 0;
        this.halfWidth = this.width / 2 >> 0;
      }
      /**
       * Returns an array of [x,y] points
       * @return {Array<Array<number>>} - Array of [x,y] points
       */
      getPoints() {
        let matrix = this.matrix;
        let points = [];
        for (let y = 0; y < matrix.length; y++) {
          for (let x = 0; x < matrix[0].length; x++) {
            if (matrix[y][x]) {
              points.push([x - this.halfWidth, y - this.halfHeight]);
            }
          }
        }
        return points;
      }
      /**
       * Returns a Mask (1 bit Image) corresponding to this shape.
       * @return {Image}
       */
      getMask() {
        let img = new _Image.default(this.width, this.height, {
          kind: _kindNames.BINARY
        });
        for (let y = 0; y < this.matrix.length; y++) {
          for (let x = 0; x < this.matrix[0].length; x++) {
            if (this.matrix[y][x]) {
              img.setBitXY(x, y);
            }
          }
        }
        return img;
      }
    };
    exports2.default = Shape;
    function rectangle(width, height, options) {
      const matrix = (0, _zerosMatrix.default)(height, width);
      if (options.filled) {
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            matrix[y][x] = 1;
          }
        }
      } else {
        for (let y of [0, height - 1]) {
          for (let x = 0; x < width; x++) {
            matrix[y][x] = 1;
          }
        }
        for (let y = 0; y < height; y++) {
          for (let x of [0, width - 1]) {
            matrix[y][x] = 1;
          }
        }
      }
      return matrix;
    }
    function ellipse(width, height, options) {
      const matrix = (0, _zerosMatrix.default)(height, width, options);
      let yEven = 1 - height % 2;
      let xEven = 1 - width % 2;
      let a = Math.floor((width - 1) / 2);
      let b = Math.floor((height - 1) / 2);
      let a2 = a * a;
      let b2 = b * b;
      if (options.filled) {
        for (let y = 0; y <= b; y++) {
          let shift = Math.floor(Math.sqrt(a2 - a2 * y * y / b2));
          for (let x = a - shift; x <= a; x++) {
            matrix[b - y][x] = 1;
            matrix[b + y + yEven][x] = 1;
            matrix[b - y][width - x - 1] = 1;
            matrix[b + y + yEven][width - x - 1] = 1;
          }
        }
      } else {
        for (let y = 0; y <= b; y++) {
          let shift = Math.floor(Math.sqrt(a2 - a2 * y * y / b2));
          let x = a - shift;
          matrix[b - y][x] = 1;
          matrix[b + y + yEven][x] = 1;
          matrix[b - y][width - x - 1] = 1;
          matrix[b + y + yEven][width - x - 1] = 1;
        }
        for (let x = 0; x <= a; x++) {
          let shift = Math.floor(Math.sqrt(b2 - b2 * x * x / a2));
          let y = b - shift;
          matrix[y][a - x] = 1;
          matrix[y][a + x + xEven] = 1;
          matrix[height - y - 1][a - x] = 1;
          matrix[height - y - 1][a + x + xEven] = 1;
        }
      }
      return matrix;
    }
    function triangle(width, height, options) {
      if (!options.filled) {
        throw new Error("Non filled triangle is not implemented");
      }
      const matrix = (0, _zerosMatrix.default)(height, width, options);
      for (let y = 0; y < height; y++) {
        let shift = Math.floor((1 - y / height) * width / 2);
        for (let x = shift; x < width - shift; x++) {
          matrix[y][x] = 1;
        }
      }
      return matrix;
    }
  }
});

// node_modules/image-js/lib/image/operator/paintPoints.js
var require_paintPoints = __commonJS({
  "node_modules/image-js/lib/image/operator/paintPoints.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = paintPoints;
    var _Shape = _interopRequireDefault(require_Shape());
    var _color = require_color();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function paintPoints(points, options = {}) {
      let {
        shape
      } = options;
      this.checkProcessable("paintPoints", {
        bitDepth: [8, 16]
      });
      let colors = (0, _color.getColors)(Object.assign({}, options, {
        numberColors: points.length
      }));
      let shapePixels = new _Shape.default(shape).getPoints();
      let numberChannels = Math.min(this.channels, colors[0].length);
      for (let i = 0; i < points.length; i++) {
        let color = colors[i % colors.length];
        let xP = points[i][0];
        let yP = points[i][1];
        for (let j = 0; j < shapePixels.length; j++) {
          let xS = shapePixels[j][0];
          let yS = shapePixels[j][1];
          if (xP + xS >= 0 && yP + yS >= 0 && xP + xS < this.width && yP + yS < this.height) {
            let position = (xP + xS + (yP + yS) * this.width) * this.channels;
            for (let channel = 0; channel < numberChannels; channel++) {
              this.data[position + channel] = color[channel];
            }
          }
        }
      }
      return this;
    }
  }
});

// node_modules/image-js/lib/image/operator/paintPolyline.js
var require_paintPolyline = __commonJS({
  "node_modules/image-js/lib/image/operator/paintPolyline.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = paintPolyline;
    function paintPolyline(points, options = {}) {
      let {
        color = [this.maxValue, 0, 0],
        closed = false
      } = options;
      this.checkProcessable("paintPoints", {
        bitDepth: [1, 8, 16]
      });
      let numberChannels = Math.min(this.channels, color.length);
      for (let i = 0; i < points.length - 1 + closed; i++) {
        let from = points[i];
        let to = points[(i + 1) % points.length];
        let dx = to[0] - from[0];
        let dy = to[1] - from[1];
        let steps = Math.max(Math.abs(dx), Math.abs(dy));
        let xIncrement = dx / steps;
        let yIncrement = dy / steps;
        let x = from[0];
        let y = from[1];
        for (let j = 0; j <= steps; j++) {
          let xPoint = Math.round(x);
          let yPoint = Math.round(y);
          if (xPoint >= 0 && yPoint >= 0 && xPoint < this.width && yPoint < this.height) {
            if (this.bitDepth === 1) {
              this.setBitXY(xPoint, yPoint);
            } else {
              let position = (xPoint + yPoint * this.width) * this.channels;
              for (let channel = 0; channel < numberChannels; channel++) {
                this.data[position + channel] = color[channel];
              }
            }
          }
          x = x + xIncrement;
          y = y + yIncrement;
        }
      }
      return this;
    }
  }
});

// node_modules/image-js/lib/image/operator/paintPolylines.js
var require_paintPolylines = __commonJS({
  "node_modules/image-js/lib/image/operator/paintPolylines.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = paintPolylines;
    var _color = require_color();
    function paintPolylines(polylines, options = {}) {
      let optionsCopy = Object.assign({}, options);
      this.checkProcessable("paintPolylines", {
        bitDepth: [8, 16]
      });
      let colors = (0, _color.getColors)(Object.assign({}, options, {
        numberColors: polylines.length
      }));
      for (let i = 0; i < polylines.length; i++) {
        optionsCopy.color = colors[i % colors.length];
        this.paintPolyline(polylines[i], optionsCopy);
      }
      return this;
    }
  }
});

// node_modules/image-js/lib/image/operator/paintPolygon.js
var require_paintPolygon = __commonJS({
  "node_modules/image-js/lib/image/operator/paintPolygon.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = paintPolygon;
    function paintPolygon(points, options = {}) {
      let {
        color = [this.maxValue, 0, 0],
        filled = false
      } = options;
      this.checkProcessable("paintPoints", {
        bitDepth: [1, 8, 16]
      });
      options.closed = true;
      let filteredPoints = deleteDouble(points);
      if (filled === false) {
        return this.paintPolyline(points, options);
      } else {
        let matrixBinary = Array(this.height);
        for (let i = 0; i < this.height; i++) {
          matrixBinary[i] = [];
          for (let j = 0; j < this.width; j++) {
            matrixBinary[i].push(0);
          }
        }
        for (let p = 0; p < filteredPoints.length; p++) {
          const line = lineBetweenTwoPoints(filteredPoints[p], filteredPoints[(p + 1) % filteredPoints.length]);
          for (let y = 0; y < this.height; y++) {
            for (let x = 0; x < this.width; x++) {
              if (isAtTheRightOfTheLine(x, y, line, this.height)) {
                matrixBinary[y][x] = matrixBinary[y][x] === 0 ? 1 : 0;
              }
            }
          }
        }
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            if (matrixBinary[y][x] === 1) {
              if (this.bitDepth === 1) {
                this.setBitXY(x, y);
              } else {
                let numberChannels = Math.min(this.channels, color.length);
                let position = (x + y * this.width) * this.channels;
                for (let channel = 0; channel < numberChannels; channel++) {
                  this.data[position + channel] = color[channel];
                }
              }
            }
          }
        }
        return this.paintPolyline(points, options);
      }
    }
    function deleteDouble(points) {
      let finalPoints = [];
      for (let i = 0; i < points.length; i++) {
        if (points[i][0] === points[(i + 1) % points.length][0] && points[i][1] === points[(i + 1) % points.length][1]) {
          continue;
        } else if (points[i][0] === points[(i - 1 + points.length) % points.length][0] && points[i][1] === points[(i - 1 + points.length) % points.length][1]) {
          continue;
        } else if (points[(i + 1) % points.length][0] === points[(i - 1 + points.length) % points.length][0] && points[(i - 1 + points.length) % points.length][1] === points[(i + 1) % points.length][1]) {
          continue;
        } else {
          finalPoints.push(points[i]);
        }
      }
      return finalPoints;
    }
    function lineBetweenTwoPoints(p1, p2) {
      if (p1[0] === p2[0]) {
        return {
          a: 0,
          b: p1[0],
          vertical: true
        };
      } else {
        const coeffA = (p2[1] - p1[1]) / (p2[0] - p1[0]);
        const coeffB = p1[1] - coeffA * p1[0];
        return {
          a: coeffA,
          b: coeffB,
          vertical: false
        };
      }
    }
    function isAtTheRightOfTheLine(x, y, line, height) {
      if (line.vertical === true) {
        return line.b <= x;
      } else {
        if (line.a === 0) {
          return false;
        } else {
          const xline = (y - line.b) / line.a;
          return xline < x && xline >= 0 && xline <= height;
        }
      }
    }
  }
});

// node_modules/image-js/lib/image/operator/paintPolygons.js
var require_paintPolygons = __commonJS({
  "node_modules/image-js/lib/image/operator/paintPolygons.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = paintPolygons;
    var _color = require_color();
    function paintPolygons(polygons, options = {}) {
      let optionsCopy = Object.assign({}, options);
      this.checkProcessable("paintPolygons", {
        bitDepth: [8, 16]
      });
      let colors = (0, _color.getColors)(Object.assign({}, options, {
        numberColors: polygons.length
      }));
      for (let i = 0; i < polygons.length; i++) {
        optionsCopy.color = colors[i % colors.length];
        this.paintPolygon(polygons[i], optionsCopy);
      }
      return this;
    }
  }
});

// node_modules/image-js/lib/image/compute/histogram.js
var require_histogram3 = __commonJS({
  "node_modules/image-js/lib/image/compute/histogram.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getHistogram = getHistogram;
    exports2.getHistograms = getHistograms;
    var _isInteger = _interopRequireDefault(require_is_integer());
    var _newArray = _interopRequireDefault(require_new_array());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function getHistogram(options = {}) {
      let {
        maxSlots = 256,
        channel,
        useAlpha = true
      } = options;
      this.checkProcessable("getHistogram", {
        bitDepth: [1, 8, 16]
      });
      if (channel === void 0) {
        if (this.components > 1) {
          throw new RangeError("You need to define the channel for an image that contains more than one channel");
        }
        channel = 0;
      }
      return getChannelHistogram.call(this, channel, {
        useAlpha,
        maxSlots
      });
    }
    function getHistograms(options = {}) {
      const {
        maxSlots = 256,
        useAlpha = true
      } = options;
      this.checkProcessable("getHistograms", {
        bitDepth: [8, 16]
      });
      let results = new Array(useAlpha ? this.components : this.channels);
      for (let i = 0; i < results.length; i++) {
        results[i] = getChannelHistogram.call(this, i, {
          useAlpha,
          maxSlots
        });
      }
      return results;
    }
    function getChannelHistogram(channel, options) {
      let {
        useAlpha,
        maxSlots
      } = options;
      if (this.bitDepth === 1) {
        let blackWhiteCount = [0, 0];
        for (let i = 0; i < this.height; i++) {
          for (let j = 0; j < this.width; j++) {
            let value = this.getBitXY(i, j);
            if (value === 0) {
              blackWhiteCount[0] += 1;
            } else if (value === 1) {
              blackWhiteCount[1] += 1;
            }
          }
        }
        return blackWhiteCount;
      }
      let bitSlots = Math.log2(maxSlots);
      if (!(0, _isInteger.default)(bitSlots)) {
        throw new RangeError("maxSlots must be a power of 2, for example: 64, 256, 1024");
      }
      let bitShift = 0;
      if (this.bitDepth > bitSlots) {
        bitShift = this.bitDepth - bitSlots;
      }
      let data = this.data;
      let result = (0, _newArray.default)(Math.pow(2, Math.min(this.bitDepth, bitSlots)), 0);
      if (useAlpha && this.alpha) {
        let alphaChannelDiff = this.channels - channel - 1;
        for (let i = channel; i < data.length; i += this.channels) {
          result[data[i] >> bitShift] += data[i + alphaChannelDiff] / this.maxValue;
        }
      } else {
        for (let i = channel; i < data.length; i += this.channels) {
          result[data[i] >> bitShift]++;
        }
      }
      return result;
    }
  }
});

// node_modules/image-js/lib/image/compute/colorHistogram.js
var require_colorHistogram = __commonJS({
  "node_modules/image-js/lib/image/compute/colorHistogram.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = getColorHistogram;
    var _newArray = _interopRequireDefault(require_new_array());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function getColorHistogram(options = {}) {
      let {
        useAlpha = true,
        nbSlots = 512
      } = options;
      this.checkProcessable("getColorHistogram", {
        bitDepth: [8, 16],
        components: [3]
      });
      let nbSlotsCheck = Math.log(nbSlots) / Math.log(8);
      if (nbSlotsCheck !== Math.floor(nbSlotsCheck)) {
        throw new RangeError("nbSlots must be a power of 8. Usually 8, 64, 512 or 4096");
      }
      let bitShift = this.bitDepth - nbSlotsCheck;
      let data = this.data;
      let result = (0, _newArray.default)(Math.pow(8, nbSlotsCheck), 0);
      let factor2 = Math.pow(2, nbSlotsCheck * 2);
      let factor1 = Math.pow(2, nbSlotsCheck);
      for (let i = 0; i < data.length; i += this.channels) {
        let slot = (data[i] >> bitShift) * factor2 + (data[i + 1] >> bitShift) * factor1 + (data[i + 2] >> bitShift);
        if (useAlpha && this.alpha) {
          result[slot] += data[i + this.channels - 1] / this.maxValue;
        } else {
          result[slot]++;
        }
      }
      return result;
    }
  }
});

// node_modules/image-js/lib/image/compute/min.js
var require_min2 = __commonJS({
  "node_modules/image-js/lib/image/compute/min.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = min;
    var _newArray = _interopRequireDefault(require_new_array());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function min() {
      this.checkProcessable("min", {
        bitDepth: [8, 16, 32]
      });
      let result = (0, _newArray.default)(this.channels, Infinity);
      for (let i = 0; i < this.data.length; i += this.channels) {
        for (let c = 0; c < this.channels; c++) {
          if (this.data[i + c] < result[c]) {
            result[c] = this.data[i + c];
          }
        }
      }
      return result;
    }
  }
});

// node_modules/image-js/lib/image/compute/max.js
var require_max2 = __commonJS({
  "node_modules/image-js/lib/image/compute/max.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = max;
    var _newArray = _interopRequireDefault(require_new_array());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function max() {
      this.checkProcessable("max", {
        bitDepth: [8, 16, 32]
      });
      let result = (0, _newArray.default)(this.channels, -Infinity);
      for (let i = 0; i < this.data.length; i += this.channels) {
        for (let c = 0; c < this.channels; c++) {
          if (this.data[i + c] > result[c]) {
            result[c] = this.data[i + c];
          }
        }
      }
      return result;
    }
  }
});

// node_modules/image-js/lib/image/compute/sum.js
var require_sum = __commonJS({
  "node_modules/image-js/lib/image/compute/sum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = sum;
    var _newArray = _interopRequireDefault(require_new_array());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function sum() {
      this.checkProcessable("sum", {
        bitDepth: [8, 16]
      });
      let result = (0, _newArray.default)(this.channels, 0);
      for (let i = 0; i < this.data.length; i += this.channels) {
        for (let c = 0; c < this.channels; c++) {
          result[c] += this.data[i + c];
        }
      }
      return result;
    }
  }
});

// node_modules/image-js/lib/image/compute/moment.js
var require_moment = __commonJS({
  "node_modules/image-js/lib/image/compute/moment.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = getMoment;
    function getMoment(xPower = 0, yPower = 0) {
      this.checkProcessable("getMoment", {
        bitDepth: [1]
      });
      let m = 0;
      for (let x = 0; x < this.width; x++) {
        for (let y = 0; y < this.height; y++) {
          if (this.getBitXY(x, y) === 1) {
            m += x ** xPower * y ** yPower;
          }
        }
      }
      return m;
    }
  }
});

// node_modules/image-js/lib/image/compute/localMaxima.js
var require_localMaxima = __commonJS({
  "node_modules/image-js/lib/image/compute/localMaxima.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = localMaxima;
    function localMaxima(options = {}) {
      let {
        mask,
        region = 3,
        removeClosePoints = 0,
        invert = false,
        maxEquals = 2
      } = options;
      let image = this;
      this.checkProcessable("localMaxima", {
        bitDepth: [8, 16],
        components: 1
      });
      region *= 4;
      let maskExpectedValue = invert ? 0 : 1;
      let dx = [1, 0, -1, 0, 1, 1, -1, -1, 2, 0, -2, 0, 2, 2, -2, -2];
      let dy = [0, 1, 0, -1, 1, -1, 1, -1, 0, 2, 0, -2, 2, -2, 2, -2];
      let shift = region <= 8 ? 1 : 2;
      let points = [];
      for (let currentY = shift; currentY < image.height - shift; currentY++) {
        for (let currentX = shift; currentX < image.width - shift; currentX++) {
          if (mask && mask.getBitXY(currentX, currentY) !== maskExpectedValue) {
            continue;
          }
          let counter = 0;
          let nbEquals = 0;
          let currentValue = image.data[currentX + currentY * image.width];
          for (let dir = 0; dir < region; dir++) {
            if (invert) {
              if (image.data[currentX + dx[dir] + (currentY + dy[dir]) * image.width] > currentValue) {
                counter++;
              }
            } else {
              if (image.data[currentX + dx[dir] + (currentY + dy[dir]) * image.width] < currentValue) {
                counter++;
              }
            }
            if (image.data[currentX + dx[dir] + (currentY + dy[dir]) * image.width] === currentValue) {
              nbEquals++;
            }
          }
          if (counter + nbEquals === region && nbEquals <= maxEquals) {
            points.push([currentX, currentY]);
          }
        }
      }
      if (removeClosePoints > 0) {
        for (let i = 0; i < points.length; i++) {
          for (let j = i + 1; j < points.length; j++) {
            if (Math.sqrt(Math.pow(points[i][0] - points[j][0], 2) + Math.pow(points[i][1] - points[j][1], 2)) < removeClosePoints) {
              points[i][0] = points[i][0] + points[j][0] >> 1;
              points[i][1] = points[i][1] + points[j][1] >> 1;
              points.splice(j, 1);
              j--;
            }
          }
        }
      }
      return points;
    }
  }
});

// node_modules/image-js/lib/image/compute/mean.js
var require_mean2 = __commonJS({
  "node_modules/image-js/lib/image/compute/mean.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = mean;
    var _histogram = require_histogram();
    function mean() {
      let histograms = this.getHistograms({
        maxSlots: this.maxValue + 1
      });
      let result = new Array(histograms.length);
      for (let c = 0; c < histograms.length; c++) {
        let histogram = histograms[c];
        result[c] = (0, _histogram.mean)(histogram);
      }
      return result;
    }
  }
});

// node_modules/image-js/lib/image/compute/median.js
var require_median2 = __commonJS({
  "node_modules/image-js/lib/image/compute/median.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = median;
    var _histogram = require_histogram();
    function median() {
      let histograms = this.getHistograms({
        maxSlots: this.maxValue + 1
      });
      let result = new Array(histograms.length);
      for (let c = 0; c < histograms.length; c++) {
        let histogram = histograms[c];
        result[c] = (0, _histogram.median)(histogram);
      }
      return result;
    }
  }
});

// node_modules/image-js/lib/image/compute/points.js
var require_points = __commonJS({
  "node_modules/image-js/lib/image/compute/points.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = points;
    function points() {
      this.checkProcessable("points", {
        bitDepth: [1]
      });
      const pixels = [];
      for (let x = 0; x < this.width; x++) {
        for (let y = 0; y < this.height; y++) {
          if (this.getBitXY(x, y) === 1) {
            pixels.push([x, y]);
          }
        }
      }
      return pixels;
    }
  }
});

// node_modules/image-js/lib/image/compute/extendedPoints.js
var require_extendedPoints = __commonJS({
  "node_modules/image-js/lib/image/compute/extendedPoints.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = extendedPoints;
    function extendedPoints() {
      this.checkProcessable("extendedPoints", {
        bitDepth: [1]
      });
      const pixels = [];
      for (let y = 0; y < this.height; y++) {
        for (let x = 0; x < this.width; x++) {
          if (this.getBitXY(x, y) === 1) {
            pixels.push([x, y]);
            if (this.getBitXY(x + 1, y) !== 1) {
              pixels.push([x + 1, y]);
              pixels.push([x + 1, y + 1]);
              if (this.getBitXY(x, y + 1) !== 1) {
                pixels.push([x, y + 1]);
              }
            } else {
              if (this.getBitXY(x, y + 1) !== 1) {
                pixels.push([x, y + 1]);
                pixels.push([x + 1, y + 1]);
              }
            }
            while (x < this.width - 2 && this.getBitXY(x + 1, y) === 1 && this.getBitXY(x + 2, y) === 1) {
              x++;
            }
          }
        }
      }
      return pixels;
    }
  }
});

// node_modules/image-js/lib/image/compute/relativePosition.js
var require_relativePosition = __commonJS({
  "node_modules/image-js/lib/image/compute/relativePosition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = getRelativePosition;
    function getRelativePosition(targetImage, options = {}) {
      if (this === targetImage) {
        return [0, 0];
      }
      let position = [0, 0];
      let currentImage = this;
      while (currentImage) {
        if (currentImage === targetImage) {
          return position;
        }
        if (currentImage.position) {
          position[0] += currentImage.position[0];
          position[1] += currentImage.position[1];
        }
        currentImage = currentImage.parent;
      }
      if (options.defaultFurther)
        return position;
      return false;
    }
  }
});

// node_modules/image-js/lib/image/compute/countAlphaPixels.js
var require_countAlphaPixels = __commonJS({
  "node_modules/image-js/lib/image/compute/countAlphaPixels.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = countAlphaPixels;
    function countAlphaPixels(options = {}) {
      let {
        alpha = 1
      } = options;
      this.checkProcessable("countAlphaPixels", {
        bitDepth: [8, 16],
        alpha: 1
      });
      let count = 0;
      if (alpha !== void 0) {
        for (let i = this.components; i < this.data.length; i += this.channels) {
          if (this.data[i] === alpha) {
            count++;
          }
        }
        return count;
      } else {
        return this.size;
      }
    }
  }
});

// node_modules/monotone-chain-convex-hull/lib/index.js
var require_lib19 = __commonJS({
  "node_modules/monotone-chain-convex-hull/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function monotoneChainConvexHull(points, options = {}) {
      const { sorted } = options;
      if (!sorted) {
        points = points.slice().sort(byXThenY);
      }
      const n = points.length;
      const result = new Array(n * 2);
      let k = 0;
      for (let i = 0; i < n; i++) {
        const point = points[i];
        while (k >= 2 && cw(result[k - 2], result[k - 1], point) <= 0) {
          k--;
        }
        result[k++] = point;
      }
      const t = k + 1;
      for (let i = n - 2; i >= 0; i--) {
        const point = points[i];
        while (k >= t && cw(result[k - 2], result[k - 1], point) <= 0) {
          k--;
        }
        result[k++] = point;
      }
      return result.slice(0, k - 1);
    }
    exports2.default = monotoneChainConvexHull;
    function cw(p1, p2, p3) {
      return (p2[1] - p1[1]) * (p3[0] - p1[0]) - (p2[0] - p1[0]) * (p3[1] - p1[1]);
    }
    function byXThenY(point1, point2) {
      if (point1[0] === point2[0]) {
        return point1[1] - point2[1];
      }
      return point1[0] - point2[0];
    }
  }
});

// node_modules/image-js/lib/image/compute/monotoneChainConvexHull.js
var require_monotoneChainConvexHull = __commonJS({
  "node_modules/image-js/lib/image/compute/monotoneChainConvexHull.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = monotoneChainConvexHull;
    var _monotoneChainConvexHull = _interopRequireDefault(require_lib19());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function monotoneChainConvexHull() {
      return (0, _monotoneChainConvexHull.default)(this.extendedPoints, {
        sorted: false
      });
    }
  }
});

// node_modules/image-js/lib/util/points.js
var require_points2 = __commonJS({
  "node_modules/image-js/lib/util/points.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.angle = angle;
    exports2.boundary = boundary;
    exports2.difference = difference;
    exports2.dot = dot;
    exports2.minMax = minMax;
    exports2.moveToZeroZero = moveToZeroZero;
    exports2.normalize = normalize;
    exports2.perimeter = perimeter;
    exports2.rotate = rotate;
    exports2.round = round;
    exports2.surface = surface;
    function round(points) {
      for (let i = 0; i < points.length; i++) {
        points[i][0] = Math.round(points[i][0]);
        points[i][1] = Math.round(points[i][1]);
      }
      return points;
    }
    function difference(p1, p2) {
      return [p1[0] - p2[0], p1[1] - p2[1]];
    }
    function normalize(p) {
      let length = Math.sqrt(p[0] ** 2 + p[1] ** 2);
      return [p[0] / length, p[1] / length];
    }
    function rotate(radians, srcPoints, destPoints) {
      if (destPoints === void 0)
        destPoints = new Array(srcPoints.length);
      let cos = Math.cos(radians);
      let sin = Math.sin(radians);
      for (let i = 0; i < destPoints.length; ++i) {
        destPoints[i] = [cos * srcPoints[i][0] - sin * srcPoints[i][1], sin * srcPoints[i][0] + cos * srcPoints[i][1]];
      }
      return destPoints;
    }
    function dot(p1, p2) {
      return p1[0] * p2[0] + p1[1] * p2[1];
    }
    function angle(origin, p1, p2) {
      let v1 = normalize(difference(p1, origin));
      let v2 = normalize(difference(p2, origin));
      let dotProduct = dot(v1, v2);
      return Math.acos(dotProduct);
    }
    function boundary(points) {
      let minMaxValues = minMax(points);
      let xMin = minMaxValues[0][0];
      let yMin = minMaxValues[0][1];
      let xMax = minMaxValues[1][0];
      let yMax = minMaxValues[1][1];
      return [[xMin, yMin], [xMax, yMin], [xMax, yMax], [xMin, yMax]];
    }
    function perimeter(vertices) {
      let total = 0;
      for (let i = 0; i < vertices.length; i++) {
        let fromX = vertices[i][0];
        let fromY = vertices[i][1];
        let toX = vertices[i === vertices.length - 1 ? 0 : i + 1][0];
        let toY = vertices[i === vertices.length - 1 ? 0 : i + 1][1];
        total += Math.sqrt((toX - fromX) ** 2 + (toY - fromY) ** 2);
      }
      return total;
    }
    function surface(vertices) {
      let total = 0;
      for (let i = 0; i < vertices.length; i++) {
        let addX = vertices[i][0];
        let addY = vertices[i === vertices.length - 1 ? 0 : i + 1][1];
        let subX = vertices[i === vertices.length - 1 ? 0 : i + 1][0];
        let subY = vertices[i][1];
        total += addX * addY * 0.5;
        total -= subX * subY * 0.5;
      }
      return Math.abs(total);
    }
    function minMax(points) {
      let xMin = Infinity;
      let yMin = Infinity;
      let xMax = -Infinity;
      let yMax = -Infinity;
      for (let i = 0; i < points.length; i++) {
        if (points[i][0] < xMin)
          xMin = points[i][0];
        if (points[i][0] > xMax)
          xMax = points[i][0];
        if (points[i][1] < yMin)
          yMin = points[i][1];
        if (points[i][1] > yMax)
          yMax = points[i][1];
      }
      return [[xMin, yMin], [xMax, yMax]];
    }
    function moveToZeroZero(srcPoints, destPoints) {
      if (destPoints === void 0) {
        destPoints = new Array(srcPoints.length).fill(0).map(() => []);
      }
      let minMaxValues = minMax(srcPoints);
      let xMin = minMaxValues[0][0];
      let yMin = minMaxValues[0][1];
      for (let i = 0; i < srcPoints.length; i++) {
        destPoints[i][0] = srcPoints[i][0] - xMin;
        destPoints[i][1] = srcPoints[i][1] - yMin;
      }
      return destPoints;
    }
  }
});

// node_modules/image-js/lib/image/compute/minimalBoundingRectangle.js
var require_minimalBoundingRectangle = __commonJS({
  "node_modules/image-js/lib/image/compute/minimalBoundingRectangle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = minimalBoundingRectangle;
    var _points = require_points2();
    var _monotoneChainConvexHull = _interopRequireDefault(require_monotoneChainConvexHull());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function minimalBoundingRectangle(options = {}) {
      const {
        originalPoints = _monotoneChainConvexHull.default.call(this)
      } = options;
      if (originalPoints.length === 0) {
        return [];
      }
      if (originalPoints.length === 1) {
        return [originalPoints[0], originalPoints[0], originalPoints[0], originalPoints[0]];
      }
      const p = new Array(originalPoints.length);
      let minSurface = Infinity;
      let minSurfaceAngle = 0;
      let mbr;
      for (let i = 0; i < p.length; i++) {
        let angle = getAngle(originalPoints[i], originalPoints[(i + 1) % p.length]);
        (0, _points.rotate)(-angle, originalPoints, p);
        let aX = p[i][0];
        let aY = p[i][1];
        let bX = p[(i + 1) % p.length][0];
        let bY = p[(i + 1) % p.length][1];
        let tUndefined = true;
        let tMin = 0;
        let tMax = 0;
        let maxWidth = 0;
        for (let j = 0; j < p.length; j++) {
          let cX = p[j][0];
          let cY = p[j][1];
          let t = (cX - aX) / (bX - aX);
          if (tUndefined === true) {
            tUndefined = false;
            tMin = t;
            tMax = t;
          } else {
            if (t < tMin)
              tMin = t;
            if (t > tMax)
              tMax = t;
          }
          let width = (-(bX - aX) * cY + bX * aY - bY * aX) / (bX - aX);
          if (Math.abs(width) > Math.abs(maxWidth))
            maxWidth = width;
        }
        let pMin = [aX + tMin * (bX - aX), aY];
        let pMax = [aX + tMax * (bX - aX), aY];
        let currentSurface = Math.abs(maxWidth * (tMin - tMax) * (bX - aX));
        if (currentSurface < minSurface) {
          minSurfaceAngle = angle;
          minSurface = currentSurface;
          mbr = [pMin, pMax, [pMax[0], pMax[1] - maxWidth], [pMin[0], pMin[1] - maxWidth]];
        }
      }
      (0, _points.rotate)(minSurfaceAngle, mbr, mbr);
      return mbr;
    }
    function getAngle(p1, p2) {
      let diff = (0, _points.difference)(p2, p1);
      let vector = (0, _points.normalize)(diff);
      let angle = Math.acos(vector[0]);
      if (vector[1] < 0)
        return -angle;
      return angle;
    }
  }
});

// node_modules/image-js/lib/image/extend.js
var require_extend3 = __commonJS({
  "node_modules/image-js/lib/image/extend.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = extend;
    var _abs = _interopRequireDefault(require_abs());
    var _invert = _interopRequireDefault(require_invert());
    var _flipX = _interopRequireDefault(require_flipX());
    var _flipY = _interopRequireDefault(require_flipY());
    var _blurFilter = _interopRequireDefault(require_blurFilter());
    var _medianFilter = _interopRequireDefault(require_medianFilter());
    var _gaussianFilter = _interopRequireDefault(require_gaussianFilter());
    var _sobelFilter = _interopRequireDefault(require_sobelFilter());
    var _scharrFilter = _interopRequireDefault(require_scharrFilter());
    var _gradientFilter = _interopRequireDefault(require_gradientFilter());
    var _level = _interopRequireDefault(require_level());
    var _add = _interopRequireDefault(require_add());
    var _subtract = _interopRequireDefault(require_subtract());
    var _subtractImage = _interopRequireDefault(require_subtractImage());
    var _hypotenuse = _interopRequireDefault(require_hypotenuse());
    var _multiply = _interopRequireDefault(require_multiply());
    var _divide = _interopRequireDefault(require_divide());
    var _background = _interopRequireDefault(require_background());
    var _dilate = _interopRequireDefault(require_dilate());
    var _erode = _interopRequireDefault(require_erode());
    var _open = _interopRequireDefault(require_open());
    var _close = _interopRequireDefault(require_close());
    var _topHat = _interopRequireDefault(require_topHat());
    var _blackHat = _interopRequireDefault(require_blackHat());
    var _morphologicalGradient = _interopRequireDefault(require_morphologicalGradient());
    var _warping = _interopRequireDefault(require_warping());
    var _crop = _interopRequireDefault(require_crop());
    var _cropAlpha = _interopRequireDefault(require_cropAlpha());
    var _resize = _interopRequireDefault(require_resize());
    var _hsv = _interopRequireDefault(require_hsv());
    var _hsl = _interopRequireDefault(require_hsl());
    var _cmyk = _interopRequireDefault(require_cmyk());
    var _rgba = _interopRequireDefault(require_rgba8());
    var _grey = _interopRequireDefault(require_grey());
    var _mask = _interopRequireDefault(require_mask());
    var _pad = _interopRequireDefault(require_pad());
    var _colorDepth = _interopRequireDefault(require_colorDepth());
    var _rotate = require_rotate();
    var _insert = _interopRequireDefault(require_insert());
    var _setBorder = _interopRequireDefault(require_setBorder());
    var _split = _interopRequireDefault(require_split());
    var _getChannel = _interopRequireDefault(require_getChannel());
    var _combineChannels = _interopRequireDefault(require_combineChannels());
    var _setChannel = _interopRequireDefault(require_setChannel());
    var _getSimilarity = _interopRequireDefault(require_getSimilarity());
    var _getPixelsGrid = _interopRequireDefault(require_getPixelsGrid());
    var _getBestMatch = _interopRequireDefault(require_getBestMatch());
    var _getRow = _interopRequireDefault(require_getRow());
    var _getColumn = _interopRequireDefault(require_getColumn());
    var _getMatrix = _interopRequireDefault(require_getMatrix());
    var _setMatrix = _interopRequireDefault(require_setMatrix());
    var _getPixelsArray = _interopRequireDefault(require_getPixelsArray());
    var _getIntersection = _interopRequireDefault(require_getIntersection());
    var _getClosestCommonParent = _interopRequireDefault(require_getClosestCommonParent());
    var _getThreshold = _interopRequireDefault(require_getThreshold());
    var _cannyEdge = _interopRequireDefault(require_cannyEdge());
    var _convolution = _interopRequireDefault(require_convolution());
    var _extract = _interopRequireDefault(require_extract());
    var _floodFill = _interopRequireDefault(require_floodFill());
    var _paintLabels = _interopRequireDefault(require_paintLabels());
    var _paintMasks = _interopRequireDefault(require_paintMasks());
    var _paintPoints = _interopRequireDefault(require_paintPoints());
    var _paintPolyline = _interopRequireDefault(require_paintPolyline());
    var _paintPolylines = _interopRequireDefault(require_paintPolylines());
    var _paintPolygon = _interopRequireDefault(require_paintPolygon());
    var _paintPolygons = _interopRequireDefault(require_paintPolygons());
    var _histogram = require_histogram3();
    var _colorHistogram = _interopRequireDefault(require_colorHistogram());
    var _min = _interopRequireDefault(require_min2());
    var _max = _interopRequireDefault(require_max2());
    var _sum = _interopRequireDefault(require_sum());
    var _moment = _interopRequireDefault(require_moment());
    var _localMaxima = _interopRequireDefault(require_localMaxima());
    var _mean = _interopRequireDefault(require_mean2());
    var _median = _interopRequireDefault(require_median2());
    var _points = _interopRequireDefault(require_points());
    var _extendedPoints = _interopRequireDefault(require_extendedPoints());
    var _relativePosition = _interopRequireDefault(require_relativePosition());
    var _countAlphaPixels = _interopRequireDefault(require_countAlphaPixels());
    var _monotoneChainConvexHull = _interopRequireDefault(require_monotoneChainConvexHull());
    var _minimalBoundingRectangle = _interopRequireDefault(require_minimalBoundingRectangle());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function extend(Image2) {
      let inPlace = {
        inPlace: true
      };
      Image2.extendMethod("invert", _invert.default);
      Image2.extendMethod("abs", _abs.default);
      Image2.extendMethod("level", _level.default, inPlace);
      Image2.extendMethod("add", _add.default, inPlace);
      Image2.extendMethod("subtract", _subtract.default, inPlace);
      Image2.extendMethod("subtractImage", _subtractImage.default);
      Image2.extendMethod("multiply", _multiply.default, inPlace);
      Image2.extendMethod("divide", _divide.default, inPlace);
      Image2.extendMethod("hypotenuse", _hypotenuse.default);
      Image2.extendMethod("background", _background.default);
      Image2.extendMethod("flipX", _flipX.default);
      Image2.extendMethod("flipY", _flipY.default);
      Image2.extendMethod("blurFilter", _blurFilter.default);
      Image2.extendMethod("medianFilter", _medianFilter.default);
      Image2.extendMethod("gaussianFilter", _gaussianFilter.default);
      Image2.extendMethod("sobelFilter", _sobelFilter.default);
      Image2.extendMethod("gradientFilter", _gradientFilter.default);
      Image2.extendMethod("scharrFilter", _scharrFilter.default);
      Image2.extendMethod("dilate", _dilate.default);
      Image2.extendMethod("erode", _erode.default);
      Image2.extendMethod("open", _open.default);
      Image2.extendMethod("close", _close.default);
      Image2.extendMethod("topHat", _topHat.default);
      Image2.extendMethod("blackHat", _blackHat.default);
      Image2.extendMethod("morphologicalGradient", _morphologicalGradient.default);
      Image2.extendMethod("warpingFourPoints", _warping.default);
      Image2.extendMethod("crop", _crop.default);
      Image2.extendMethod("cropAlpha", _cropAlpha.default);
      Image2.extendMethod("resize", _resize.default).extendMethod("scale", _resize.default);
      Image2.extendMethod("hsv", _hsv.default);
      Image2.extendMethod("hsl", _hsl.default);
      Image2.extendMethod("cmyk", _cmyk.default);
      Image2.extendMethod("rgba8", _rgba.default);
      Image2.extendMethod("grey", _grey.default).extendMethod("gray", _grey.default);
      Image2.extendMethod("mask", _mask.default);
      Image2.extendMethod("pad", _pad.default);
      Image2.extendMethod("colorDepth", _colorDepth.default);
      Image2.extendMethod("setBorder", _setBorder.default, inPlace);
      Image2.extendMethod("rotate", _rotate.rotate);
      Image2.extendMethod("rotateLeft", _rotate.rotateLeft);
      Image2.extendMethod("rotateRight", _rotate.rotateRight);
      Image2.extendMethod("insert", _insert.default);
      Image2.extendMethod("getRow", _getRow.default);
      Image2.extendMethod("getColumn", _getColumn.default);
      Image2.extendMethod("getMatrix", _getMatrix.default);
      Image2.extendMethod("setMatrix", _setMatrix.default);
      Image2.extendMethod("getPixelsArray", _getPixelsArray.default);
      Image2.extendMethod("getIntersection", _getIntersection.default);
      Image2.extendMethod("getClosestCommonParent", _getClosestCommonParent.default);
      Image2.extendMethod("getThreshold", _getThreshold.default);
      Image2.extendMethod("split", _split.default);
      Image2.extendMethod("getChannel", _getChannel.default);
      Image2.extendMethod("combineChannels", _combineChannels.default);
      Image2.extendMethod("setChannel", _setChannel.default);
      Image2.extendMethod("getSimilarity", _getSimilarity.default);
      Image2.extendMethod("getPixelsGrid", _getPixelsGrid.default);
      Image2.extendMethod("getBestMatch", _getBestMatch.default);
      Image2.extendMethod("cannyEdge", _cannyEdge.default);
      Image2.extendMethod("convolution", _convolution.default);
      Image2.extendMethod("extract", _extract.default);
      Image2.extendMethod("floodFill", _floodFill.default);
      Image2.extendMethod("paintLabels", _paintLabels.default, inPlace);
      Image2.extendMethod("paintMasks", _paintMasks.default, inPlace);
      Image2.extendMethod("paintPoints", _paintPoints.default, inPlace);
      Image2.extendMethod("paintPolyline", _paintPolyline.default, inPlace);
      Image2.extendMethod("paintPolylines", _paintPolylines.default, inPlace);
      Image2.extendMethod("paintPolygon", _paintPolygon.default, inPlace);
      Image2.extendMethod("paintPolygons", _paintPolygons.default, inPlace);
      Image2.extendMethod("countAlphaPixels", _countAlphaPixels.default);
      Image2.extendMethod("monotoneChainConvexHull", _monotoneChainConvexHull.default);
      Image2.extendMethod("minimalBoundingRectangle", _minimalBoundingRectangle.default);
      Image2.extendMethod("getHistogram", _histogram.getHistogram).extendProperty("histogram", _histogram.getHistogram);
      Image2.extendMethod("getHistograms", _histogram.getHistograms).extendProperty("histograms", _histogram.getHistograms);
      Image2.extendMethod("getColorHistogram", _colorHistogram.default).extendProperty("colorHistogram", _colorHistogram.default);
      Image2.extendMethod("getMin", _min.default).extendProperty("min", _min.default);
      Image2.extendMethod("getMax", _max.default).extendProperty("max", _max.default);
      Image2.extendMethod("getSum", _sum.default).extendProperty("sum", _sum.default);
      Image2.extendMethod("getMoment", _moment.default).extendProperty("moment", _moment.default);
      Image2.extendMethod("getLocalMaxima", _localMaxima.default);
      Image2.extendMethod("getMedian", _median.default).extendProperty("median", _median.default);
      Image2.extendMethod("getMean", _mean.default).extendProperty("mean", _mean.default);
      Image2.extendMethod("getPoints", _points.default).extendProperty("points", _points.default);
      Image2.extendMethod("getExtendedPoints", _extendedPoints.default).extendProperty("extendedPoints", _extendedPoints.default);
      Image2.extendMethod("getRelativePosition", _relativePosition.default);
    }
  }
});

// node_modules/js-quantities/build/quantities.js
var require_quantities = __commonJS({
  "node_modules/js-quantities/build/quantities.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.Qty = factory());
    })(exports2, function() {
      "use strict";
      function isString(value) {
        return typeof value === "string" || value instanceof String;
      }
      var isFiniteImpl = Number.isFinite || window.isFinite;
      function isNumber(value) {
        return isFiniteImpl(value);
      }
      function identity(value) {
        return value;
      }
      function uniq(strings) {
        var seen = {};
        return strings.filter(function(item) {
          return seen.hasOwnProperty(item) ? false : seen[item] = true;
        });
      }
      function compareArray(array1, array2) {
        if (array2.length !== array1.length) {
          return false;
        }
        for (var i2 = 0; i2 < array1.length; i2++) {
          if (array2[i2].compareArray) {
            if (!array2[i2].compareArray(array1[i2])) {
              return false;
            }
          }
          if (array2[i2] !== array1[i2]) {
            return false;
          }
        }
        return true;
      }
      function assign(target, properties) {
        Object.keys(properties).forEach(function(key) {
          target[key] = properties[key];
        });
      }
      function mulSafe() {
        var result = 1, decimals = 0;
        for (var i2 = 0; i2 < arguments.length; i2++) {
          var arg = arguments[i2];
          decimals = decimals + getFractional(arg);
          result *= arg;
        }
        return decimals !== 0 ? round(result, decimals) : result;
      }
      function divSafe(num, den) {
        if (den === 0) {
          throw new Error("Divide by zero");
        }
        var factor = Math.pow(10, getFractional(den));
        var invDen = factor / (factor * den);
        return mulSafe(num, invDen);
      }
      function round(val, decimals) {
        return Math.round(val * Math.pow(10, decimals)) / Math.pow(10, decimals);
      }
      function getFractional(num) {
        if (!isFinite(num)) {
          return 0;
        }
        var count = 0;
        while (num % 1 !== 0) {
          num *= 10;
          count++;
        }
        return count;
      }
      function QtyError() {
        var err;
        if (!this) {
          err = Object.create(QtyError.prototype);
          QtyError.apply(err, arguments);
          return err;
        }
        err = Error.apply(this, arguments);
        this.name = "QtyError";
        this.message = err.message;
        this.stack = err.stack;
      }
      QtyError.prototype = Object.create(Error.prototype, { constructor: { value: QtyError } });
      function throwIncompatibleUnits(left, right) {
        throw new QtyError("Incompatible units: " + left + " and " + right);
      }
      var UNITS = {
        /* prefixes */
        "<googol>": [["googol"], 1e100, "prefix"],
        "<kibi>": [["Ki", "Kibi", "kibi"], Math.pow(2, 10), "prefix"],
        "<mebi>": [["Mi", "Mebi", "mebi"], Math.pow(2, 20), "prefix"],
        "<gibi>": [["Gi", "Gibi", "gibi"], Math.pow(2, 30), "prefix"],
        "<tebi>": [["Ti", "Tebi", "tebi"], Math.pow(2, 40), "prefix"],
        "<pebi>": [["Pi", "Pebi", "pebi"], Math.pow(2, 50), "prefix"],
        "<exi>": [["Ei", "Exi", "exi"], Math.pow(2, 60), "prefix"],
        "<zebi>": [["Zi", "Zebi", "zebi"], Math.pow(2, 70), "prefix"],
        "<yebi>": [["Yi", "Yebi", "yebi"], Math.pow(2, 80), "prefix"],
        "<yotta>": [["Y", "Yotta", "yotta"], 1e24, "prefix"],
        "<zetta>": [["Z", "Zetta", "zetta"], 1e21, "prefix"],
        "<exa>": [["E", "Exa", "exa"], 1e18, "prefix"],
        "<peta>": [["P", "Peta", "peta"], 1e15, "prefix"],
        "<tera>": [["T", "Tera", "tera"], 1e12, "prefix"],
        "<giga>": [["G", "Giga", "giga"], 1e9, "prefix"],
        "<mega>": [["M", "Mega", "mega"], 1e6, "prefix"],
        "<kilo>": [["k", "kilo"], 1e3, "prefix"],
        "<hecto>": [["h", "Hecto", "hecto"], 100, "prefix"],
        "<deca>": [["da", "Deca", "deca", "deka"], 10, "prefix"],
        "<deci>": [["d", "Deci", "deci"], 0.1, "prefix"],
        "<centi>": [["c", "Centi", "centi"], 0.01, "prefix"],
        "<milli>": [["m", "Milli", "milli"], 1e-3, "prefix"],
        "<micro>": [
          ["u", "\u03BC", "\xB5", "Micro", "mc", "micro"],
          1e-6,
          "prefix"
        ],
        "<nano>": [["n", "Nano", "nano"], 1e-9, "prefix"],
        "<pico>": [["p", "Pico", "pico"], 1e-12, "prefix"],
        "<femto>": [["f", "Femto", "femto"], 1e-15, "prefix"],
        "<atto>": [["a", "Atto", "atto"], 1e-18, "prefix"],
        "<zepto>": [["z", "Zepto", "zepto"], 1e-21, "prefix"],
        "<yocto>": [["y", "Yocto", "yocto"], 1e-24, "prefix"],
        "<1>": [["1", "<1>"], 1, ""],
        /* length units */
        "<meter>": [["m", "meter", "meters", "metre", "metres"], 1, "length", ["<meter>"]],
        "<inch>": [["in", "inch", "inches", '"'], 0.0254, "length", ["<meter>"]],
        "<foot>": [["ft", "foot", "feet", "'"], 0.3048, "length", ["<meter>"]],
        "<yard>": [["yd", "yard", "yards"], 0.9144, "length", ["<meter>"]],
        "<mile>": [["mi", "mile", "miles"], 1609.344, "length", ["<meter>"]],
        "<naut-mile>": [["nmi", "naut-mile"], 1852, "length", ["<meter>"]],
        "<league>": [["league", "leagues"], 4828, "length", ["<meter>"]],
        "<furlong>": [["furlong", "furlongs"], 201.2, "length", ["<meter>"]],
        "<rod>": [["rd", "rod", "rods"], 5.029, "length", ["<meter>"]],
        "<mil>": [["mil", "mils"], 254e-7, "length", ["<meter>"]],
        "<angstrom>": [["ang", "angstrom", "angstroms"], 1e-10, "length", ["<meter>"]],
        "<fathom>": [["fathom", "fathoms"], 1.829, "length", ["<meter>"]],
        "<pica>": [["pica", "picas"], 0.00423333333, "length", ["<meter>"]],
        "<point>": [["pt", "point", "points"], 352777778e-12, "length", ["<meter>"]],
        "<redshift>": [["z", "red-shift", "redshift"], 1302773e20, "length", ["<meter>"]],
        "<AU>": [["AU", "astronomical-unit"], 1495979e5, "length", ["<meter>"]],
        "<light-second>": [["ls", "light-second"], 299792500, "length", ["<meter>"]],
        "<light-minute>": [["lmin", "light-minute"], 1798755e4, "length", ["<meter>"]],
        "<light-year>": [["ly", "light-year"], 9460528e9, "length", ["<meter>"]],
        "<parsec>": [["pc", "parsec", "parsecs"], 3085678e10, "length", ["<meter>"]],
        "<datamile>": [["DM", "datamile"], 1828.8, "length", ["<meter>"]],
        /* mass */
        "<kilogram>": [["kg", "kilogram", "kilograms"], 1, "mass", ["<kilogram>"]],
        "<AMU>": [["u", "AMU", "amu"], 1660538921e-36, "mass", ["<kilogram>"]],
        "<dalton>": [["Da", "Dalton", "Daltons", "dalton", "daltons"], 1660538921e-36, "mass", ["<kilogram>"]],
        "<slug>": [["slug", "slugs"], 14.5939029, "mass", ["<kilogram>"]],
        "<short-ton>": [["tn", "ton", "short-ton"], 907.18474, "mass", ["<kilogram>"]],
        "<metric-ton>": [["t", "tonne", "metric-ton"], 1e3, "mass", ["<kilogram>"]],
        "<carat>": [["ct", "carat", "carats"], 2e-4, "mass", ["<kilogram>"]],
        "<pound>": [["lbs", "lb", "pound", "pounds", "#"], 0.45359237, "mass", ["<kilogram>"]],
        "<ounce>": [["oz", "ounce", "ounces"], 0.0283495231, "mass", ["<kilogram>"]],
        "<gram>": [["g", "gram", "grams", "gramme", "grammes"], 1e-3, "mass", ["<kilogram>"]],
        "<grain>": [["grain", "grains", "gr"], 6479891e-11, "mass", ["<kilogram>"]],
        "<dram>": [["dram", "drams", "dr"], 0.0017718452, "mass", ["<kilogram>"]],
        "<stone>": [["stone", "stones", "st"], 6.35029318, "mass", ["<kilogram>"]],
        /* area */
        "<hectare>": [["hectare"], 1e4, "area", ["<meter>", "<meter>"]],
        "<acre>": [["acre", "acres"], 4046.85642, "area", ["<meter>", "<meter>"]],
        "<sqft>": [["sqft"], 1, "area", ["<foot>", "<foot>"]],
        /* volume */
        "<liter>": [["l", "L", "liter", "liters", "litre", "litres"], 1e-3, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<gallon>": [["gal", "gallon", "gallons"], 0.0037854118, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<gallon-imp>": [["galimp", "gallon-imp", "gallons-imp"], 454609e-8, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<quart>": [["qt", "quart", "quarts"], 94635295e-11, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<pint>": [["pt", "pint", "pints"], 473176475e-12, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<pint-imp>": [["ptimp", "pint-imp", "pints-imp"], 56826125e-11, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<cup>": [["cu", "cup", "cups"], 236588238e-12, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<fluid-ounce>": [["floz", "fluid-ounce", "fluid-ounces"], 295735297e-13, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<fluid-ounce-imp>": [["flozimp", "floz-imp", "fluid-ounce-imp", "fluid-ounces-imp"], 284130625e-13, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<tablespoon>": [["tb", "tbsp", "tbs", "tablespoon", "tablespoons"], 147867648e-13, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<teaspoon>": [["tsp", "teaspoon", "teaspoons"], 492892161e-14, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<bushel>": [["bu", "bsh", "bushel", "bushels"], 0.035239072, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<oilbarrel>": [["bbl", "oilbarrel", "oilbarrels", "oil-barrel", "oil-barrels"], 0.158987294928, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<beerbarrel>": [["bl", "bl-us", "beerbarrel", "beerbarrels", "beer-barrel", "beer-barrels"], 0.1173477658, "volume", ["<meter>", "<meter>", "<meter>"]],
        "<beerbarrel-imp>": [["blimp", "bl-imp", "beerbarrel-imp", "beerbarrels-imp", "beer-barrel-imp", "beer-barrels-imp"], 0.16365924, "volume", ["<meter>", "<meter>", "<meter>"]],
        /* speed */
        "<kph>": [["kph"], 0.277777778, "speed", ["<meter>"], ["<second>"]],
        "<mph>": [["mph"], 0.44704, "speed", ["<meter>"], ["<second>"]],
        "<knot>": [["kt", "kn", "kts", "knot", "knots"], 0.514444444, "speed", ["<meter>"], ["<second>"]],
        "<fps>": [["fps"], 0.3048, "speed", ["<meter>"], ["<second>"]],
        /* acceleration */
        "<gee>": [["gee"], 9.80665, "acceleration", ["<meter>"], ["<second>", "<second>"]],
        "<Gal>": [["Gal"], 0.01, "acceleration", ["<meter>"], ["<second>", "<second>"]],
        /* temperature_difference */
        "<kelvin>": [["degK", "kelvin"], 1, "temperature", ["<kelvin>"]],
        "<celsius>": [["degC", "celsius", "celsius", "centigrade"], 1, "temperature", ["<kelvin>"]],
        "<fahrenheit>": [["degF", "fahrenheit"], 5 / 9, "temperature", ["<kelvin>"]],
        "<rankine>": [["degR", "rankine"], 5 / 9, "temperature", ["<kelvin>"]],
        "<temp-K>": [["tempK", "temp-K"], 1, "temperature", ["<temp-K>"]],
        "<temp-C>": [["tempC", "temp-C"], 1, "temperature", ["<temp-K>"]],
        "<temp-F>": [["tempF", "temp-F"], 5 / 9, "temperature", ["<temp-K>"]],
        "<temp-R>": [["tempR", "temp-R"], 5 / 9, "temperature", ["<temp-K>"]],
        /* time */
        "<second>": [["s", "sec", "secs", "second", "seconds"], 1, "time", ["<second>"]],
        "<minute>": [["min", "mins", "minute", "minutes"], 60, "time", ["<second>"]],
        "<hour>": [["h", "hr", "hrs", "hour", "hours"], 3600, "time", ["<second>"]],
        "<day>": [["d", "day", "days"], 3600 * 24, "time", ["<second>"]],
        "<week>": [["wk", "week", "weeks"], 7 * 3600 * 24, "time", ["<second>"]],
        "<fortnight>": [["fortnight", "fortnights"], 1209600, "time", ["<second>"]],
        "<year>": [["y", "yr", "year", "years", "annum"], 31556926, "time", ["<second>"]],
        "<decade>": [["decade", "decades"], 315569260, "time", ["<second>"]],
        "<century>": [["century", "centuries"], 3155692600, "time", ["<second>"]],
        /* pressure */
        "<pascal>": [["Pa", "pascal", "Pascal"], 1, "pressure", ["<kilogram>"], ["<meter>", "<second>", "<second>"]],
        "<bar>": [["bar", "bars"], 1e5, "pressure", ["<kilogram>"], ["<meter>", "<second>", "<second>"]],
        "<mmHg>": [["mmHg"], 133.322368, "pressure", ["<kilogram>"], ["<meter>", "<second>", "<second>"]],
        "<inHg>": [["inHg"], 3386.3881472, "pressure", ["<kilogram>"], ["<meter>", "<second>", "<second>"]],
        "<torr>": [["torr"], 133.322368, "pressure", ["<kilogram>"], ["<meter>", "<second>", "<second>"]],
        "<atm>": [["atm", "ATM", "atmosphere", "atmospheres"], 101325, "pressure", ["<kilogram>"], ["<meter>", "<second>", "<second>"]],
        "<psi>": [["psi"], 6894.76, "pressure", ["<kilogram>"], ["<meter>", "<second>", "<second>"]],
        "<cmh2o>": [["cmH2O", "cmh2o"], 98.0638, "pressure", ["<kilogram>"], ["<meter>", "<second>", "<second>"]],
        "<inh2o>": [["inH2O", "inh2o"], 249.082052, "pressure", ["<kilogram>"], ["<meter>", "<second>", "<second>"]],
        /* viscosity */
        "<poise>": [["P", "poise"], 0.1, "viscosity", ["<kilogram>"], ["<meter>", "<second>"]],
        "<stokes>": [["St", "stokes"], 1e-4, "viscosity", ["<meter>", "<meter>"], ["<second>"]],
        /* substance */
        "<mole>": [["mol", "mole"], 1, "substance", ["<mole>"]],
        /* molar_concentration */
        "<molar>": [["M", "molar"], 1e3, "molar_concentration", ["<mole>"], ["<meter>", "<meter>", "<meter>"]],
        "<wtpercent>": [["wt%", "wtpercent"], 10, "molar_concentration", ["<kilogram>"], ["<meter>", "<meter>", "<meter>"]],
        /* activity */
        "<katal>": [["kat", "katal", "Katal"], 1, "activity", ["<mole>"], ["<second>"]],
        "<unit>": [["U", "enzUnit", "unit"], 16667e-19, "activity", ["<mole>"], ["<second>"]],
        /* capacitance */
        "<farad>": [["F", "farad", "Farad"], 1, "capacitance", ["<second>", "<second>", "<second>", "<second>", "<ampere>", "<ampere>"], ["<meter>", "<meter>", "<kilogram>"]],
        /* charge */
        "<coulomb>": [["C", "coulomb", "Coulomb"], 1, "charge", ["<ampere>", "<second>"]],
        "<Ah>": [["Ah"], 3600, "charge", ["<ampere>", "<second>"]],
        /* current */
        "<ampere>": [["A", "Ampere", "ampere", "amp", "amps"], 1, "current", ["<ampere>"]],
        /* conductance */
        "<siemens>": [["S", "Siemens", "siemens"], 1, "conductance", ["<second>", "<second>", "<second>", "<ampere>", "<ampere>"], ["<kilogram>", "<meter>", "<meter>"]],
        /* inductance */
        "<henry>": [["H", "Henry", "henry"], 1, "inductance", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>", "<ampere>", "<ampere>"]],
        /* potential */
        "<volt>": [["V", "Volt", "volt", "volts"], 1, "potential", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>", "<second>", "<ampere>"]],
        /* resistance */
        "<ohm>": [
          [
            "Ohm",
            "ohm",
            "\u03A9",
            "\u2126"
            /* as ohm sign*/
          ],
          1,
          "resistance",
          ["<meter>", "<meter>", "<kilogram>"],
          ["<second>", "<second>", "<second>", "<ampere>", "<ampere>"]
        ],
        /* magnetism */
        "<weber>": [["Wb", "weber", "webers"], 1, "magnetism", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>", "<ampere>"]],
        "<tesla>": [["T", "tesla", "teslas"], 1, "magnetism", ["<kilogram>"], ["<second>", "<second>", "<ampere>"]],
        "<gauss>": [["G", "gauss"], 1e-4, "magnetism", ["<kilogram>"], ["<second>", "<second>", "<ampere>"]],
        "<maxwell>": [["Mx", "maxwell", "maxwells"], 1e-8, "magnetism", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>", "<ampere>"]],
        "<oersted>": [["Oe", "oersted", "oersteds"], 250 / Math.PI, "magnetism", ["<ampere>"], ["<meter>"]],
        /* energy */
        "<joule>": [["J", "joule", "Joule", "joules", "Joules"], 1, "energy", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>"]],
        "<erg>": [["erg", "ergs"], 1e-7, "energy", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>"]],
        "<btu>": [["BTU", "btu", "BTUs"], 1055.056, "energy", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>"]],
        "<calorie>": [["cal", "calorie", "calories"], 4.184, "energy", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>"]],
        "<Calorie>": [["Cal", "Calorie", "Calories"], 4184, "energy", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>"]],
        "<therm-US>": [["th", "therm", "therms", "Therm", "therm-US"], 105480400, "energy", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>"]],
        "<Wh>": [["Wh"], 3600, "energy", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>"]],
        "<electronvolt>": [["eV", "electronvolt", "electronvolts"], 1602176634e-28, "energy", ["<meter>", "<meter>", "<kilogram>"], ["<second>", "<second>"]],
        /* force */
        "<newton>": [["N", "Newton", "newton"], 1, "force", ["<kilogram>", "<meter>"], ["<second>", "<second>"]],
        "<dyne>": [["dyn", "dyne"], 1e-5, "force", ["<kilogram>", "<meter>"], ["<second>", "<second>"]],
        "<pound-force>": [["lbf", "pound-force"], 4.448222, "force", ["<kilogram>", "<meter>"], ["<second>", "<second>"]],
        /* frequency */
        "<hertz>": [["Hz", "hertz", "Hertz"], 1, "frequency", ["<1>"], ["<second>"]],
        /* angle */
        "<radian>": [["rad", "radian", "radians"], 1, "angle", ["<radian>"]],
        "<degree>": [["deg", "degree", "degrees"], Math.PI / 180, "angle", ["<radian>"]],
        "<arcminute>": [["arcmin", "arcminute", "arcminutes"], Math.PI / 10800, "angle", ["<radian>"]],
        "<arcsecond>": [["arcsec", "arcsecond", "arcseconds"], Math.PI / 648e3, "angle", ["<radian>"]],
        "<gradian>": [["gon", "grad", "gradian", "grads"], Math.PI / 200, "angle", ["<radian>"]],
        "<steradian>": [["sr", "steradian", "steradians"], 1, "solid_angle", ["<steradian>"]],
        /* rotation */
        "<rotation>": [["rotation"], 2 * Math.PI, "angle", ["<radian>"]],
        "<rpm>": [["rpm"], 2 * Math.PI / 60, "angular_velocity", ["<radian>"], ["<second>"]],
        /* information */
        "<byte>": [["B", "byte", "bytes"], 1, "information", ["<byte>"]],
        "<bit>": [["b", "bit", "bits"], 0.125, "information", ["<byte>"]],
        /* information rate */
        "<Bps>": [["Bps"], 1, "information_rate", ["<byte>"], ["<second>"]],
        "<bps>": [["bps"], 0.125, "information_rate", ["<byte>"], ["<second>"]],
        /* currency */
        "<dollar>": [["USD", "dollar"], 1, "currency", ["<dollar>"]],
        "<cents>": [["cents"], 0.01, "currency", ["<dollar>"]],
        /* luminosity */
        "<candela>": [["cd", "candela"], 1, "luminosity", ["<candela>"]],
        "<lumen>": [["lm", "lumen"], 1, "luminous_power", ["<candela>", "<steradian>"]],
        "<lux>": [["lux"], 1, "illuminance", ["<candela>", "<steradian>"], ["<meter>", "<meter>"]],
        /* power */
        "<watt>": [["W", "watt", "watts"], 1, "power", ["<kilogram>", "<meter>", "<meter>"], ["<second>", "<second>", "<second>"]],
        "<volt-ampere>": [["VA", "volt-ampere"], 1, "power", ["<kilogram>", "<meter>", "<meter>"], ["<second>", "<second>", "<second>"]],
        "<volt-ampere-reactive>": [["var", "Var", "VAr", "VAR", "volt-ampere-reactive"], 1, "power", ["<kilogram>", "<meter>", "<meter>"], ["<second>", "<second>", "<second>"]],
        "<horsepower>": [["hp", "horsepower"], 745.699872, "power", ["<kilogram>", "<meter>", "<meter>"], ["<second>", "<second>", "<second>"]],
        /* radiation */
        "<gray>": [["Gy", "gray", "grays"], 1, "radiation", ["<meter>", "<meter>"], ["<second>", "<second>"]],
        "<roentgen>": [["R", "roentgen"], 933e-5, "radiation", ["<meter>", "<meter>"], ["<second>", "<second>"]],
        "<sievert>": [["Sv", "sievert", "sieverts"], 1, "radiation", ["<meter>", "<meter>"], ["<second>", "<second>"]],
        "<becquerel>": [["Bq", "becquerel", "becquerels"], 1, "radiation", ["<1>"], ["<second>"]],
        "<curie>": [["Ci", "curie", "curies"], 37e9, "radiation", ["<1>"], ["<second>"]],
        /* rate */
        "<cpm>": [["cpm"], 1 / 60, "rate", ["<count>"], ["<second>"]],
        "<dpm>": [["dpm"], 1 / 60, "rate", ["<count>"], ["<second>"]],
        "<bpm>": [["bpm"], 1 / 60, "rate", ["<count>"], ["<second>"]],
        /* resolution / typography */
        "<dot>": [["dot", "dots"], 1, "resolution", ["<each>"]],
        "<pixel>": [["pixel", "px"], 1, "resolution", ["<each>"]],
        "<ppi>": [["ppi"], 1, "resolution", ["<pixel>"], ["<inch>"]],
        "<dpi>": [["dpi"], 1, "typography", ["<dot>"], ["<inch>"]],
        /* other */
        "<cell>": [["cells", "cell"], 1, "counting", ["<each>"]],
        "<each>": [["each"], 1, "counting", ["<each>"]],
        "<count>": [["count"], 1, "counting", ["<each>"]],
        "<base-pair>": [["bp", "base-pair"], 1, "counting", ["<each>"]],
        "<nucleotide>": [["nt", "nucleotide"], 1, "counting", ["<each>"]],
        "<molecule>": [["molecule", "molecules"], 1, "counting", ["<1>"]],
        "<dozen>": [["doz", "dz", "dozen"], 12, "prefix_only", ["<each>"]],
        "<percent>": [["%", "percent"], 0.01, "prefix_only", ["<1>"]],
        "<ppm>": [["ppm"], 1e-6, "prefix_only", ["<1>"]],
        "<ppb>": [["ppb"], 1e-9, "prefix_only", ["<1>"]],
        "<ppt>": [["ppt"], 1e-12, "prefix_only", ["<1>"]],
        "<ppq>": [["ppq"], 1e-15, "prefix_only", ["<1>"]],
        "<gross>": [["gr", "gross"], 144, "prefix_only", ["<dozen>", "<dozen>"]],
        "<decibel>": [["dB", "decibel", "decibels"], 1, "logarithmic", ["<decibel>"]]
      };
      var BASE_UNITS = ["<meter>", "<kilogram>", "<second>", "<mole>", "<ampere>", "<radian>", "<kelvin>", "<temp-K>", "<byte>", "<dollar>", "<candela>", "<each>", "<steradian>", "<decibel>"];
      var UNITY = "<1>";
      var UNITY_ARRAY = [UNITY];
      function validateUnitDefinition(unitDef2, definition2) {
        var scalar = definition2[1];
        var numerator = definition2[3] || [];
        var denominator = definition2[4] || [];
        if (!isNumber(scalar)) {
          throw new QtyError(unitDef2 + ": Invalid unit definition. 'scalar' must be a number");
        }
        numerator.forEach(function(unit) {
          if (UNITS[unit] === void 0) {
            throw new QtyError(unitDef2 + ": Invalid unit definition. Unit " + unit + " in 'numerator' is not recognized");
          }
        });
        denominator.forEach(function(unit) {
          if (UNITS[unit] === void 0) {
            throw new QtyError(unitDef2 + ": Invalid unit definition. Unit " + unit + " in 'denominator' is not recognized");
          }
        });
      }
      var PREFIX_VALUES = {};
      var PREFIX_MAP = {};
      var UNIT_VALUES = {};
      var UNIT_MAP = {};
      var OUTPUT_MAP = {};
      for (var unitDef in UNITS) {
        if (UNITS.hasOwnProperty(unitDef)) {
          var definition = UNITS[unitDef];
          if (definition[2] === "prefix") {
            PREFIX_VALUES[unitDef] = definition[1];
            for (var i = 0; i < definition[0].length; i++) {
              PREFIX_MAP[definition[0][i]] = unitDef;
            }
          } else {
            validateUnitDefinition(unitDef, definition);
            UNIT_VALUES[unitDef] = {
              scalar: definition[1],
              numerator: definition[3],
              denominator: definition[4]
            };
            for (var j = 0; j < definition[0].length; j++) {
              UNIT_MAP[definition[0][j]] = unitDef;
            }
          }
          OUTPUT_MAP[unitDef] = definition[0][0];
        }
      }
      function getUnits(kind) {
        var i2;
        var units = [];
        var unitKeys = Object.keys(UNITS);
        if (typeof kind === "undefined") {
          for (i2 = 0; i2 < unitKeys.length; i2++) {
            if (["", "prefix"].indexOf(UNITS[unitKeys[i2]][2]) === -1) {
              units.push(unitKeys[i2].substr(1, unitKeys[i2].length - 2));
            }
          }
        } else if (this.getKinds().indexOf(kind) === -1) {
          throw new QtyError("Kind not recognized");
        } else {
          for (i2 = 0; i2 < unitKeys.length; i2++) {
            if (UNITS[unitKeys[i2]][2] === kind) {
              units.push(unitKeys[i2].substr(1, unitKeys[i2].length - 2));
            }
          }
        }
        return units.sort(function(a, b) {
          if (a.toLowerCase() < b.toLowerCase()) {
            return -1;
          }
          if (a.toLowerCase() > b.toLowerCase()) {
            return 1;
          }
          return 0;
        });
      }
      function getAliases(unitName) {
        if (!UNIT_MAP[unitName]) {
          throw new QtyError("Unit not recognized");
        }
        return UNITS[UNIT_MAP[unitName]][0];
      }
      var SIGNATURE_VECTOR = ["length", "time", "temperature", "mass", "current", "substance", "luminosity", "currency", "information", "angle"];
      function unitSignature() {
        if (this.signature) {
          return this.signature;
        }
        var vector = unitSignatureVector.call(this);
        for (var i2 = 0; i2 < vector.length; i2++) {
          vector[i2] *= Math.pow(20, i2);
        }
        return vector.reduce(
          function(previous, current) {
            return previous + current;
          },
          0
        );
      }
      function unitSignatureVector() {
        if (!this.isBase()) {
          return unitSignatureVector.call(this.toBase());
        }
        var vector = new Array(SIGNATURE_VECTOR.length);
        for (var i2 = 0; i2 < vector.length; i2++) {
          vector[i2] = 0;
        }
        var r, n;
        for (var j2 = 0; j2 < this.numerator.length; j2++) {
          if (r = UNITS[this.numerator[j2]]) {
            n = SIGNATURE_VECTOR.indexOf(r[2]);
            if (n >= 0) {
              vector[n] = vector[n] + 1;
            }
          }
        }
        for (var k = 0; k < this.denominator.length; k++) {
          if (r = UNITS[this.denominator[k]]) {
            n = SIGNATURE_VECTOR.indexOf(r[2]);
            if (n >= 0) {
              vector[n] = vector[n] - 1;
            }
          }
        }
        return vector;
      }
      var SIGN = "[+-]";
      var INTEGER = "\\d+";
      var SIGNED_INTEGER = SIGN + "?" + INTEGER;
      var FRACTION = "\\." + INTEGER;
      var FLOAT = "(?:" + INTEGER + "(?:" + FRACTION + ")?)|(?:" + FRACTION + ")";
      var EXPONENT = "[Ee]" + SIGNED_INTEGER;
      var SCI_NUMBER = "(?:" + FLOAT + ")(?:" + EXPONENT + ")?";
      var SIGNED_NUMBER = SIGN + "?\\s*" + SCI_NUMBER;
      var QTY_STRING = "(" + SIGNED_NUMBER + ")?\\s*([^/]*)(?:/(.+))?";
      var QTY_STRING_REGEX = new RegExp("^" + QTY_STRING + "$");
      var POWER_OP = "\\^|\\*{2}";
      var SAFE_POWER = "[01234]";
      var TOP_REGEX = new RegExp("([^ \\*\\d]+?)(?:" + POWER_OP + ")?(-?" + SAFE_POWER + "(?![a-zA-Z]))");
      var BOTTOM_REGEX = new RegExp("([^ \\*\\d]+?)(?:" + POWER_OP + ")?(" + SAFE_POWER + "(?![a-zA-Z]))");
      function parse(val) {
        if (!isString(val)) {
          val = val.toString();
        }
        val = val.trim();
        var result = QTY_STRING_REGEX.exec(val);
        if (!result) {
          throw new QtyError(val + ": Quantity not recognized");
        }
        var scalarMatch = result[1];
        if (scalarMatch) {
          scalarMatch = scalarMatch.replace(/\s/g, "");
          this.scalar = parseFloat(scalarMatch);
        } else {
          this.scalar = 1;
        }
        var top = result[2];
        var bottom = result[3];
        var n, x, nx;
        while (result = TOP_REGEX.exec(top)) {
          n = parseFloat(result[2]);
          if (isNaN(n)) {
            throw new QtyError("Unit exponent is not a number");
          }
          if (n === 0 && !UNIT_TEST_REGEX.test(result[1])) {
            throw new QtyError("Unit not recognized");
          }
          x = result[1] + " ";
          nx = "";
          for (var i2 = 0; i2 < Math.abs(n); i2++) {
            nx += x;
          }
          if (n >= 0) {
            top = top.replace(result[0], nx);
          } else {
            bottom = bottom ? bottom + nx : nx;
            top = top.replace(result[0], "");
          }
        }
        while (result = BOTTOM_REGEX.exec(bottom)) {
          n = parseFloat(result[2]);
          if (isNaN(n)) {
            throw new QtyError("Unit exponent is not a number");
          }
          if (n === 0 && !UNIT_TEST_REGEX.test(result[1])) {
            throw new QtyError("Unit not recognized");
          }
          x = result[1] + " ";
          nx = "";
          for (var j2 = 0; j2 < n; j2++) {
            nx += x;
          }
          bottom = bottom.replace(result[0], nx);
        }
        if (top) {
          this.numerator = parseUnits(top.trim());
        }
        if (bottom) {
          this.denominator = parseUnits(bottom.trim());
        }
      }
      var PREFIX_REGEX = Object.keys(PREFIX_MAP).sort(function(a, b) {
        return b.length - a.length;
      }).join("|");
      var UNIT_REGEX = Object.keys(UNIT_MAP).sort(function(a, b) {
        return b.length - a.length;
      }).join("|");
      var BOUNDARY_REGEX = "\\b|$";
      var UNIT_MATCH = "(" + PREFIX_REGEX + ")??(" + UNIT_REGEX + ")(?:" + BOUNDARY_REGEX + ")";
      var UNIT_TEST_REGEX = new RegExp("^\\s*(" + UNIT_MATCH + "[\\s\\*]*)+$");
      var UNIT_MATCH_REGEX = new RegExp(UNIT_MATCH, "g");
      var parsedUnitsCache = {};
      function parseUnits(units) {
        var cached = parsedUnitsCache[units];
        if (cached) {
          return cached;
        }
        var unitMatch, normalizedUnits = [];
        if (!UNIT_TEST_REGEX.test(units)) {
          throw new QtyError("Unit not recognized");
        }
        while (unitMatch = UNIT_MATCH_REGEX.exec(units)) {
          normalizedUnits.push(unitMatch.slice(1));
        }
        normalizedUnits = normalizedUnits.map(function(item) {
          return PREFIX_MAP[item[0]] ? [PREFIX_MAP[item[0]], UNIT_MAP[item[1]]] : [UNIT_MAP[item[1]]];
        });
        normalizedUnits = normalizedUnits.reduce(function(a, b) {
          return a.concat(b);
        }, []);
        normalizedUnits = normalizedUnits.filter(function(item) {
          return item;
        });
        parsedUnitsCache[units] = normalizedUnits;
        return normalizedUnits;
      }
      function globalParse(value) {
        if (!isString(value)) {
          throw new QtyError("Argument should be a string");
        }
        try {
          return this(value);
        } catch (e) {
          return null;
        }
      }
      function isQty(value) {
        return value instanceof Qty;
      }
      function Qty(initValue, initUnits) {
        assertValidConstructorArgs.apply(null, arguments);
        if (!isQty(this)) {
          return new Qty(initValue, initUnits);
        }
        this.scalar = null;
        this.baseScalar = null;
        this.signature = null;
        this._conversionCache = {};
        this.numerator = UNITY_ARRAY;
        this.denominator = UNITY_ARRAY;
        if (isDefinitionObject(initValue)) {
          this.scalar = initValue.scalar;
          this.numerator = initValue.numerator && initValue.numerator.length !== 0 ? initValue.numerator : UNITY_ARRAY;
          this.denominator = initValue.denominator && initValue.denominator.length !== 0 ? initValue.denominator : UNITY_ARRAY;
        } else if (initUnits) {
          parse.call(this, initUnits);
          this.scalar = initValue;
        } else {
          parse.call(this, initValue);
        }
        if (this.denominator.join("*").indexOf("temp") >= 0) {
          throw new QtyError("Cannot divide with temperatures");
        }
        if (this.numerator.join("*").indexOf("temp") >= 0) {
          if (this.numerator.length > 1) {
            throw new QtyError("Cannot multiply by temperatures");
          }
          if (!compareArray(this.denominator, UNITY_ARRAY)) {
            throw new QtyError("Cannot divide with temperatures");
          }
        }
        this.initValue = initValue;
        updateBaseScalar.call(this);
        if (this.isTemperature() && this.baseScalar < 0) {
          throw new QtyError("Temperatures must not be less than absolute zero");
        }
      }
      Qty.prototype = {
        // Properly set up constructor
        constructor: Qty
      };
      function assertValidConstructorArgs(value, units) {
        if (units) {
          if (!(isNumber(value) && isString(units))) {
            throw new QtyError("Only number accepted as initialization value when units are explicitly provided");
          }
        } else {
          if (!(isString(value) || isNumber(value) || isQty(value) || isDefinitionObject(value))) {
            throw new QtyError("Only string, number or quantity accepted as single initialization value");
          }
        }
      }
      function isDefinitionObject(value) {
        return value && typeof value === "object" && value.hasOwnProperty("scalar");
      }
      function updateBaseScalar() {
        if (this.baseScalar) {
          return this.baseScalar;
        }
        if (this.isBase()) {
          this.baseScalar = this.scalar;
          this.signature = unitSignature.call(this);
        } else {
          var base = this.toBase();
          this.baseScalar = base.scalar;
          this.signature = base.signature;
        }
      }
      var KINDS = {
        "-312078": "elastance",
        "-312058": "resistance",
        "-312038": "inductance",
        "-152058": "potential",
        "-152040": "magnetism",
        "-152038": "magnetism",
        "-7997": "specific_volume",
        "-79": "snap",
        "-59": "jolt",
        "-39": "acceleration",
        "-38": "radiation",
        "-20": "frequency",
        "-19": "speed",
        "-18": "viscosity",
        "-17": "volumetric_flow",
        "-1": "wavenumber",
        "0": "unitless",
        "1": "length",
        "2": "area",
        "3": "volume",
        "20": "time",
        "400": "temperature",
        "7941": "yank",
        "7942": "power",
        "7959": "pressure",
        "7961": "force",
        "7962": "energy",
        "7979": "viscosity",
        "7981": "momentum",
        "7982": "angular_momentum",
        "7997": "density",
        "7998": "area_density",
        "8000": "mass",
        "152020": "radiation_exposure",
        "159999": "magnetism",
        "160000": "current",
        "160020": "charge",
        "312058": "conductance",
        "312078": "capacitance",
        "3199980": "activity",
        "3199997": "molar_concentration",
        "3200000": "substance",
        "63999998": "illuminance",
        "64000000": "luminous_power",
        "1280000000": "currency",
        "25599999980": "information_rate",
        "25600000000": "information",
        "511999999980": "angular_velocity",
        "512000000000": "angle"
      };
      function getKinds() {
        return uniq(Object.keys(KINDS).map(function(knownSignature) {
          return KINDS[knownSignature];
        }));
      }
      Qty.prototype.kind = function() {
        return KINDS[this.signature.toString()];
      };
      assign(Qty.prototype, {
        isDegrees: function() {
          return (this.signature === null || this.signature === 400) && this.numerator.length === 1 && compareArray(this.denominator, UNITY_ARRAY) && (this.numerator[0].match(/<temp-[CFRK]>/) || this.numerator[0].match(/<(kelvin|celsius|rankine|fahrenheit)>/));
        },
        isTemperature: function() {
          return this.isDegrees() && this.numerator[0].match(/<temp-[CFRK]>/);
        }
      });
      function subtractTemperatures(lhs, rhs) {
        var lhsUnits = lhs.units();
        var rhsConverted = rhs.to(lhsUnits);
        var dstDegrees = Qty(getDegreeUnits(lhsUnits));
        return Qty({ "scalar": lhs.scalar - rhsConverted.scalar, "numerator": dstDegrees.numerator, "denominator": dstDegrees.denominator });
      }
      function subtractTempDegrees(temp, deg) {
        var tempDegrees = deg.to(getDegreeUnits(temp.units()));
        return Qty({ "scalar": temp.scalar - tempDegrees.scalar, "numerator": temp.numerator, "denominator": temp.denominator });
      }
      function addTempDegrees(temp, deg) {
        var tempDegrees = deg.to(getDegreeUnits(temp.units()));
        return Qty({ "scalar": temp.scalar + tempDegrees.scalar, "numerator": temp.numerator, "denominator": temp.denominator });
      }
      function getDegreeUnits(units) {
        if (units === "tempK") {
          return "degK";
        } else if (units === "tempC") {
          return "degC";
        } else if (units === "tempF") {
          return "degF";
        } else if (units === "tempR") {
          return "degR";
        } else {
          throw new QtyError("Unknown type for temp conversion from: " + units);
        }
      }
      function toDegrees(src, dst) {
        var srcDegK = toDegK(src);
        var dstUnits = dst.units();
        var dstScalar;
        if (dstUnits === "degK") {
          dstScalar = srcDegK.scalar;
        } else if (dstUnits === "degC") {
          dstScalar = srcDegK.scalar;
        } else if (dstUnits === "degF") {
          dstScalar = srcDegK.scalar * 9 / 5;
        } else if (dstUnits === "degR") {
          dstScalar = srcDegK.scalar * 9 / 5;
        } else {
          throw new QtyError("Unknown type for degree conversion to: " + dstUnits);
        }
        return Qty({ "scalar": dstScalar, "numerator": dst.numerator, "denominator": dst.denominator });
      }
      function toDegK(qty) {
        var units = qty.units();
        var q;
        if (units.match(/(deg)[CFRK]/)) {
          q = qty.baseScalar;
        } else if (units === "tempK") {
          q = qty.scalar;
        } else if (units === "tempC") {
          q = qty.scalar;
        } else if (units === "tempF") {
          q = qty.scalar * 5 / 9;
        } else if (units === "tempR") {
          q = qty.scalar * 5 / 9;
        } else {
          throw new QtyError("Unknown type for temp conversion from: " + units);
        }
        return Qty({ "scalar": q, "numerator": ["<kelvin>"], "denominator": UNITY_ARRAY });
      }
      function toTemp(src, dst) {
        var dstUnits = dst.units();
        var dstScalar;
        if (dstUnits === "tempK") {
          dstScalar = src.baseScalar;
        } else if (dstUnits === "tempC") {
          dstScalar = src.baseScalar - 273.15;
        } else if (dstUnits === "tempF") {
          dstScalar = src.baseScalar * 9 / 5 - 459.67;
        } else if (dstUnits === "tempR") {
          dstScalar = src.baseScalar * 9 / 5;
        } else {
          throw new QtyError("Unknown type for temp conversion to: " + dstUnits);
        }
        return Qty({ "scalar": dstScalar, "numerator": dst.numerator, "denominator": dst.denominator });
      }
      function toTempK(qty) {
        var units = qty.units();
        var q;
        if (units.match(/(deg)[CFRK]/)) {
          q = qty.baseScalar;
        } else if (units === "tempK") {
          q = qty.scalar;
        } else if (units === "tempC") {
          q = qty.scalar + 273.15;
        } else if (units === "tempF") {
          q = (qty.scalar + 459.67) * 5 / 9;
        } else if (units === "tempR") {
          q = qty.scalar * 5 / 9;
        } else {
          throw new QtyError("Unknown type for temp conversion from: " + units);
        }
        return Qty({ "scalar": q, "numerator": ["<temp-K>"], "denominator": UNITY_ARRAY });
      }
      assign(Qty.prototype, {
        /**
         * Converts to other compatible units.
         * Instance's converted quantities are cached for faster subsequent calls.
         *
         * @param {(string|Qty)} other - Target units as string or retrieved from
         *                               other Qty instance (scalar is ignored)
         *
         * @returns {Qty} New converted Qty instance with target units
         *
         * @throws {QtyError} if target units are incompatible
         *
         * @example
         * var weight = Qty("25 kg");
         * weight.to("lb"); // => Qty("55.11556554621939 lbs");
         * weight.to(Qty("3 g")); // => Qty("25000 g"); // scalar of passed Qty is ignored
         */
        to: function(other) {
          var cached, target;
          if (other === void 0 || other === null) {
            return this;
          }
          if (!isString(other)) {
            return this.to(other.units());
          }
          cached = this._conversionCache[other];
          if (cached) {
            return cached;
          }
          target = Qty(other);
          if (target.units() === this.units()) {
            return this;
          }
          if (!this.isCompatible(target)) {
            if (this.isInverse(target)) {
              target = this.inverse().to(other);
            } else {
              throwIncompatibleUnits(this.units(), target.units());
            }
          } else {
            if (target.isTemperature()) {
              target = toTemp(this, target);
            } else if (target.isDegrees()) {
              target = toDegrees(this, target);
            } else {
              var q = divSafe(this.baseScalar, target.baseScalar);
              target = Qty({ "scalar": q, "numerator": target.numerator, "denominator": target.denominator });
            }
          }
          this._conversionCache[other] = target;
          return target;
        },
        // convert to base SI units
        // results of the conversion are cached so subsequent calls to this will be fast
        toBase: function() {
          if (this.isBase()) {
            return this;
          }
          if (this.isTemperature()) {
            return toTempK(this);
          }
          var cached = baseUnitCache[this.units()];
          if (!cached) {
            cached = toBaseUnits(this.numerator, this.denominator);
            baseUnitCache[this.units()] = cached;
          }
          return cached.mul(this.scalar);
        },
        // Converts the unit back to a float if it is unitless.  Otherwise raises an exception
        toFloat: function() {
          if (this.isUnitless()) {
            return this.scalar;
          }
          throw new QtyError("Can't convert to Float unless unitless.  Use Unit#scalar");
        },
        /**
         * Returns the nearest multiple of quantity passed as
         * precision
         *
         * @param {(Qty|string|number)} precQuantity - Quantity, string formated
         *   quantity or number as expected precision
         *
         * @returns {Qty} Nearest multiple of precQuantity
         *
         * @example
         * Qty('5.5 ft').toPrec('2 ft'); // returns 6 ft
         * Qty('0.8 cu').toPrec('0.25 cu'); // returns 0.75 cu
         * Qty('6.3782 m').toPrec('cm'); // returns 6.38 m
         * Qty('1.146 MPa').toPrec('0.1 bar'); // returns 1.15 MPa
         *
         */
        toPrec: function(precQuantity) {
          if (isString(precQuantity)) {
            precQuantity = Qty(precQuantity);
          }
          if (isNumber(precQuantity)) {
            precQuantity = Qty(precQuantity + " " + this.units());
          }
          if (!this.isUnitless()) {
            precQuantity = precQuantity.to(this.units());
          } else if (!precQuantity.isUnitless()) {
            throwIncompatibleUnits(this.units(), precQuantity.units());
          }
          if (precQuantity.scalar === 0) {
            throw new QtyError("Divide by zero");
          }
          var precRoundedResult = mulSafe(
            Math.round(this.scalar / precQuantity.scalar),
            precQuantity.scalar
          );
          return Qty(precRoundedResult + this.units());
        }
      });
      function swiftConverter(srcUnits, dstUnits) {
        var srcQty = Qty(srcUnits);
        var dstQty = Qty(dstUnits);
        if (srcQty.eq(dstQty)) {
          return identity;
        }
        var convert;
        if (!srcQty.isTemperature()) {
          convert = function(value) {
            return value * srcQty.baseScalar / dstQty.baseScalar;
          };
        } else {
          convert = function(value) {
            return srcQty.mul(value).to(dstQty).scalar;
          };
        }
        return function converter(value) {
          var i2, length, result;
          if (!Array.isArray(value)) {
            return convert(value);
          } else {
            length = value.length;
            result = [];
            for (i2 = 0; i2 < length; i2++) {
              result.push(convert(value[i2]));
            }
            return result;
          }
        };
      }
      var baseUnitCache = {};
      function toBaseUnits(numerator, denominator) {
        var num = [];
        var den = [];
        var q = 1;
        var unit;
        for (var i2 = 0; i2 < numerator.length; i2++) {
          unit = numerator[i2];
          if (PREFIX_VALUES[unit]) {
            q = mulSafe(q, PREFIX_VALUES[unit]);
          } else {
            if (UNIT_VALUES[unit]) {
              q *= UNIT_VALUES[unit].scalar;
              if (UNIT_VALUES[unit].numerator) {
                num.push(UNIT_VALUES[unit].numerator);
              }
              if (UNIT_VALUES[unit].denominator) {
                den.push(UNIT_VALUES[unit].denominator);
              }
            }
          }
        }
        for (var j2 = 0; j2 < denominator.length; j2++) {
          unit = denominator[j2];
          if (PREFIX_VALUES[unit]) {
            q /= PREFIX_VALUES[unit];
          } else {
            if (UNIT_VALUES[unit]) {
              q /= UNIT_VALUES[unit].scalar;
              if (UNIT_VALUES[unit].numerator) {
                den.push(UNIT_VALUES[unit].numerator);
              }
              if (UNIT_VALUES[unit].denominator) {
                num.push(UNIT_VALUES[unit].denominator);
              }
            }
          }
        }
        num = num.reduce(function(a, b) {
          return a.concat(b);
        }, []);
        den = den.reduce(function(a, b) {
          return a.concat(b);
        }, []);
        return Qty({ "scalar": q, "numerator": num, "denominator": den });
      }
      Qty.parse = globalParse;
      Qty.getUnits = getUnits;
      Qty.getAliases = getAliases;
      Qty.mulSafe = mulSafe;
      Qty.divSafe = divSafe;
      Qty.getKinds = getKinds;
      Qty.swiftConverter = swiftConverter;
      Qty.Error = QtyError;
      assign(Qty.prototype, {
        // Returns new instance with units of this
        add: function(other) {
          if (isString(other)) {
            other = Qty(other);
          }
          if (!this.isCompatible(other)) {
            throwIncompatibleUnits(this.units(), other.units());
          }
          if (this.isTemperature() && other.isTemperature()) {
            throw new QtyError("Cannot add two temperatures");
          } else if (this.isTemperature()) {
            return addTempDegrees(this, other);
          } else if (other.isTemperature()) {
            return addTempDegrees(other, this);
          }
          return Qty({ "scalar": this.scalar + other.to(this).scalar, "numerator": this.numerator, "denominator": this.denominator });
        },
        sub: function(other) {
          if (isString(other)) {
            other = Qty(other);
          }
          if (!this.isCompatible(other)) {
            throwIncompatibleUnits(this.units(), other.units());
          }
          if (this.isTemperature() && other.isTemperature()) {
            return subtractTemperatures(this, other);
          } else if (this.isTemperature()) {
            return subtractTempDegrees(this, other);
          } else if (other.isTemperature()) {
            throw new QtyError("Cannot subtract a temperature from a differential degree unit");
          }
          return Qty({ "scalar": this.scalar - other.to(this).scalar, "numerator": this.numerator, "denominator": this.denominator });
        },
        mul: function(other) {
          if (isNumber(other)) {
            return Qty({ "scalar": mulSafe(this.scalar, other), "numerator": this.numerator, "denominator": this.denominator });
          } else if (isString(other)) {
            other = Qty(other);
          }
          if ((this.isTemperature() || other.isTemperature()) && !(this.isUnitless() || other.isUnitless())) {
            throw new QtyError("Cannot multiply by temperatures");
          }
          var op1 = this;
          var op2 = other;
          if (op1.isCompatible(op2) && op1.signature !== 400) {
            op2 = op2.to(op1);
          }
          var numdenscale = cleanTerms(op1.numerator, op1.denominator, op2.numerator, op2.denominator);
          return Qty({ "scalar": mulSafe(op1.scalar, op2.scalar, numdenscale[2]), "numerator": numdenscale[0], "denominator": numdenscale[1] });
        },
        div: function(other) {
          if (isNumber(other)) {
            if (other === 0) {
              throw new QtyError("Divide by zero");
            }
            return Qty({ "scalar": this.scalar / other, "numerator": this.numerator, "denominator": this.denominator });
          } else if (isString(other)) {
            other = Qty(other);
          }
          if (other.scalar === 0) {
            throw new QtyError("Divide by zero");
          }
          if (other.isTemperature()) {
            throw new QtyError("Cannot divide with temperatures");
          } else if (this.isTemperature() && !other.isUnitless()) {
            throw new QtyError("Cannot divide with temperatures");
          }
          var op1 = this;
          var op2 = other;
          if (op1.isCompatible(op2) && op1.signature !== 400) {
            op2 = op2.to(op1);
          }
          var numdenscale = cleanTerms(op1.numerator, op1.denominator, op2.denominator, op2.numerator);
          return Qty({ "scalar": mulSafe(op1.scalar, numdenscale[2]) / op2.scalar, "numerator": numdenscale[0], "denominator": numdenscale[1] });
        },
        // Returns a Qty that is the inverse of this Qty,
        inverse: function() {
          if (this.isTemperature()) {
            throw new QtyError("Cannot divide with temperatures");
          }
          if (this.scalar === 0) {
            throw new QtyError("Divide by zero");
          }
          return Qty({ "scalar": 1 / this.scalar, "numerator": this.denominator, "denominator": this.numerator });
        }
      });
      function cleanTerms(num1, den1, num2, den2) {
        function notUnity(val) {
          return val !== UNITY;
        }
        num1 = num1.filter(notUnity);
        num2 = num2.filter(notUnity);
        den1 = den1.filter(notUnity);
        den2 = den2.filter(notUnity);
        var combined = {};
        function combineTerms(terms, direction) {
          var k;
          var prefix;
          var prefixValue;
          for (var i2 = 0; i2 < terms.length; i2++) {
            if (PREFIX_VALUES[terms[i2]]) {
              k = terms[i2 + 1];
              prefix = terms[i2];
              prefixValue = PREFIX_VALUES[prefix];
              i2++;
            } else {
              k = terms[i2];
              prefix = null;
              prefixValue = 1;
            }
            if (k && k !== UNITY) {
              if (combined[k]) {
                combined[k][0] += direction;
                var combinedPrefixValue = combined[k][2] ? PREFIX_VALUES[combined[k][2]] : 1;
                combined[k][direction === 1 ? 3 : 4] *= divSafe(prefixValue, combinedPrefixValue);
              } else {
                combined[k] = [direction, k, prefix, 1, 1];
              }
            }
          }
        }
        combineTerms(num1, 1);
        combineTerms(den1, -1);
        combineTerms(num2, 1);
        combineTerms(den2, -1);
        var num = [];
        var den = [];
        var scale = 1;
        for (var prop in combined) {
          if (combined.hasOwnProperty(prop)) {
            var item = combined[prop];
            var n;
            if (item[0] > 0) {
              for (n = 0; n < item[0]; n++) {
                num.push(item[2] === null ? item[1] : [item[2], item[1]]);
              }
            } else if (item[0] < 0) {
              for (n = 0; n < -item[0]; n++) {
                den.push(item[2] === null ? item[1] : [item[2], item[1]]);
              }
            }
            scale *= divSafe(item[3], item[4]);
          }
        }
        if (num.length === 0) {
          num = UNITY_ARRAY;
        }
        if (den.length === 0) {
          den = UNITY_ARRAY;
        }
        num = num.reduce(function(a, b) {
          return a.concat(b);
        }, []);
        den = den.reduce(function(a, b) {
          return a.concat(b);
        }, []);
        return [num, den, scale];
      }
      assign(Qty.prototype, {
        eq: function(other) {
          return this.compareTo(other) === 0;
        },
        lt: function(other) {
          return this.compareTo(other) === -1;
        },
        lte: function(other) {
          return this.eq(other) || this.lt(other);
        },
        gt: function(other) {
          return this.compareTo(other) === 1;
        },
        gte: function(other) {
          return this.eq(other) || this.gt(other);
        },
        // Compare two Qty objects. Throws an exception if they are not of compatible types.
        // Comparisons are done based on the value of the quantity in base SI units.
        //
        // NOTE: We cannot compare inverses as that breaks the general compareTo contract:
        //   if a.compareTo(b) < 0 then b.compareTo(a) > 0
        //   if a.compareTo(b) == 0 then b.compareTo(a) == 0
        //
        //   Since "10S" == ".1ohm" (10 > .1) and "10ohm" == ".1S" (10 > .1)
        //     Qty("10S").inverse().compareTo("10ohm") == -1
        //     Qty("10ohm").inverse().compareTo("10S") == -1
        //
        //   If including inverses in the sort is needed, I suggest writing: Qty.sort(qtyArray,units)
        compareTo: function(other) {
          if (isString(other)) {
            return this.compareTo(Qty(other));
          }
          if (!this.isCompatible(other)) {
            throwIncompatibleUnits(this.units(), other.units());
          }
          if (this.baseScalar < other.baseScalar) {
            return -1;
          } else if (this.baseScalar === other.baseScalar) {
            return 0;
          } else if (this.baseScalar > other.baseScalar) {
            return 1;
          }
        },
        // Return true if quantities and units match
        // Unit("100 cm").same(Unit("100 cm"))  # => true
        // Unit("100 cm").same(Unit("1 m"))     # => false
        same: function(other) {
          return this.scalar === other.scalar && this.units() === other.units();
        }
      });
      assign(Qty.prototype, {
        // returns true if no associated units
        // false, even if the units are "unitless" like 'radians, each, etc'
        isUnitless: function() {
          return [this.numerator, this.denominator].every(function(item) {
            return compareArray(item, UNITY_ARRAY);
          });
        },
        /*
        check to see if units are compatible, but not the scalar part
        this check is done by comparing signatures for performance reasons
        if passed a string, it will create a unit object with the string and then do the comparison
        this permits a syntax like:
        unit =~ "mm"
        if you want to do a regexp on the unit string do this ...
        unit.units =~ /regexp/
        */
        isCompatible: function(other) {
          if (isString(other)) {
            return this.isCompatible(Qty(other));
          }
          if (!isQty(other)) {
            return false;
          }
          if (other.signature !== void 0) {
            return this.signature === other.signature;
          } else {
            return false;
          }
        },
        /*
        check to see if units are inverse of each other, but not the scalar part
        this check is done by comparing signatures for performance reasons
        if passed a string, it will create a unit object with the string and then do the comparison
        this permits a syntax like:
        unit =~ "mm"
        if you want to do a regexp on the unit string do this ...
        unit.units =~ /regexp/
        */
        isInverse: function(other) {
          return this.inverse().isCompatible(other);
        },
        // Returns 'true' if the Unit is represented in base units
        isBase: function() {
          if (this._isBase !== void 0) {
            return this._isBase;
          }
          if (this.isDegrees() && this.numerator[0].match(/<(kelvin|temp-K)>/)) {
            this._isBase = true;
            return this._isBase;
          }
          this.numerator.concat(this.denominator).forEach(function(item) {
            if (item !== UNITY && BASE_UNITS.indexOf(item) === -1) {
              this._isBase = false;
            }
          }, this);
          if (this._isBase === false) {
            return this._isBase;
          }
          this._isBase = true;
          return this._isBase;
        }
      });
      function NestedMap() {
      }
      NestedMap.prototype.get = function(keys) {
        if (arguments.length > 1) {
          keys = Array.apply(null, arguments);
        }
        return keys.reduce(
          function(map, key, index) {
            if (map) {
              var childMap = map[key];
              if (index === keys.length - 1) {
                return childMap ? childMap.data : void 0;
              } else {
                return childMap;
              }
            }
          },
          this
        );
      };
      NestedMap.prototype.set = function(keys, value) {
        if (arguments.length > 2) {
          keys = Array.prototype.slice.call(arguments, 0, -1);
          value = arguments[arguments.length - 1];
        }
        return keys.reduce(function(map, key, index) {
          var childMap = map[key];
          if (childMap === void 0) {
            childMap = map[key] = {};
          }
          if (index === keys.length - 1) {
            childMap.data = value;
            return value;
          } else {
            return childMap;
          }
        }, this);
      };
      function defaultFormatter(scalar, units) {
        return (scalar + " " + units).trim();
      }
      Qty.formatter = defaultFormatter;
      assign(Qty.prototype, {
        // returns the 'unit' part of the Unit object without the scalar
        units: function() {
          if (this._units !== void 0) {
            return this._units;
          }
          var numIsUnity = compareArray(this.numerator, UNITY_ARRAY);
          var denIsUnity = compareArray(this.denominator, UNITY_ARRAY);
          if (numIsUnity && denIsUnity) {
            this._units = "";
            return this._units;
          }
          var numUnits = stringifyUnits(this.numerator);
          var denUnits = stringifyUnits(this.denominator);
          this._units = numUnits + (denIsUnity ? "" : "/" + denUnits);
          return this._units;
        },
        /**
         * Stringifies the quantity
         * Deprecation notice: only units parameter is supported.
         *
         * @param {(number|string|Qty)} targetUnitsOrMaxDecimalsOrPrec -
         *                              target units if string,
         *                              max number of decimals if number,
         *                              passed to #toPrec before converting if Qty
         *
         * @param {number=} maxDecimals - Maximum number of decimals of
         *                                formatted output
         *
         * @returns {string} reparseable quantity as string
         */
        toString: function(targetUnitsOrMaxDecimalsOrPrec, maxDecimals) {
          var targetUnits;
          if (isNumber(targetUnitsOrMaxDecimalsOrPrec)) {
            targetUnits = this.units();
            maxDecimals = targetUnitsOrMaxDecimalsOrPrec;
          } else if (isString(targetUnitsOrMaxDecimalsOrPrec)) {
            targetUnits = targetUnitsOrMaxDecimalsOrPrec;
          } else if (isQty(targetUnitsOrMaxDecimalsOrPrec)) {
            return this.toPrec(targetUnitsOrMaxDecimalsOrPrec).toString(maxDecimals);
          }
          var out = this.to(targetUnits);
          var outScalar = maxDecimals !== void 0 ? round(out.scalar, maxDecimals) : out.scalar;
          out = (outScalar + " " + out.units()).trim();
          return out;
        },
        /**
         * Format the quantity according to optional passed target units
         * and formatter
         *
         * @param {string} [targetUnits=current units] -
         *                 optional units to convert to before formatting
         *
         * @param {function} [formatter=Qty.formatter] -
         *                   delegates formatting to formatter callback.
         *                   formatter is called back with two parameters (scalar, units)
         *                   and should return formatted result.
         *                   If unspecified, formatting is delegated to default formatter
         *                   set to Qty.formatter
         *
         * @example
         * var roundingAndLocalizingFormatter = function(scalar, units) {
         *   // localize or limit scalar to n max decimals for instance
         *   // return formatted result
         * };
         * var qty = Qty('1.1234 m');
         * qty.format(); // same units, default formatter => "1.234 m"
         * qty.format("cm"); // converted to "cm", default formatter => "123.45 cm"
         * qty.format(roundingAndLocalizingFormatter); // same units, custom formatter => "1,2 m"
         * qty.format("cm", roundingAndLocalizingFormatter); // convert to "cm", custom formatter => "123,4 cm"
         *
         * @returns {string} quantity as string
         */
        format: function(targetUnits, formatter) {
          if (arguments.length === 1) {
            if (typeof targetUnits === "function") {
              formatter = targetUnits;
              targetUnits = void 0;
            }
          }
          formatter = formatter || Qty.formatter;
          var targetQty = this.to(targetUnits);
          return formatter.call(this, targetQty.scalar, targetQty.units());
        }
      });
      var stringifiedUnitsCache = new NestedMap();
      function stringifyUnits(units) {
        var stringified = stringifiedUnitsCache.get(units);
        if (stringified) {
          return stringified;
        }
        var isUnity = compareArray(units, UNITY_ARRAY);
        if (isUnity) {
          stringified = "1";
        } else {
          stringified = simplify(getOutputNames(units)).join("*");
        }
        stringifiedUnitsCache.set(units, stringified);
        return stringified;
      }
      function getOutputNames(units) {
        var unitNames = [], token, tokenNext;
        for (var i2 = 0; i2 < units.length; i2++) {
          token = units[i2];
          tokenNext = units[i2 + 1];
          if (PREFIX_VALUES[token]) {
            unitNames.push(OUTPUT_MAP[token] + OUTPUT_MAP[tokenNext]);
            i2++;
          } else {
            unitNames.push(OUTPUT_MAP[token]);
          }
        }
        return unitNames;
      }
      function simplify(units) {
        var unitCounts = units.reduce(function(acc, unit) {
          var unitCounter = acc[unit];
          if (!unitCounter) {
            acc.push(unitCounter = acc[unit] = [unit, 0]);
          }
          unitCounter[1]++;
          return acc;
        }, []);
        return unitCounts.map(function(unitCount) {
          return unitCount[0] + (unitCount[1] > 1 ? unitCount[1] : "");
        });
      }
      Qty.version = "1.8.0";
      return Qty;
    });
  }
});

// node_modules/image-js/lib/util/deepValue.js
var require_deepValue = __commonJS({
  "node_modules/image-js/lib/util/deepValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = deepValue;
    function deepValue(object, path = "") {
      let parts = path.split(".");
      for (let part of parts) {
        if (object[part] === void 0)
          return void 0;
        object = object[part];
      }
      return object;
    }
  }
});

// node_modules/two-product/two-product.js
var require_two_product = __commonJS({
  "node_modules/two-product/two-product.js"(exports2, module2) {
    "use strict";
    module2.exports = twoProduct;
    var SPLITTER = +(Math.pow(2, 27) + 1);
    function twoProduct(a, b, result) {
      var x = a * b;
      var c = SPLITTER * a;
      var abig = c - a;
      var ahi = c - abig;
      var alo = a - ahi;
      var d = SPLITTER * b;
      var bbig = d - b;
      var bhi = d - bbig;
      var blo = b - bhi;
      var err1 = x - ahi * bhi;
      var err2 = err1 - alo * bhi;
      var err3 = err2 - ahi * blo;
      var y = alo * blo - err3;
      if (result) {
        result[0] = y;
        result[1] = x;
        return result;
      }
      return [y, x];
    }
  }
});

// node_modules/robust-sum/robust-sum.js
var require_robust_sum = __commonJS({
  "node_modules/robust-sum/robust-sum.js"(exports2, module2) {
    "use strict";
    module2.exports = linearExpansionSum;
    function scalarScalar(a, b) {
      var x = a + b;
      var bv = x - a;
      var av = x - bv;
      var br = b - bv;
      var ar = a - av;
      var y = ar + br;
      if (y) {
        return [y, x];
      }
      return [x];
    }
    function linearExpansionSum(e, f) {
      var ne = e.length | 0;
      var nf = f.length | 0;
      if (ne === 1 && nf === 1) {
        return scalarScalar(e[0], f[0]);
      }
      var n = ne + nf;
      var g = new Array(n);
      var count = 0;
      var eptr = 0;
      var fptr = 0;
      var abs = Math.abs;
      var ei = e[eptr];
      var ea = abs(ei);
      var fi = f[fptr];
      var fa = abs(fi);
      var a, b;
      if (ea < fa) {
        b = ei;
        eptr += 1;
        if (eptr < ne) {
          ei = e[eptr];
          ea = abs(ei);
        }
      } else {
        b = fi;
        fptr += 1;
        if (fptr < nf) {
          fi = f[fptr];
          fa = abs(fi);
        }
      }
      if (eptr < ne && ea < fa || fptr >= nf) {
        a = ei;
        eptr += 1;
        if (eptr < ne) {
          ei = e[eptr];
          ea = abs(ei);
        }
      } else {
        a = fi;
        fptr += 1;
        if (fptr < nf) {
          fi = f[fptr];
          fa = abs(fi);
        }
      }
      var x = a + b;
      var bv = x - a;
      var y = b - bv;
      var q0 = y;
      var q1 = x;
      var _x, _bv, _av, _br, _ar;
      while (eptr < ne && fptr < nf) {
        if (ea < fa) {
          a = ei;
          eptr += 1;
          if (eptr < ne) {
            ei = e[eptr];
            ea = abs(ei);
          }
        } else {
          a = fi;
          fptr += 1;
          if (fptr < nf) {
            fi = f[fptr];
            fa = abs(fi);
          }
        }
        b = q0;
        x = a + b;
        bv = x - a;
        y = b - bv;
        if (y) {
          g[count++] = y;
        }
        _x = q1 + x;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
      }
      while (eptr < ne) {
        a = ei;
        b = q0;
        x = a + b;
        bv = x - a;
        y = b - bv;
        if (y) {
          g[count++] = y;
        }
        _x = q1 + x;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
        eptr += 1;
        if (eptr < ne) {
          ei = e[eptr];
        }
      }
      while (fptr < nf) {
        a = fi;
        b = q0;
        x = a + b;
        bv = x - a;
        y = b - bv;
        if (y) {
          g[count++] = y;
        }
        _x = q1 + x;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
        fptr += 1;
        if (fptr < nf) {
          fi = f[fptr];
        }
      }
      if (q0) {
        g[count++] = q0;
      }
      if (q1) {
        g[count++] = q1;
      }
      if (!count) {
        g[count++] = 0;
      }
      g.length = count;
      return g;
    }
  }
});

// node_modules/two-sum/two-sum.js
var require_two_sum = __commonJS({
  "node_modules/two-sum/two-sum.js"(exports2, module2) {
    "use strict";
    module2.exports = fastTwoSum;
    function fastTwoSum(a, b, result) {
      var x = a + b;
      var bv = x - a;
      var av = x - bv;
      var br = b - bv;
      var ar = a - av;
      if (result) {
        result[0] = ar + br;
        result[1] = x;
        return result;
      }
      return [ar + br, x];
    }
  }
});

// node_modules/robust-scale/robust-scale.js
var require_robust_scale = __commonJS({
  "node_modules/robust-scale/robust-scale.js"(exports2, module2) {
    "use strict";
    var twoProduct = require_two_product();
    var twoSum = require_two_sum();
    module2.exports = scaleLinearExpansion;
    function scaleLinearExpansion(e, scale) {
      var n = e.length;
      if (n === 1) {
        var ts = twoProduct(e[0], scale);
        if (ts[0]) {
          return ts;
        }
        return [ts[1]];
      }
      var g = new Array(2 * n);
      var q = [0.1, 0.1];
      var t = [0.1, 0.1];
      var count = 0;
      twoProduct(e[0], scale, q);
      if (q[0]) {
        g[count++] = q[0];
      }
      for (var i = 1; i < n; ++i) {
        twoProduct(e[i], scale, t);
        var pq = q[1];
        twoSum(pq, t[0], q);
        if (q[0]) {
          g[count++] = q[0];
        }
        var a = t[1];
        var b = q[1];
        var x = a + b;
        var bv = x - a;
        var y = b - bv;
        q[1] = x;
        if (y) {
          g[count++] = y;
        }
      }
      if (q[1]) {
        g[count++] = q[1];
      }
      if (count === 0) {
        g[count++] = 0;
      }
      g.length = count;
      return g;
    }
  }
});

// node_modules/robust-subtract/robust-diff.js
var require_robust_diff = __commonJS({
  "node_modules/robust-subtract/robust-diff.js"(exports2, module2) {
    "use strict";
    module2.exports = robustSubtract;
    function scalarScalar(a, b) {
      var x = a + b;
      var bv = x - a;
      var av = x - bv;
      var br = b - bv;
      var ar = a - av;
      var y = ar + br;
      if (y) {
        return [y, x];
      }
      return [x];
    }
    function robustSubtract(e, f) {
      var ne = e.length | 0;
      var nf = f.length | 0;
      if (ne === 1 && nf === 1) {
        return scalarScalar(e[0], -f[0]);
      }
      var n = ne + nf;
      var g = new Array(n);
      var count = 0;
      var eptr = 0;
      var fptr = 0;
      var abs = Math.abs;
      var ei = e[eptr];
      var ea = abs(ei);
      var fi = -f[fptr];
      var fa = abs(fi);
      var a, b;
      if (ea < fa) {
        b = ei;
        eptr += 1;
        if (eptr < ne) {
          ei = e[eptr];
          ea = abs(ei);
        }
      } else {
        b = fi;
        fptr += 1;
        if (fptr < nf) {
          fi = -f[fptr];
          fa = abs(fi);
        }
      }
      if (eptr < ne && ea < fa || fptr >= nf) {
        a = ei;
        eptr += 1;
        if (eptr < ne) {
          ei = e[eptr];
          ea = abs(ei);
        }
      } else {
        a = fi;
        fptr += 1;
        if (fptr < nf) {
          fi = -f[fptr];
          fa = abs(fi);
        }
      }
      var x = a + b;
      var bv = x - a;
      var y = b - bv;
      var q0 = y;
      var q1 = x;
      var _x, _bv, _av, _br, _ar;
      while (eptr < ne && fptr < nf) {
        if (ea < fa) {
          a = ei;
          eptr += 1;
          if (eptr < ne) {
            ei = e[eptr];
            ea = abs(ei);
          }
        } else {
          a = fi;
          fptr += 1;
          if (fptr < nf) {
            fi = -f[fptr];
            fa = abs(fi);
          }
        }
        b = q0;
        x = a + b;
        bv = x - a;
        y = b - bv;
        if (y) {
          g[count++] = y;
        }
        _x = q1 + x;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
      }
      while (eptr < ne) {
        a = ei;
        b = q0;
        x = a + b;
        bv = x - a;
        y = b - bv;
        if (y) {
          g[count++] = y;
        }
        _x = q1 + x;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
        eptr += 1;
        if (eptr < ne) {
          ei = e[eptr];
        }
      }
      while (fptr < nf) {
        a = fi;
        b = q0;
        x = a + b;
        bv = x - a;
        y = b - bv;
        if (y) {
          g[count++] = y;
        }
        _x = q1 + x;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
        fptr += 1;
        if (fptr < nf) {
          fi = -f[fptr];
        }
      }
      if (q0) {
        g[count++] = q0;
      }
      if (q1) {
        g[count++] = q1;
      }
      if (!count) {
        g[count++] = 0;
      }
      g.length = count;
      return g;
    }
  }
});

// node_modules/robust-orientation/orientation.js
var require_orientation = __commonJS({
  "node_modules/robust-orientation/orientation.js"(exports2, module2) {
    "use strict";
    var twoProduct = require_two_product();
    var robustSum = require_robust_sum();
    var robustScale = require_robust_scale();
    var robustSubtract = require_robust_diff();
    var NUM_EXPAND = 5;
    var EPSILON = 11102230246251565e-32;
    var ERRBOUND3 = (3 + 16 * EPSILON) * EPSILON;
    var ERRBOUND4 = (7 + 56 * EPSILON) * EPSILON;
    function orientation_3(sum, prod, scale, sub) {
      return function orientation3Exact2(m0, m1, m2) {
        var p = sum(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])));
        var n = sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0]));
        var d = sub(p, n);
        return d[d.length - 1];
      };
    }
    function orientation_4(sum, prod, scale, sub) {
      return function orientation4Exact2(m0, m1, m2, m3) {
        var p = sum(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m3[2]))), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))));
        var n = sum(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m3[2]))), sum(scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m2[2]))));
        var d = sub(p, n);
        return d[d.length - 1];
      };
    }
    function orientation_5(sum, prod, scale, sub) {
      return function orientation5Exact(m0, m1, m2, m3, m4) {
        var p = sum(sum(sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m2[2]), sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), -m3[2]), scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m4[2]))), m1[3]), sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m3[2]), scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m4[2]))), -m2[3]), scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m4[2]))), m3[3]))), sum(scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m3[2]))), -m4[3]), sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m3[2]), scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m4[2]))), m0[3]), scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m3[2]), scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), m4[2]))), -m1[3])))), sum(sum(scale(sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m4[2]))), m3[3]), sum(scale(sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))), -m4[3]), scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m3[2]))), m0[3]))), sum(scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m3[2]))), -m1[3]), sum(scale(sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))), m2[3]), scale(sum(scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m2[2]))), -m3[3])))));
        var n = sum(sum(sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m2[2]), sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), -m3[2]), scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m4[2]))), m0[3]), scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m3[2]), scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), m4[2]))), -m2[3])), sum(scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m4[2]))), m3[3]), scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m3[2]))), -m4[3]))), sum(sum(scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m4[2]))), m0[3]), scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m4[2]))), -m1[3])), sum(scale(sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m4[2]))), m2[3]), scale(sum(scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m2[2]))), -m4[3]))));
        var d = sub(p, n);
        return d[d.length - 1];
      };
    }
    function orientation(n) {
      var fn = n === 3 ? orientation_3 : n === 4 ? orientation_4 : orientation_5;
      return fn(robustSum, twoProduct, robustScale, robustSubtract);
    }
    var orientation3Exact = orientation(3);
    var orientation4Exact = orientation(4);
    var CACHED = [
      function orientation0() {
        return 0;
      },
      function orientation1() {
        return 0;
      },
      function orientation2(a, b) {
        return b[0] - a[0];
      },
      function orientation3(a, b, c) {
        var l = (a[1] - c[1]) * (b[0] - c[0]);
        var r = (a[0] - c[0]) * (b[1] - c[1]);
        var det = l - r;
        var s;
        if (l > 0) {
          if (r <= 0) {
            return det;
          } else {
            s = l + r;
          }
        } else if (l < 0) {
          if (r >= 0) {
            return det;
          } else {
            s = -(l + r);
          }
        } else {
          return det;
        }
        var tol = ERRBOUND3 * s;
        if (det >= tol || det <= -tol) {
          return det;
        }
        return orientation3Exact(a, b, c);
      },
      function orientation4(a, b, c, d) {
        var adx = a[0] - d[0];
        var bdx = b[0] - d[0];
        var cdx = c[0] - d[0];
        var ady = a[1] - d[1];
        var bdy = b[1] - d[1];
        var cdy = c[1] - d[1];
        var adz = a[2] - d[2];
        var bdz = b[2] - d[2];
        var cdz = c[2] - d[2];
        var bdxcdy = bdx * cdy;
        var cdxbdy = cdx * bdy;
        var cdxady = cdx * ady;
        var adxcdy = adx * cdy;
        var adxbdy = adx * bdy;
        var bdxady = bdx * ady;
        var det = adz * (bdxcdy - cdxbdy) + bdz * (cdxady - adxcdy) + cdz * (adxbdy - bdxady);
        var permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz) + (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz) + (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz);
        var tol = ERRBOUND4 * permanent;
        if (det > tol || -det > tol) {
          return det;
        }
        return orientation4Exact(a, b, c, d);
      }
    ];
    function slowOrient(args) {
      var proc2 = CACHED[args.length];
      if (!proc2) {
        proc2 = CACHED[args.length] = orientation(args.length);
      }
      return proc2.apply(void 0, args);
    }
    function proc(slow, o0, o1, o2, o3, o4, o5) {
      return function getOrientation(a0, a1, a2, a3, a4) {
        switch (arguments.length) {
          case 0:
          case 1:
            return 0;
          case 2:
            return o2(a0, a1);
          case 3:
            return o3(a0, a1, a2);
          case 4:
            return o4(a0, a1, a2, a3);
          case 5:
            return o5(a0, a1, a2, a3, a4);
        }
        var s = new Array(arguments.length);
        for (var i = 0; i < arguments.length; ++i) {
          s[i] = arguments[i];
        }
        return slow(s);
      };
    }
    function generateOrientationProc() {
      while (CACHED.length <= NUM_EXPAND) {
        CACHED.push(orientation(CACHED.length));
      }
      module2.exports = proc.apply(void 0, [slowOrient].concat(CACHED));
      for (var i = 0; i <= NUM_EXPAND; ++i) {
        module2.exports[i] = CACHED[i];
      }
    }
    generateOrientationProc();
  }
});

// node_modules/robust-point-in-polygon/robust-pnp.js
var require_robust_pnp = __commonJS({
  "node_modules/robust-point-in-polygon/robust-pnp.js"(exports2, module2) {
    module2.exports = robustPointInPolygon;
    var orient = require_orientation();
    function robustPointInPolygon(vs, point) {
      var x = point[0];
      var y = point[1];
      var n = vs.length;
      var inside = 1;
      var lim = n;
      for (var i = 0, j = n - 1; i < lim; j = i++) {
        var a = vs[i];
        var b = vs[j];
        var yi = a[1];
        var yj = b[1];
        if (yj < yi) {
          if (yj < y && y < yi) {
            var s = orient(a, b, point);
            if (s === 0) {
              return 0;
            } else {
              inside ^= 0 < s | 0;
            }
          } else if (y === yi) {
            var c = vs[(i + 1) % n];
            var yk = c[1];
            if (yi < yk) {
              var s = orient(a, b, point);
              if (s === 0) {
                return 0;
              } else {
                inside ^= 0 < s | 0;
              }
            }
          }
        } else if (yi < yj) {
          if (yi < y && y < yj) {
            var s = orient(a, b, point);
            if (s === 0) {
              return 0;
            } else {
              inside ^= s < 0 | 0;
            }
          } else if (y === yi) {
            var c = vs[(i + 1) % n];
            var yk = c[1];
            if (yk < yi) {
              var s = orient(a, b, point);
              if (s === 0) {
                return 0;
              } else {
                inside ^= s < 0 | 0;
              }
            }
          }
        } else if (y === yi) {
          var x0 = Math.min(a[0], b[0]);
          var x1 = Math.max(a[0], b[0]);
          if (i === 0) {
            while (j > 0) {
              var k = (j + n - 1) % n;
              var p = vs[k];
              if (p[1] !== y) {
                break;
              }
              var px = p[0];
              x0 = Math.min(x0, px);
              x1 = Math.max(x1, px);
              j = k;
            }
            if (j === 0) {
              if (x0 <= x && x <= x1) {
                return 0;
              }
              return 1;
            }
            lim = j + 1;
          }
          var y0 = vs[(j + n - 1) % n][1];
          while (i + 1 < lim) {
            var p = vs[i + 1];
            if (p[1] !== y) {
              break;
            }
            var px = p[0];
            x0 = Math.min(x0, px);
            x1 = Math.max(x1, px);
            i += 1;
          }
          if (x0 <= x && x <= x1) {
            return 0;
          }
          var y1 = vs[(i + 1) % n][1];
          if (x < x0 && y0 < y !== y1 < y) {
            inside ^= 1;
          }
        }
      }
      return 2 * inside - 1;
    }
  }
});

// node_modules/image-js/lib/image/roi/feretDiameters.js
var require_feretDiameters = __commonJS({
  "node_modules/image-js/lib/image/roi/feretDiameters.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = feretDiameters;
    var _points = require_points2();
    var _monotoneChainConvexHull = _interopRequireDefault(require_monotoneChainConvexHull());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function feretDiameters(options = {}) {
      const {
        originalPoints = _monotoneChainConvexHull.default.call(this)
      } = options;
      if (originalPoints.length === 0) {
        return {
          min: 0,
          max: 0,
          minLine: [],
          maxLine: [],
          aspectRatio: 1
        };
      }
      if (originalPoints.length === 1) {
        return {
          min: 1,
          max: 1,
          minLine: [originalPoints[0], originalPoints[0]],
          maxLine: [originalPoints[0], originalPoints[0]],
          aspectRatio: 1
        };
      }
      const temporaryPoints = new Array(originalPoints.length);
      let minWidth = Infinity;
      let minWidthAngle = 0;
      let minLine = [];
      for (let i = 0; i < originalPoints.length; i++) {
        let angle = getAngle(originalPoints[i], originalPoints[(i + 1) % originalPoints.length]);
        (0, _points.rotate)(-angle, originalPoints, temporaryPoints);
        let currentWidth = 0;
        let currentMinLine = [];
        for (let j = 0; j < originalPoints.length; j++) {
          let absWidth = Math.abs(temporaryPoints[i][1] - temporaryPoints[j][1]);
          if (absWidth > currentWidth) {
            currentWidth = absWidth;
            currentMinLine = [];
            currentMinLine.push([temporaryPoints[j][0], temporaryPoints[i][1]], [temporaryPoints[j][0], temporaryPoints[j][1]]);
          }
        }
        if (currentWidth < minWidth) {
          minWidth = currentWidth;
          minWidthAngle = angle;
          minLine = currentMinLine;
        }
      }
      (0, _points.rotate)(minWidthAngle, minLine, minLine);
      let maxWidth = 0;
      let maxLine = [];
      let maxSquaredWidth = 0;
      for (let i = 0; i < originalPoints.length - 1; i++) {
        for (let j = i + 1; j < originalPoints.length; j++) {
          let currentSquaredWidth = (originalPoints[i][0] - originalPoints[j][0]) ** 2 + (originalPoints[i][1] - originalPoints[j][1]) ** 2;
          if (currentSquaredWidth > maxSquaredWidth) {
            maxSquaredWidth = currentSquaredWidth;
            maxWidth = Math.sqrt(currentSquaredWidth);
            maxLine = [originalPoints[i], originalPoints[j]];
          }
        }
      }
      return {
        min: minWidth,
        minLine,
        max: maxWidth,
        maxLine,
        aspectRatio: minWidth / maxWidth
      };
    }
    function getAngle(p1, p2) {
      let diff = (0, _points.difference)(p2, p1);
      let vector = (0, _points.normalize)(diff);
      let angle = Math.acos(vector[0]);
      if (vector[1] < 0)
        return -angle;
      return angle;
    }
  }
});

// node_modules/image-js/lib/image/roi/Roi.js
var require_Roi = __commonJS({
  "node_modules/image-js/lib/image/roi/Roi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _monotoneChainConvexHull = _interopRequireDefault(require_lib19());
    var _robustPointInPolygon = _interopRequireDefault(require_robust_pnp());
    var _Shape = _interopRequireDefault(require_Shape());
    var _points = require_points2();
    var _Image = _interopRequireDefault(require_Image());
    var _minimalBoundingRectangle = _interopRequireDefault(require_minimalBoundingRectangle());
    var KindNames = _interopRequireWildcard(require_kindNames());
    var _feretDiameters = _interopRequireDefault(require_feretDiameters());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != typeof e && "function" != typeof e)
        return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n.default = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Roi = class {
      constructor(map, id) {
        this.map = map;
        this.id = id;
        this.minX = Number.POSITIVE_INFINITY;
        this.maxX = Number.NEGATIVE_INFINITY;
        this.minY = Number.POSITIVE_INFINITY;
        this.maxY = Number.NEGATIVE_INFINITY;
        this.meanX = 0;
        this.meanY = 0;
        this.surface = 0;
        this.computed = {};
      }
      /**
       * Returns a binary image (mask) for the corresponding ROI
       * @param {object} [options]
       * @param {number} [options.scale=1] - Scaling factor to apply to the mask
       * @param {string} [options.kind='normal'] - 'contour', 'box', 'filled', 'center', 'hull' or 'normal'
       * @return {Image} - Returns a mask (1 bit Image)
       */
      getMask(options = {}) {
        const {
          scale = 1,
          kind = ""
        } = options;
        let mask;
        switch (kind) {
          case "contour":
            mask = this.contourMask;
            break;
          case "box":
            mask = this.boxMask;
            break;
          case "filled":
            mask = this.filledMask;
            break;
          case "center":
            mask = this.centerMask;
            break;
          case "mbr":
            mask = this.mbrFilledMask;
            break;
          case "hull":
            mask = this.convexHullFilledMask;
            break;
          case "hullContour":
            mask = this.convexHullMask;
            break;
          case "mbrContour":
            mask = this.mbrMask;
            break;
          case "feret":
            mask = this.feretMask;
            break;
          default:
            mask = this.mask;
        }
        if (scale < 1) {
          mask = mask.resize({
            factor: scale
          });
          mask.parent = this.mask.parent;
          mask.position[0] += this.minX;
          mask.position[1] += this.minY;
        }
        return mask;
      }
      get mean() {
        throw new Error("Roi mean not implemented yet");
      }
      get center() {
        if (!this.computed.center) {
          this.computed.center = [this.width / 2 >> 0, this.height / 2 >> 0];
        }
        return this.computed.center;
      }
      get ratio() {
        return this.width / this.height;
      }
      get width() {
        return this.maxX - this.minX + 1;
      }
      get height() {
        return this.maxY - this.minY + 1;
      }
      _computExternalIDs() {
        let borders = this.borderIDs;
        let lengths = this.borderLengths;
        this.computed.externalIDs = [];
        this.computed.externalLengths = [];
        let internals = this.internalIDs;
        for (let i = 0; i < borders.length; i++) {
          if (!internals.includes(borders[i])) {
            this.computed.externalIDs.push(borders[i]);
            this.computed.externalLengths.push(lengths[i]);
          }
        }
      }
      get externalIDs() {
        if (this.computed.externalIDs) {
          return this.computed.externalIDs;
        }
        this._computExternalIDs();
        return this.computed.externalIDs;
      }
      get externalLengths() {
        if (this.computed.externalLengths) {
          return this.computed.externalLengths;
        }
        this._computExternalIDs();
        return this.computed.externalLengths;
      }
      _computeBorderIDs() {
        let borders = getBorders(this);
        this.computed.borderIDs = borders.ids;
        this.computed.borderLengths = borders.lengths;
      }
      /**
         Retrieve all the IDs (array of number) of the regions that are in contact with this
         specific region. It may be external or internal
         */
      get borderIDs() {
        if (this.computed.borderIDs) {
          return this.computed.borderIDs;
        }
        this._computeBorderIDs();
        return this.computed.borderIDs;
      }
      /**
         Retrieve all the length (array of number) of the contacts with this
         specific region. It may be external or internal
         */
      get borderLengths() {
        if (this.computed.borderLengths) {
          return this.computed.borderLengths;
        }
        this._computeBorderIDs();
        return this.computed.borderLengths;
      }
      /**
         Retrieve all the IDs or the Roi touching the box surrouding the region
          It should really be an array to solve complex cases related to border effect
          Like the image
         <pre>
         0000
         1111
         0000
         1111
         </pre>
          The first row of 1 will be surrouned by 2 differents zones
          Or even worse
         <pre>
         010
         111
         010
         </pre>
         The cross will be surrouned by 4 differents zones
          However in most of the cases it will be an array of one element
         */
      get boxIDs() {
        if (!this.computed.boxIDs) {
          this.computed.boxIDs = getBoxIDs(this);
        }
        return this.computed.boxIDs;
      }
      get internalIDs() {
        if (!this.computed.internalIDs) {
          this.computed.internalIDs = getInternalIDs(this);
        }
        return this.computed.internalIDs;
      }
      /**
         Number of pixels of the Roi that touch the rectangle
         This is useful for the calculation of the border
         because we will ignore those special pixels of the rectangle
         border that don't have neighbours all around them.
         */
      get box() {
        if (!this.computed.box) {
          this.computed.box = getBox(this);
        }
        return this.computed.box;
      }
      /**
         Calculates the number of pixels that are in the external border of the Roi
         Contour are all the pixels that touch an external "zone".
         All the pixels that touch the box are part of the border and
         are calculated in the getBoxPixels procedure
         */
      get external() {
        if (!this.computed.external) {
          this.computed.external = getExternal(this);
        }
        return this.computed.external;
      }
      /**
         Calculates information about holes
         */
      get holesInfo() {
        if (!this.computed.holesInfo) {
          this.computed.holesInfo = getHolesInfo(this);
        }
        return this.computed.holesInfo;
      }
      /**
         Calculates the number of pixels that are involved in border
         Border are all the pixels that touch another "zone". It could be external
         or internal. If there is a hole in the zone it will be counted as a border.
         All the pixels that touch the box are part of the border and
         are calculated in the getBoxPixels procedure
         */
      get border() {
        if (!this.computed.border) {
          this.computed.border = getBorder(this);
        }
        return this.computed.border;
      }
      /**
        Returns a binary image (mask) containing only the border of the mask
      */
      get contourMask() {
        if (!this.computed.contourMask) {
          let img = new _Image.default(this.width, this.height, {
            kind: KindNames.BINARY,
            position: [this.minX, this.minY],
            parent: this.map.parent
          });
          for (let x = 0; x < this.width; x++) {
            for (let y = 0; y < this.height; y++) {
              if (this.map.data[x + this.minX + (y + this.minY) * this.map.width] === this.id) {
                if (x > 0 && x < this.width - 1 && y > 0 && y < this.height - 1) {
                  if (this.map.data[x - 1 + this.minX + (y + this.minY) * this.map.width] !== this.id || this.map.data[x + 1 + this.minX + (y + this.minY) * this.map.width] !== this.id || this.map.data[x + this.minX + (y - 1 + this.minY) * this.map.width] !== this.id || this.map.data[x + this.minX + (y + 1 + this.minY) * this.map.width] !== this.id) {
                    img.setBitXY(x, y);
                  }
                } else {
                  img.setBitXY(x, y);
                }
              }
            }
          }
          this.computed.contourMask = img;
        }
        return this.computed.contourMask;
      }
      get boxMask() {
        if (!this.computed.boxMask) {
          let img = new _Image.default(this.width, this.height, {
            kind: KindNames.BINARY,
            position: [this.minX, this.minY],
            parent: this.map.parent
          });
          for (let x = 0; x < this.width; x++) {
            img.setBitXY(x, 0);
            img.setBitXY(x, this.height - 1);
          }
          for (let y = 0; y < this.height; y++) {
            img.setBitXY(0, y);
            img.setBitXY(this.width - 1, y);
          }
          this.computed.boxMask = img;
        }
        return this.computed.boxMask;
      }
      /**
         Returns a binary image containing the mask
         */
      get mask() {
        if (!this.computed.mask) {
          let img = new _Image.default(this.width, this.height, {
            kind: KindNames.BINARY,
            position: [this.minX, this.minY],
            parent: this.map.parent
          });
          for (let x = 0; x < this.width; x++) {
            for (let y = 0; y < this.height; y++) {
              if (this.map.data[x + this.minX + (y + this.minY) * this.map.width] === this.id) {
                img.setBitXY(x, y);
              }
            }
          }
          this.computed.mask = img;
        }
        return this.computed.mask;
      }
      get filledMask() {
        if (!this.computed.filledMask) {
          let img = new _Image.default(this.width, this.height, {
            kind: KindNames.BINARY,
            position: [this.minX, this.minY],
            parent: this.map.parent
          });
          for (let x = 0; x < this.width; x++) {
            for (let y = 0; y < this.height; y++) {
              let target = x + this.minX + (y + this.minY) * this.map.width;
              if (this.internalIDs.includes(this.map.data[target])) {
                img.setBitXY(x, y);
              }
            }
          }
          this.computed.filledMask = img;
        }
        return this.computed.filledMask;
      }
      get centerMask() {
        if (!this.computed.centerMask) {
          let img = new _Shape.default({
            kind: "smallCross"
          }).getMask();
          img.parent = this.map.parent;
          img.position = [this.minX + this.center[0] - 1, this.minY + this.center[1] - 1];
          this.computed.centerMask = img;
        }
        return this.computed.centerMask;
      }
      get convexHull() {
        if (!this.computed.convexHull) {
          const calculationPoints = [];
          for (let x = 0; x < this.width; x++) {
            for (let y = 0; y < this.height; y++) {
              if (this.map.data[x + this.minX + (y + this.minY) * this.map.width] === this.id) {
                if (x > 0 && x < this.width - 1 && y > 0 && y < this.height - 1) {
                  if (this.map.data[x - 1 + this.minX + (y + this.minY) * this.map.width] !== this.id || this.map.data[x + 1 + this.minX + (y + this.minY) * this.map.width] !== this.id || this.map.data[x + this.minX + (y - 1 + this.minY) * this.map.width] !== this.id || this.map.data[x + this.minX + (y + 1 + this.minY) * this.map.width] !== this.id) {
                    calculationPoints.push([x, y]);
                    calculationPoints.push([x + 1, y]);
                    calculationPoints.push([x, y + 1]);
                    calculationPoints.push([x + 1, y + 1]);
                  }
                } else {
                  calculationPoints.push([x, y]);
                  calculationPoints.push([x + 1, y]);
                  calculationPoints.push([x, y + 1]);
                  calculationPoints.push([x + 1, y + 1]);
                }
              }
            }
          }
          const convexHull = (0, _monotoneChainConvexHull.default)(calculationPoints);
          this.computed.convexHull = {
            polyline: convexHull,
            surface: (0, _points.surface)(convexHull),
            perimeter: (0, _points.perimeter)(convexHull)
          };
        }
        return this.computed.convexHull;
      }
      get convexHullMask() {
        if (!this.computed.convexHullMask) {
          const convexHull = this.convexHull;
          const img = new _Image.default(this.width + 1, this.height + 1, {
            kind: KindNames.BINARY,
            position: [this.minX, this.minY],
            parent: this.map.parent
          });
          img.paintPolyline(convexHull.polyline, {
            closed: true
          });
          this.computed.convexHullMask = img;
        }
        return this.computed.convexHullMask;
      }
      get convexHullFilledMask() {
        if (!this.computed.convexHullFilledMask) {
          const convexHull = this.convexHull;
          const img = new _Image.default(this.width, this.height, {
            kind: KindNames.BINARY,
            position: [this.minX, this.minY],
            parent: this.map.parent
          });
          for (let x = 0; x < this.width; x++) {
            for (let y = 0; y < this.height; y++) {
              if ((0, _robustPointInPolygon.default)(convexHull.polyline, [x, y]) !== 1) {
                img.setBitXY(x, y);
              }
            }
          }
          this.computed.convexHullFilledMask = img;
        }
        return this.computed.convexHullFilledMask;
      }
      get mbr() {
        if (!this.computed.mbr) {
          let mbr = (0, _minimalBoundingRectangle.default)({
            originalPoints: this.convexHull.polyline
          });
          if (mbr.length === 0) {
            this.computed.mbr = {
              width: 0,
              height: 0,
              surface: 0,
              perimeter: 0,
              rectangle: mbr
            };
          } else {
            let first = mbr[0];
            let second = mbr[1];
            let third = mbr[2];
            let width = Math.sqrt((first[0] - second[0]) ** 2 + (first[1] - second[1]) ** 2);
            let height = Math.sqrt((third[0] - second[0]) ** 2 + (third[1] - second[1]) ** 2);
            this.computed.mbr = {
              width,
              height,
              elongation: 1 - width / height,
              aspectRatio: width / height,
              surface: width * height,
              perimeter: (width + height) * 2,
              rectangle: mbr
            };
          }
        }
        return this.computed.mbr;
      }
      get fillRatio() {
        return this.surface / (this.surface + this.holesInfo.surface);
      }
      get feretDiameters() {
        if (!this.computed.feretDiameters) {
          this.computed.feretDiameters = (0, _feretDiameters.default)({
            originalPoints: this.convexHull.polyline
          });
        }
        return this.computed.feretDiameters;
      }
      /**
       * Diameter of a circle of equal projection area
       */
      get eqpc() {
        if (!this.computed.eqpc) {
          this.computed.eqpc = 2 * Math.sqrt(this.surface / Math.PI);
        }
        return this.computed.eqpc;
      }
      /**
       * Get the category in which each external pixel belongs
       */
      get perimeterInfo() {
        if (!this.computed.perimeterInfo) {
          this.computed.perimeterInfo = getPerimeterInfo(this);
        }
        return this.computed.perimeterInfo;
      }
      /**
       * Return the perimeter of the ROI
       */
      get perimeter() {
        let info = this.perimeterInfo;
        let delta = 2 - Math.sqrt(2);
        return info.one + info.two * 2 + info.three * 3 + info.four * 4 - delta * (info.two + info.three * 2 + info.four);
      }
      /**
       * Diameter of a circle of equal perimeter
       */
      get ped() {
        if (!this.computed.ped) {
          this.computed.ped = this.perimeter / Math.PI;
        }
        return this.computed.ped;
      }
      get feretMask() {
        if (!this.computed.feretMask) {
          const image = new _Image.default(this.width + 1, this.height + 1, {
            kind: KindNames.BINARY,
            position: [this.minX, this.minY],
            parent: this.map.parent
          });
          image.paintPolyline(this.feretDiameters.minLine);
          image.paintPolyline(this.feretDiameters.maxLine);
          this.computed.feretMask = image;
        }
        return this.computed.feretMask;
      }
      get mbrMask() {
        if (!this.computed.mbrMask) {
          let rectangle = (0, _points.round)(this.mbr.rectangle);
          if (rectangle.length > 0) {
            const minMax = (0, _points.minMax)(rectangle);
            const img = new _Image.default(minMax[1][0] - minMax[0][0] + 1, minMax[1][1] - minMax[0][1] + 1, {
              kind: KindNames.BINARY,
              position: [this.minX + minMax[0][0], this.minY + minMax[0][1]],
              parent: this.map.parent
            });
            rectangle = (0, _points.moveToZeroZero)(rectangle);
            img.paintPolyline(rectangle, {
              closed: true
            });
            this.computed.mbrMask = img;
          } else {
            this.computed.mbrMask = new _Image.default(1, 1, {
              kind: KindNames.BINARY,
              position: [this.minX, this.minY],
              parent: this.map.parent
            });
          }
        }
        return this.computed.mbrMask;
      }
      get mbrFilledMask() {
        if (!this.computed.mbrFilledMask) {
          const img = new _Image.default(this.width, this.height, {
            kind: KindNames.BINARY,
            position: [this.minX, this.minY],
            parent: this.map.parent
          });
          const mbr = this.mask.minimalBoundingRectangle();
          for (let x = 0; x < this.width; x++) {
            for (let y = 0; y < this.height; y++) {
              if ((0, _robustPointInPolygon.default)(mbr, [x, y]) !== 1) {
                img.setBitXY(x, y);
              }
            }
          }
          this.computed.mbrFilledMask = img;
        }
        return this.computed.mbrFilledMask;
      }
      get points() {
        if (!this.computed.points) {
          let points = [];
          for (let y = 0; y < this.height; y++) {
            for (let x = 0; x < this.width; x++) {
              let target = (y + this.minY) * this.map.width + x + this.minX;
              if (this.map.data[target] === this.id) {
                points.push([x, y]);
              }
            }
          }
          this.computed.points = points;
        }
        return this.computed.points;
      }
      get maxLengthPoints() {
        if (!this.computed.maxLengthPoints) {
          let maxLength = 0;
          let maxLengthPoints;
          const points = this.points;
          for (let i = 0; i < points.length; i++) {
            for (let j = i + 1; j < points.length; j++) {
              let currentML = Math.pow(points[i][0] - points[j][0], 2) + Math.pow(points[i][1] - points[j][1], 2);
              if (currentML >= maxLength) {
                maxLength = currentML;
                maxLengthPoints = [points[i], points[j]];
              }
            }
          }
          this.computed.maxLengthPoints = maxLengthPoints;
        }
        return this.computed.maxLengthPoints;
      }
      /**
            Calculates the maximum length between two pixels of the Roi.
         */
      get maxLength() {
        if (!this.computed.maxLength) {
          let maxLength = Math.sqrt(Math.pow(this.maxLengthPoints[0][0] - this.maxLengthPoints[1][0], 2) + Math.pow(this.maxLengthPoints[0][1] - this.maxLengthPoints[1][1], 2));
          this.computed.maxLength = maxLength;
        }
        return this.computed.maxLength;
      }
      get roundness() {
        return 4 * this.surface / (Math.PI * this.feretDiameters.max ** 2);
      }
      get sphericity() {
        return 2 * Math.sqrt(this.surface * Math.PI) / this.perimeter;
      }
      get solidity() {
        return this.surface / this.convexHull.surface;
      }
      get angle() {
        if (!this.computed.angle) {
          let points = this.maxLengthPoints;
          let angle = -Math.atan2(points[0][1] - points[1][1], points[0][0] - points[1][0]) * 180 / Math.PI;
          this.computed.angle = angle;
        }
        return this.computed.angle;
      }
      toJSON() {
        return {
          id: this.id,
          minX: this.minX,
          maxX: this.maxX,
          minY: this.minY,
          maxY: this.maxY,
          meanX: this.meanX,
          meanY: this.meanY,
          height: this.height,
          width: this.width,
          surface: this.surface,
          mbrWidth: this.mbr.width,
          mbrHeight: this.mbr.height,
          mbrSurface: this.mbr.surface,
          eqpc: this.eqpc,
          ped: this.ped,
          feretDiameterMin: this.feretDiameters.min,
          feretDiameterMax: this.feretDiameters.max,
          aspectRatio: this.feretDiameters.aspectRatio,
          fillRatio: this.fillRatio,
          sphericity: this.sphericity,
          roundness: this.roundness,
          solidity: this.solidity,
          perimeter: this.perimeter
        };
      }
    };
    exports2.default = Roi;
    function getBorders(roi) {
      let roiMap = roi.map;
      let data = roiMap.data;
      let surroudingIDs = /* @__PURE__ */ new Set();
      let surroundingBorders = /* @__PURE__ */ new Map();
      let visitedData = /* @__PURE__ */ new Set();
      let dx = [1, 0, -1, 0];
      let dy = [0, 1, 0, -1];
      for (let x = roi.minX; x <= roi.maxX; x++) {
        for (let y = roi.minY; y <= roi.maxY; y++) {
          let target = x + y * roiMap.width;
          if (data[target] === roi.id) {
            for (let dir = 0; dir < 4; dir++) {
              let newX = x + dx[dir];
              let newY = y + dy[dir];
              if (newX >= 0 && newY >= 0 && newX < roiMap.width && newY < roiMap.height) {
                let neighbour = newX + newY * roiMap.width;
                if (data[neighbour] !== roi.id && !visitedData.has(neighbour)) {
                  visitedData.add(neighbour);
                  surroudingIDs.add(data[neighbour]);
                  let surroundingBorder = surroundingBorders.get(data[neighbour]);
                  if (!surroundingBorder) {
                    surroundingBorders.set(data[neighbour], 1);
                  } else {
                    surroundingBorders.set(data[neighbour], ++surroundingBorder);
                  }
                }
              }
            }
          }
        }
      }
      let ids = Array.from(surroudingIDs);
      let borderLengths = ids.map(function(id) {
        return surroundingBorders.get(id);
      });
      return {
        ids,
        lengths: borderLengths
      };
    }
    function getBoxIDs(roi) {
      let surroundingIDs = /* @__PURE__ */ new Set();
      let roiMap = roi.map;
      let data = roiMap.data;
      for (let y of [0, roi.height - 1]) {
        for (let x = 0; x < roi.width; x++) {
          let target = (y + roi.minY) * roiMap.width + x + roi.minX;
          if (x - roi.minX > 0 && data[target] === roi.id && data[target - 1] !== roi.id) {
            let value = data[target - 1];
            surroundingIDs.add(value);
          }
          if (roiMap.width - x - roi.minX > 1 && data[target] === roi.id && data[target + 1] !== roi.id) {
            let value = data[target + 1];
            surroundingIDs.add(value);
          }
        }
      }
      for (let x of [0, roi.width - 1]) {
        for (let y = 0; y < roi.height; y++) {
          let target = (y + roi.minY) * roiMap.width + x + roi.minX;
          if (y - roi.minY > 0 && data[target] === roi.id && data[target - roiMap.width] !== roi.id) {
            let value = data[target - roiMap.width];
            surroundingIDs.add(value);
          }
          if (roiMap.height - y - roi.minY > 1 && data[target] === roi.id && data[target + roiMap.width] !== roi.id) {
            let value = data[target + roiMap.width];
            surroundingIDs.add(value);
          }
        }
      }
      return Array.from(surroundingIDs);
    }
    function getBox(roi) {
      let total = 0;
      let roiMap = roi.map;
      let data = roiMap.data;
      let topBottom = [0];
      if (roi.height > 1) {
        topBottom[1] = roi.height - 1;
      }
      for (let y of topBottom) {
        for (let x = 1; x < roi.width - 1; x++) {
          let target = (y + roi.minY) * roiMap.width + x + roi.minX;
          if (data[target] === roi.id) {
            total++;
          }
        }
      }
      let leftRight = [0];
      if (roi.width > 1) {
        leftRight[1] = roi.width - 1;
      }
      for (let x of leftRight) {
        for (let y = 0; y < roi.height; y++) {
          let target = (y + roi.minY) * roiMap.width + x + roi.minX;
          if (data[target] === roi.id) {
            total++;
          }
        }
      }
      return total;
    }
    function getBorder(roi) {
      let total = 0;
      let roiMap = roi.map;
      let data = roiMap.data;
      for (let x = 1; x < roi.width - 1; x++) {
        for (let y = 1; y < roi.height - 1; y++) {
          let target = (y + roi.minY) * roiMap.width + x + roi.minX;
          if (data[target] === roi.id) {
            if (data[target - 1] !== roi.id || data[target + 1] !== roi.id || data[target - roiMap.width] !== roi.id || data[target + roiMap.width] !== roi.id) {
              total++;
            }
          }
        }
      }
      return total + roi.box;
    }
    function getPerimeterInfo(roi) {
      let roiMap = roi.map;
      let data = roiMap.data;
      let one = 0;
      let two = 0;
      let three = 0;
      let four = 0;
      for (let x = 0; x < roi.width; x++) {
        for (let y = 0; y < roi.height; y++) {
          let target = (y + roi.minY) * roiMap.width + x + roi.minX;
          if (data[target] === roi.id) {
            let nbAround = 0;
            if (x === 0) {
              nbAround++;
            } else if (roi.externalIDs.includes(data[target - 1])) {
              nbAround++;
            }
            if (x === roi.width - 1) {
              nbAround++;
            } else if (roi.externalIDs.includes(data[target + 1])) {
              nbAround++;
            }
            if (y === 0) {
              nbAround++;
            } else if (roi.externalIDs.includes(data[target - roiMap.width])) {
              nbAround++;
            }
            if (y === roi.height - 1) {
              nbAround++;
            } else if (roi.externalIDs.includes(data[target + roiMap.width])) {
              nbAround++;
            }
            switch (nbAround) {
              case 1:
                one++;
                break;
              case 2:
                two++;
                break;
              case 3:
                three++;
                break;
              case 4:
                four++;
                break;
              default:
            }
          }
        }
      }
      return {
        one,
        two,
        three,
        four
      };
    }
    function getExternal(roi) {
      let total = 0;
      let roiMap = roi.map;
      let data = roiMap.data;
      for (let x = 1; x < roi.width - 1; x++) {
        for (let y = 1; y < roi.height - 1; y++) {
          let target = (y + roi.minY) * roiMap.width + x + roi.minX;
          if (data[target] === roi.id) {
            if (roi.externalIDs.includes(data[target - 1]) || roi.externalIDs.includes(data[target + 1]) || roi.externalIDs.includes(data[target - roiMap.width]) || roi.externalIDs.includes(data[target + roiMap.width])) {
              total++;
            }
          }
        }
      }
      return total + roi.box;
    }
    function getHolesInfo(roi) {
      let surface = 0;
      let width = roi.map.width;
      let data = roi.map.data;
      for (let x = 1; x < roi.width - 1; x++) {
        for (let y = 1; y < roi.height - 1; y++) {
          let target = (y + roi.minY) * width + x + roi.minX;
          if (roi.internalIDs.includes(data[target]) && data[target] !== roi.id) {
            surface++;
          }
        }
      }
      return {
        number: roi.internalIDs.length - 1,
        surface
      };
    }
    function getInternalIDs(roi) {
      let internal = [roi.id];
      let roiMap = roi.map;
      let data = roiMap.data;
      if (roi.height > 2) {
        for (let x = 0; x < roi.width; x++) {
          let target = roi.minY * roiMap.width + x + roi.minX;
          if (internal.includes(data[target])) {
            let id = data[target + roiMap.width];
            if (!internal.includes(id) && !roi.boxIDs.includes(id)) {
              internal.push(id);
            }
          }
        }
      }
      let array = new Array(4);
      for (let x = 1; x < roi.width - 1; x++) {
        for (let y = 1; y < roi.height - 1; y++) {
          let target = (y + roi.minY) * roiMap.width + x + roi.minX;
          if (internal.includes(data[target])) {
            array[0] = data[target - 1];
            array[1] = data[target + 1];
            array[2] = data[target - roiMap.width];
            array[3] = data[target + roiMap.width];
            for (let i = 0; i < 4; i++) {
              let id = array[i];
              if (!internal.includes(id) && !roi.boxIDs.includes(id)) {
                internal.push(id);
              }
            }
          }
        }
      }
      return internal;
    }
  }
});

// node_modules/image-js/lib/image/roi/RoiLayer.js
var require_RoiLayer = __commonJS({
  "node_modules/image-js/lib/image/roi/RoiLayer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _Roi = _interopRequireDefault(require_Roi());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var RoiLayer = class {
      constructor(roiMap, options) {
        this.roiMap = roiMap;
        this.options = options;
        this.roi = this.createRoi();
      }
      /**
       * Roi are created from a roiMap
       * The roiMap contains mainty an array of identifiers that define
       * for each data to which Roi it belongs
       * @memberof RoiManager
       * @instance
       * @return {Roi[]}
       */
      createRoi() {
        let data = this.roiMap.data;
        let mapIDs = {};
        this.roiMap.positive = 0;
        this.roiMap.negative = 0;
        for (let i = 0; i < data.length; i++) {
          if (data[i] && !mapIDs[data[i]]) {
            mapIDs[data[i]] = true;
            if (data[i] > 0) {
              this.roiMap.positive++;
            } else {
              this.roiMap.negative++;
            }
          }
        }
        let rois = {};
        for (let mapID in mapIDs) {
          rois[mapID] = new _Roi.default(this.roiMap, mapID * 1);
        }
        let width = this.roiMap.width;
        let height = this.roiMap.height;
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            let target = y * width + x;
            if (data[target] !== 0) {
              const mapID = data[target];
              const roi = rois[mapID];
              if (x < roi.minX) {
                roi.minX = x;
              }
              if (x > roi.maxX) {
                roi.maxX = x;
              }
              if (y < roi.minY) {
                roi.minY = y;
              }
              if (y > roi.maxY) {
                roi.maxY = y;
              }
              roi.meanX += x;
              roi.meanY += y;
              roi.surface++;
            }
          }
        }
        let roiArray = [];
        for (let mapID in mapIDs) {
          rois[mapID].meanX /= rois[mapID].surface;
          rois[mapID].meanY /= rois[mapID].surface;
          roiArray.push(rois[mapID]);
        }
        return roiArray;
      }
    };
    exports2.default = RoiLayer;
  }
});

// node_modules/image-js/lib/image/roi/util/commonBorderLength.js
var require_commonBorderLength = __commonJS({
  "node_modules/image-js/lib/image/roi/util/commonBorderLength.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = commonBorderLength;
    function commonBorderLength(roiMap) {
      let data = roiMap.data;
      let dx = [1, 0, -1, 0];
      let dy = [0, 1, 0, -1];
      let minMax = roiMap.minMax;
      let shift = -minMax.min;
      let max = minMax.max + shift;
      let borderInfo = [];
      for (let i = 0; i <= max; i++) {
        borderInfo.push(/* @__PURE__ */ Object.create(null));
      }
      for (let x = 0; x < roiMap.width; x++) {
        for (let y = 0; y < roiMap.height; y++) {
          let target = x + y * roiMap.width;
          let currentRoiID = data[target];
          if (currentRoiID !== 0) {
            let used = /* @__PURE__ */ Object.create(null);
            let isBorder = false;
            for (let dir = 0; dir < 4; dir++) {
              let newX = x + dx[dir];
              let newY = y + dy[dir];
              if (newX >= 0 && newY >= 0 && newX < roiMap.width && newY < roiMap.height) {
                let neighbourRoiID = data[newX + newY * roiMap.width];
                if (currentRoiID !== neighbourRoiID) {
                  isBorder = true;
                  if (neighbourRoiID !== 0 && used[neighbourRoiID] === void 0) {
                    used[neighbourRoiID] = true;
                    if (!borderInfo[neighbourRoiID + shift][currentRoiID]) {
                      borderInfo[neighbourRoiID + shift][currentRoiID] = 1;
                    } else {
                      borderInfo[neighbourRoiID + shift][currentRoiID]++;
                    }
                  }
                }
              } else {
                isBorder = true;
              }
            }
            if (isBorder) {
              if (!borderInfo[currentRoiID + shift][currentRoiID]) {
                borderInfo[currentRoiID + shift][currentRoiID] = 1;
              } else {
                borderInfo[currentRoiID + shift][currentRoiID]++;
              }
            }
          }
        }
      }
      let result = {};
      for (let i = 0; i < borderInfo.length; i++) {
        if (Object.keys(borderInfo[i]).length > 0) {
          result[i - shift] = borderInfo[i];
        }
      }
      return result;
    }
  }
});

// node_modules/image-js/lib/image/roi/util/mergeRoi.js
var require_mergeRoi = __commonJS({
  "node_modules/image-js/lib/image/roi/util/mergeRoi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = mergeRoi;
    function mergeRoi(options = {}) {
      const {
        algorithm = "commonBorderLength",
        minCommonBorderLength = 5,
        maxCommonBorderLength = 100,
        minCommonBorderRatio = 0.3,
        maxCommonBorderRatio = 1
      } = options;
      let checkFunction = function(currentInfo, currentID, neighbourID) {
        return currentInfo[neighbourID] >= minCommonBorderLength && currentInfo[neighbourID] <= maxCommonBorderLength;
      };
      if (typeof algorithm === "function") {
        checkFunction = algorithm;
      }
      if (algorithm.toLowerCase() === "commonborderratio") {
        checkFunction = function(currentInfo, currentID, neighbourID) {
          let ratio = Math.min(currentInfo[neighbourID] / currentInfo[currentID], 1);
          return ratio >= minCommonBorderRatio && ratio <= maxCommonBorderRatio;
        };
      }
      const roiMap = this;
      const borderLengths = roiMap.commonBorderLength;
      let newMap = {};
      let oldToNew = {};
      for (let currentID of Object.keys(borderLengths)) {
        let currentInfo = borderLengths[currentID];
        let neighbourIDs = Object.keys(currentInfo);
        for (let neighbourID of neighbourIDs) {
          if (neighbourID !== currentID) {
            if (checkFunction(currentInfo, currentID, neighbourID)) {
              let newNeighbourID = neighbourID;
              if (oldToNew[neighbourID])
                newNeighbourID = oldToNew[neighbourID];
              let newCurrentID = currentID;
              if (oldToNew[currentID])
                newCurrentID = oldToNew[currentID];
              if (Number(newNeighbourID) !== newCurrentID) {
                let smallerID = Math.min(newNeighbourID, newCurrentID);
                let largerID = Math.max(newNeighbourID, newCurrentID);
                if (!newMap[smallerID]) {
                  newMap[smallerID] = {};
                }
                newMap[smallerID][largerID] = true;
                oldToNew[largerID] = smallerID;
                if (newMap[largerID]) {
                  for (let id of Object.keys(newMap[largerID])) {
                    newMap[smallerID][id] = true;
                    oldToNew[id] = smallerID;
                  }
                  delete newMap[largerID];
                }
              }
            }
          }
        }
      }
      let minMax = roiMap.minMax;
      let shift = -minMax.min;
      let max = minMax.max + shift;
      let oldToNewArray = new Array(max + 1).fill(0);
      for (let key of Object.keys(oldToNew)) {
        oldToNewArray[Number(key) + shift] = oldToNew[key];
      }
      let data = roiMap.data;
      for (let i = 0; i < data.length; i++) {
        let currentValue = data[i];
        if (currentValue !== 0) {
          let newValue = oldToNewArray[currentValue + shift];
          if (newValue !== 0) {
            data[i] = newValue;
          }
        }
      }
      roiMap.computed = {};
      return roiMap;
    }
  }
});

// node_modules/image-js/lib/image/roi/RoiMap.js
var require_RoiMap = __commonJS({
  "node_modules/image-js/lib/image/roi/RoiMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _commonBorderLength = _interopRequireDefault(require_commonBorderLength());
    var _mergeRoi = _interopRequireDefault(require_mergeRoi());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var RoiMap = class {
      constructor(parent, data) {
        this.parent = parent;
        this.width = parent.width;
        this.height = parent.height;
        this.data = data;
        this.negative = 0;
        this.positive = 0;
      }
      get total() {
        return this.negative + this.positive;
      }
      get minMax() {
        let min = Number.MAX_SAFE_INTEGER;
        let max = Number.MIN_SAFE_INTEGER;
        for (let i = 0; i < this.data.length; i++) {
          if (this.data[i] < min)
            min = this.data[i];
          if (this.data[i] > max)
            max = this.data[i];
        }
        return {
          min,
          max
        };
      }
      get commonBorderLength() {
        return (0, _commonBorderLength.default)(this);
      }
      mergeRoi(options = {}) {
        return _mergeRoi.default.call(this, options);
      }
      mergeRois(rois) {
        const first = rois[0];
        const others = rois.slice(1);
        for (let i = 0; i < this.data.length; i++) {
          if (others.includes(this.data[i])) {
            this.data[i] = first;
          }
        }
      }
      rowsInfo() {
        let rowsInfo = new Array(this.height);
        let currentRow = 0;
        for (let i = 0; i < this.data.length; i += this.width) {
          let info = {
            row: currentRow,
            positivePixel: 0,
            negativePixel: 0,
            zeroPixel: 0,
            positiveRoi: 0,
            negativeRoi: 0,
            medianChange: 0
          };
          rowsInfo[currentRow++] = info;
          let positives = {};
          let negatives = {};
          let changes = [];
          let previous = this.data[i];
          let current = 0;
          for (let j = i; j < i + this.width; j++) {
            let value = this.data[j];
            if (previous !== value) {
              previous = value;
              changes.push(current);
              current = 0;
            }
            current++;
            if (value > 0) {
              info.positivePixel++;
              if (!positives[value]) {
                positives[value] = true;
              }
            } else if (value < 0) {
              info.negativePixel++;
              if (!negatives[value]) {
                negatives[value] = true;
              }
            } else {
              info.zeroPixel++;
            }
          }
          changes.push(current);
          info.medianChange = changes.sort((a, b) => a - b)[Math.floor(changes.length / 2)];
          info.positiveRoiIDs = Object.keys(positives);
          info.negativeRoiIDs = Object.keys(negatives);
          info.positiveRoi = info.positiveRoiIDs.length;
          info.negativeRoi = info.negativeRoiIDs.length;
        }
        return rowsInfo;
      }
      colsInfo() {
        let colsInfo = new Array(this.width);
        let currentCol = 0;
        for (let i = 0; i < this.width; i++) {
          let info = {
            col: currentCol,
            positivePixel: 0,
            negativePixel: 0,
            zeroPixel: 0,
            positiveRoi: 0,
            negativeRoi: 0,
            medianChange: 0
          };
          colsInfo[currentCol++] = info;
          let positives = {};
          let negatives = {};
          let changes = [];
          let previous = this.data[i];
          let current = 0;
          for (let j = i; j < i + this.data.length; j += this.width) {
            let value = this.data[j];
            if (previous !== value) {
              previous = value;
              changes.push(current);
              current = 0;
            }
            current++;
            if (value > 0) {
              info.positivePixel++;
              if (!positives[value]) {
                positives[value] = true;
              }
            } else if (value < 0) {
              info.negativePixel++;
              if (!negatives[value]) {
                negatives[value] = true;
              }
            } else {
              info.zeroPixel++;
            }
          }
          changes.push(current);
          info.medianChange = changes.sort((a, b) => a - b)[Math.floor(changes.length / 2)];
          info.positiveRoiIDs = Object.keys(positives);
          info.negativeRoiIDs = Object.keys(negatives);
          info.positiveRoi = info.positiveRoiIDs.length;
          info.negativeRoi = info.negativeRoiIDs.length;
        }
        return colsInfo;
      }
    };
    exports2.default = RoiMap;
  }
});

// node_modules/image-js/lib/image/roi/creator/fromMask.js
var require_fromMask = __commonJS({
  "node_modules/image-js/lib/image/roi/creator/fromMask.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = fromMask;
    var _RoiMap = _interopRequireDefault(require_RoiMap());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function fromMask(mask, options = {}) {
      const {
        allowCorners = false
      } = options;
      const MAX_ARRAY = 65535;
      let data = new Int16Array(mask.size);
      let positiveID = 0;
      let negativeID = 0;
      let xToProcess = new Uint16Array(MAX_ARRAY + 1);
      let yToProcess = new Uint16Array(MAX_ARRAY + 1);
      for (let x = 0; x < mask.width; x++) {
        for (let y = 0; y < mask.height; y++) {
          if (data[y * mask.width + x] === 0) {
            analyseSurface(x, y);
          }
        }
      }
      function analyseSurface(x, y) {
        let from = 0;
        let to = 0;
        let targetState = mask.getBitXY(x, y);
        let id = targetState ? ++positiveID : --negativeID;
        if (positiveID > 32767 || negativeID < -32768) {
          throw new Error("Too many regions of interest");
        }
        xToProcess[0] = x;
        yToProcess[0] = y;
        while (from <= to) {
          let currentX = xToProcess[from & MAX_ARRAY];
          let currentY = yToProcess[from & MAX_ARRAY];
          data[currentY * mask.width + currentX] = id;
          if (currentX > 0 && data[currentY * mask.width + currentX - 1] === 0 && mask.getBitXY(currentX - 1, currentY) === targetState) {
            to++;
            xToProcess[to & MAX_ARRAY] = currentX - 1;
            yToProcess[to & MAX_ARRAY] = currentY;
            data[currentY * mask.width + currentX - 1] = -32768;
          }
          if (currentY > 0 && data[(currentY - 1) * mask.width + currentX] === 0 && mask.getBitXY(currentX, currentY - 1) === targetState) {
            to++;
            xToProcess[to & MAX_ARRAY] = currentX;
            yToProcess[to & MAX_ARRAY] = currentY - 1;
            data[(currentY - 1) * mask.width + currentX] = -32768;
          }
          if (currentX < mask.width - 1 && data[currentY * mask.width + currentX + 1] === 0 && mask.getBitXY(currentX + 1, currentY) === targetState) {
            to++;
            xToProcess[to & MAX_ARRAY] = currentX + 1;
            yToProcess[to & MAX_ARRAY] = currentY;
            data[currentY * mask.width + currentX + 1] = -32768;
          }
          if (currentY < mask.height - 1 && data[(currentY + 1) * mask.width + currentX] === 0 && mask.getBitXY(currentX, currentY + 1) === targetState) {
            to++;
            xToProcess[to & MAX_ARRAY] = currentX;
            yToProcess[to & MAX_ARRAY] = currentY + 1;
            data[(currentY + 1) * mask.width + currentX] = -32768;
          }
          if (allowCorners) {
            if (currentX > 0 && currentY > 0 && data[(currentY - 1) * mask.width + currentX - 1] === 0 && mask.getBitXY(currentX - 1, currentY - 1) === targetState) {
              to++;
              xToProcess[to & MAX_ARRAY] = currentX - 1;
              yToProcess[to & MAX_ARRAY] = currentY - 1;
              data[(currentY - 1) * mask.width + currentX - 1] = -32768;
            }
            if (currentX < mask.width - 1 && currentY > 0 && data[(currentY - 1) * mask.width + currentX + 1] === 0 && mask.getBitXY(currentX + 1, currentY - 1) === targetState) {
              to++;
              xToProcess[to & MAX_ARRAY] = currentX + 1;
              yToProcess[to & MAX_ARRAY] = currentY - 1;
              data[(currentY - 1) * mask.width + currentX + 1] = -32768;
            }
            if (currentX > 0 && currentY < mask.height - 1 && data[(currentY + 1) * mask.width + currentX - 1] === 0 && mask.getBitXY(currentX - 1, currentY + 1) === targetState) {
              to++;
              xToProcess[to & MAX_ARRAY] = currentX - 1;
              yToProcess[to & MAX_ARRAY] = currentY + 1;
              data[(currentY + 1) * mask.width + currentX - 1] = -32768;
            }
            if (currentX < mask.width - 1 && currentY < mask.height - 1 && data[(currentY + 1) * mask.width + currentX + 1] === 0 && mask.getBitXY(currentX + 1, currentY + 1) === targetState) {
              to++;
              xToProcess[to & MAX_ARRAY] = currentX + 1;
              yToProcess[to & MAX_ARRAY] = currentY + 1;
              data[(currentY + 1) * mask.width + currentX + 1] = -32768;
            }
          }
          from++;
          if (to - from > MAX_ARRAY) {
            throw new Error("analyseMask can not finish, the array to manage internal data is not big enough.You could improve mask by changing MAX_ARRAY");
          }
        }
      }
      return new _RoiMap.default(mask, data);
    }
  }
});

// node_modules/ml-disjoint-set/src/DisjointSet.js
var require_DisjointSet = __commonJS({
  "node_modules/ml-disjoint-set/src/DisjointSet.js"(exports2, module2) {
    "use strict";
    var DisjointSet = class {
      constructor() {
        this.nodes = /* @__PURE__ */ new Map();
      }
      /**
       * Adds an element as a new set
       * @param {*} value
       * @return {DisjointSetNode} Object holding the element
       */
      add(value) {
        var node = this.nodes.get(value);
        if (!node) {
          node = new DisjointSetNode(value);
          this.nodes.set(value, node);
        }
        return node;
      }
      /**
       * Merges the sets that contain x and y
       * @param {DisjointSetNode} x
       * @param {DisjointSetNode} y
       */
      union(x, y) {
        const rootX = this.find(x);
        const rootY = this.find(y);
        if (rootX === rootY) {
          return;
        }
        if (rootX.rank < rootY.rank) {
          rootX.parent = rootY;
        } else if (rootX.rank > rootY.rank) {
          rootY.parent = rootX;
        } else {
          rootY.parent = rootX;
          rootX.rank++;
        }
      }
      /**
       * Finds and returns the root node of the set that contains node
       * @param {DisjointSetNode} node
       * @return {DisjointSetNode}
       */
      find(node) {
        var rootX = node;
        while (rootX.parent !== null) {
          rootX = rootX.parent;
        }
        var toUpdateX = node;
        while (toUpdateX.parent !== null) {
          var toUpdateParent = toUpdateX;
          toUpdateX = toUpdateX.parent;
          toUpdateParent.parent = rootX;
        }
        return rootX;
      }
      /**
       * Returns true if x and y belong to the same set
       * @param {DisjointSetNode} x
       * @param {DisjointSetNode} y
       */
      connected(x, y) {
        return this.find(x) === this.find(y);
      }
    };
    module2.exports = DisjointSet;
    function DisjointSetNode(value) {
      this.value = value;
      this.parent = null;
      this.rank = 0;
    }
  }
});

// node_modules/image-js/lib/image/roi/creator/fromMaskConnectedComponentLabelingAlgorithm.js
var require_fromMaskConnectedComponentLabelingAlgorithm = __commonJS({
  "node_modules/image-js/lib/image/roi/creator/fromMaskConnectedComponentLabelingAlgorithm.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = fromMaskConnectedComponentLabelingAlgorithm;
    var _mlDisjointSet = _interopRequireDefault(require_DisjointSet());
    var _RoiMap = _interopRequireDefault(require_RoiMap());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var direction4X = [-1, 0];
    var direction4Y = [0, -1];
    var neighbours4 = [null, null];
    var direction8X = [-1, -1, 0, 1];
    var direction8Y = [0, -1, -1, -1];
    var neighbours8 = [null, null, null, null];
    function fromMaskConnectedComponentLabelingAlgorithm(mask, options = {}) {
      const {
        allowCorners = false
      } = options;
      let neighbours = 4;
      if (allowCorners) {
        neighbours = 8;
      }
      let directionX;
      let directionY;
      let neighboursList;
      if (neighbours === 8) {
        directionX = direction8X;
        directionY = direction8Y;
        neighboursList = neighbours8;
      } else if (neighbours === 4) {
        directionX = direction4X;
        directionY = direction4Y;
        neighboursList = neighbours4;
      } else {
        throw new RangeError(`unsupported neighbours count: ${neighbours}`);
      }
      const size = mask.size;
      const width = mask.width;
      const height = mask.height;
      const labels = new Array(size);
      const data = new Uint32Array(size);
      const linked = new _mlDisjointSet.default();
      let currentLabel = 1;
      for (let j = 0; j < height; j++) {
        for (let i = 0; i < width; i++) {
          const index = i + j * width;
          if (mask.getBit(index)) {
            let smallestNeighbour = null;
            for (let k = 0; k < neighboursList.length; k++) {
              const ii = i + directionX[k];
              const jj = j + directionY[k];
              if (ii >= 0 && jj >= 0 && ii < width && jj < height) {
                const index2 = ii + jj * width;
                let neighbour = labels[index2];
                if (!neighbour) {
                  neighboursList[k] = null;
                } else {
                  neighboursList[k] = neighbour;
                  if (!smallestNeighbour || neighboursList[k].value < smallestNeighbour.value) {
                    smallestNeighbour = neighboursList[k];
                  }
                }
              }
            }
            if (!smallestNeighbour) {
              labels[index] = linked.add(currentLabel++);
            } else {
              labels[index] = smallestNeighbour;
              for (let k = 0; k < neighboursList.length; k++) {
                if (neighboursList[k] && neighboursList[k] !== smallestNeighbour) {
                  linked.union(smallestNeighbour, neighboursList[k]);
                }
              }
            }
          }
        }
      }
      for (let j = 0; j < height; j++) {
        for (let i = 0; i < width; i++) {
          const index = i + j * width;
          if (mask.getBit(index)) {
            data[index] = linked.find(labels[index]).value;
          }
        }
      }
      return new _RoiMap.default(mask, data);
    }
  }
});

// node_modules/image-js/lib/image/roi/creator/fromMaxima.js
var require_fromMaxima = __commonJS({
  "node_modules/image-js/lib/image/roi/creator/fromMaxima.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = fromMaxima;
    var _RoiMap = _interopRequireDefault(require_RoiMap());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function fromMaxima(options = {}) {
      let {
        allowCorner = true,
        onlyTop = false,
        invert = false
      } = options;
      let image = this;
      image.checkProcessable("fromMaxima", {
        components: [1]
      });
      const PROCESS_TOP = 1;
      const PROCESS_NORMAL = 2;
      let positiveID = 0;
      let negativeID = 0;
      let data = new Int16Array(image.size);
      let processed = new Int8Array(image.size);
      let variations = new Float32Array(image.size);
      let MAX_ARRAY = 1048575;
      let xToProcess = new Uint16Array(MAX_ARRAY + 1);
      let yToProcess = new Uint16Array(MAX_ARRAY + 1);
      let from = 0;
      let to = 0;
      let xToProcessTop = new Uint16Array(MAX_ARRAY + 1);
      let yToProcessTop = new Uint16Array(MAX_ARRAY + 1);
      let fromTop = 0;
      let toTop = 0;
      appendMaxima(image, {
        maxima: !invert
      });
      while (from < to) {
        let currentX = xToProcess[from & MAX_ARRAY];
        let currentY = yToProcess[from & MAX_ARRAY];
        process(currentX, currentY, PROCESS_NORMAL);
        from++;
      }
      return new _RoiMap.default(image, data);
      function appendMaxima({
        maxima = true
      }) {
        for (let y = 1; y < image.height - 1; y++) {
          for (let x = 1; x < image.width - 1; x++) {
            let index = x + y * image.width;
            if (processed[index] === 0) {
              let currentValue = maxima ? image.data[index] : -image.data[x + y * image.width];
              if (image.data[y * image.width + x - 1] > currentValue) {
                continue;
              }
              if (image.data[y * image.width + x + 1] > currentValue) {
                continue;
              }
              if (image.data[(y - 1) * image.width + x] > currentValue) {
                continue;
              }
              if (image.data[(y + 1) * image.width + x] > currentValue) {
                continue;
              }
              if (allowCorner) {
                if (image.data[(y - 1) * image.width + x - 1] > currentValue) {
                  continue;
                }
                if (image.data[(y - 1) * image.width + x + 1] > currentValue) {
                  continue;
                }
                if (image.data[(y + 1) * image.width + x - 1] > currentValue) {
                  continue;
                }
                if (image.data[(y + 1) * image.width + x + 1] > currentValue) {
                  continue;
                }
              }
              data[index] = maxima ? ++positiveID : --negativeID;
              let valid = processTop(x, y, PROCESS_TOP);
              if (!valid) {
                if (maxima) {
                  --positiveID;
                } else {
                  ++negativeID;
                }
              }
            }
          }
        }
      }
      function processTop(xToProcess2, yToProcess2) {
        let currentTo = to;
        fromTop = 0;
        toTop = 1;
        xToProcessTop[0] = xToProcess2;
        yToProcessTop[0] = yToProcess2;
        let valid = true;
        while (fromTop < toTop) {
          let currentX = xToProcessTop[fromTop & MAX_ARRAY];
          let currentY = yToProcessTop[fromTop & MAX_ARRAY];
          valid &= process(currentX, currentY, PROCESS_TOP);
          fromTop++;
        }
        if (!valid) {
          for (let i = 0; i < toTop; i++) {
            let currentX = xToProcessTop[i & MAX_ARRAY];
            let currentY = yToProcessTop[i & MAX_ARRAY];
            let index = currentY * image.width + currentX;
            data[index] = 0;
          }
          to = currentTo;
        }
        return valid;
      }
      function process(xCenter, yCenter, type) {
        let currentID = data[yCenter * image.width + xCenter];
        let currentValue = image.data[yCenter * image.width + xCenter];
        for (let y = yCenter - 1; y <= yCenter + 1; y++) {
          for (let x = xCenter - 1; x <= xCenter + 1; x++) {
            let index = y * image.width + x;
            if (processed[index] === 0) {
              processed[index] = 1;
              variations[index] = image.data[index] - currentValue;
              switch (type) {
                case PROCESS_TOP:
                  if (variations[index] === 0) {
                    if (x === 0 || y === 0 || x === image.width - 1 || y === image.height - 1) {
                      return false;
                    }
                    data[index] = currentID;
                    xToProcessTop[toTop & MAX_ARRAY] = x;
                    yToProcessTop[toTop & MAX_ARRAY] = y;
                    toTop++;
                  } else if (variations[index] > 0) {
                    return false;
                  } else {
                    if (!onlyTop) {
                      data[index] = currentID;
                      xToProcess[to & MAX_ARRAY] = x;
                      yToProcess[to & MAX_ARRAY] = y;
                      to++;
                    }
                  }
                  break;
                case PROCESS_NORMAL:
                  if (variations[index] <= 0) {
                    data[index] = currentID;
                    xToProcess[to & MAX_ARRAY] = x;
                    yToProcess[to & MAX_ARRAY] = y;
                    to++;
                  }
                  break;
                default:
                  throw new Error("unreachable");
              }
            }
          }
        }
        return true;
      }
    }
  }
});

// node_modules/image-js/lib/image/roi/creator/fromPoints.js
var require_fromPoints = __commonJS({
  "node_modules/image-js/lib/image/roi/creator/fromPoints.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = fromPoints;
    var _Shape = _interopRequireDefault(require_Shape());
    var _RoiMap = _interopRequireDefault(require_RoiMap());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function fromPoints(pointsToPaint, options = {}) {
      let shape = new _Shape.default(options);
      let data = new Int16Array(this.size);
      let positiveID = 0;
      let shapePoints = shape.getPoints();
      for (let i = 0; i < pointsToPaint.length; i++) {
        positiveID++;
        let xP = pointsToPaint[i][0];
        let yP = pointsToPaint[i][1];
        for (let j = 0; j < shapePoints.length; j++) {
          let xS = shapePoints[j][0];
          let yS = shapePoints[j][1];
          if (xP + xS >= 0 && yP + yS >= 0 && xP + xS < this.width && yP + yS < this.height) {
            data[xP + xS + (yP + yS) * this.width] = positiveID;
          }
        }
      }
      return new _RoiMap.default(this, data);
    }
  }
});

// node_modules/js-priority-queue/priority-queue.js
var require_priority_queue = __commonJS({
  "node_modules/js-priority-queue/priority-queue.js"(exports2, module2) {
    (function(f) {
      if (typeof exports2 === "object" && typeof module2 !== "undefined") {
        module2.exports = f();
      } else if (typeof define === "function" && define.amd) {
        define([], f);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.PriorityQueue = f();
      }
    })(function() {
      var define2, module3, exports3;
      return function e(t, n, r) {
        function s(o2, u) {
          if (!n[o2]) {
            if (!t[o2]) {
              var a = typeof require == "function" && require;
              if (!u && a)
                return a(o2, true);
              if (i)
                return i(o2, true);
              var f = new Error("Cannot find module '" + o2 + "'");
              throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o2] = { exports: {} };
            t[o2][0].call(l.exports, function(e2) {
              var n2 = t[o2][1][e2];
              return s(n2 ? n2 : e2);
            }, l, l.exports, e, t, n, r);
          }
          return n[o2].exports;
        }
        var i = typeof require == "function" && require;
        for (var o = 0; o < r.length; o++)
          s(r[o]);
        return s;
      }({ 1: [function(_dereq_, module4, exports4) {
        var AbstractPriorityQueue, ArrayStrategy, BHeapStrategy, BinaryHeapStrategy, PriorityQueue, extend = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key))
              child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        AbstractPriorityQueue = _dereq_("./PriorityQueue/AbstractPriorityQueue");
        ArrayStrategy = _dereq_("./PriorityQueue/ArrayStrategy");
        BinaryHeapStrategy = _dereq_("./PriorityQueue/BinaryHeapStrategy");
        BHeapStrategy = _dereq_("./PriorityQueue/BHeapStrategy");
        PriorityQueue = function(superClass) {
          extend(PriorityQueue2, superClass);
          function PriorityQueue2(options) {
            options || (options = {});
            options.strategy || (options.strategy = BinaryHeapStrategy);
            options.comparator || (options.comparator = function(a, b) {
              return (a || 0) - (b || 0);
            });
            PriorityQueue2.__super__.constructor.call(this, options);
          }
          return PriorityQueue2;
        }(AbstractPriorityQueue);
        PriorityQueue.ArrayStrategy = ArrayStrategy;
        PriorityQueue.BinaryHeapStrategy = BinaryHeapStrategy;
        PriorityQueue.BHeapStrategy = BHeapStrategy;
        module4.exports = PriorityQueue;
      }, { "./PriorityQueue/AbstractPriorityQueue": 2, "./PriorityQueue/ArrayStrategy": 3, "./PriorityQueue/BHeapStrategy": 4, "./PriorityQueue/BinaryHeapStrategy": 5 }], 2: [function(_dereq_, module4, exports4) {
        var AbstractPriorityQueue;
        module4.exports = AbstractPriorityQueue = function() {
          function AbstractPriorityQueue2(options) {
            var ref;
            if ((options != null ? options.strategy : void 0) == null) {
              throw "Must pass options.strategy, a strategy";
            }
            if ((options != null ? options.comparator : void 0) == null) {
              throw "Must pass options.comparator, a comparator";
            }
            this.priv = new options.strategy(options);
            this.length = (options != null ? (ref = options.initialValues) != null ? ref.length : void 0 : void 0) || 0;
          }
          AbstractPriorityQueue2.prototype.queue = function(value) {
            this.length++;
            this.priv.queue(value);
            return void 0;
          };
          AbstractPriorityQueue2.prototype.dequeue = function(value) {
            if (!this.length) {
              throw "Empty queue";
            }
            this.length--;
            return this.priv.dequeue();
          };
          AbstractPriorityQueue2.prototype.peek = function(value) {
            if (!this.length) {
              throw "Empty queue";
            }
            return this.priv.peek();
          };
          AbstractPriorityQueue2.prototype.clear = function() {
            this.length = 0;
            return this.priv.clear();
          };
          return AbstractPriorityQueue2;
        }();
      }, {}], 3: [function(_dereq_, module4, exports4) {
        var ArrayStrategy, binarySearchForIndexReversed;
        binarySearchForIndexReversed = function(array, value, comparator) {
          var high, low, mid;
          low = 0;
          high = array.length;
          while (low < high) {
            mid = low + high >>> 1;
            if (comparator(array[mid], value) >= 0) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return low;
        };
        module4.exports = ArrayStrategy = function() {
          function ArrayStrategy2(options) {
            var ref;
            this.options = options;
            this.comparator = this.options.comparator;
            this.data = ((ref = this.options.initialValues) != null ? ref.slice(0) : void 0) || [];
            this.data.sort(this.comparator).reverse();
          }
          ArrayStrategy2.prototype.queue = function(value) {
            var pos;
            pos = binarySearchForIndexReversed(this.data, value, this.comparator);
            this.data.splice(pos, 0, value);
            return void 0;
          };
          ArrayStrategy2.prototype.dequeue = function() {
            return this.data.pop();
          };
          ArrayStrategy2.prototype.peek = function() {
            return this.data[this.data.length - 1];
          };
          ArrayStrategy2.prototype.clear = function() {
            this.data.length = 0;
            return void 0;
          };
          return ArrayStrategy2;
        }();
      }, {}], 4: [function(_dereq_, module4, exports4) {
        var BHeapStrategy;
        module4.exports = BHeapStrategy = function() {
          function BHeapStrategy2(options) {
            var arr, i, j, k, len, ref, ref1, shift, value;
            this.comparator = (options != null ? options.comparator : void 0) || function(a, b) {
              return a - b;
            };
            this.pageSize = (options != null ? options.pageSize : void 0) || 512;
            this.length = 0;
            shift = 0;
            while (1 << shift < this.pageSize) {
              shift += 1;
            }
            if (1 << shift !== this.pageSize) {
              throw "pageSize must be a power of two";
            }
            this._shift = shift;
            this._emptyMemoryPageTemplate = arr = [];
            for (i = j = 0, ref = this.pageSize; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
              arr.push(null);
            }
            this._memory = [];
            this._mask = this.pageSize - 1;
            if (options.initialValues) {
              ref1 = options.initialValues;
              for (k = 0, len = ref1.length; k < len; k++) {
                value = ref1[k];
                this.queue(value);
              }
            }
          }
          BHeapStrategy2.prototype.queue = function(value) {
            this.length += 1;
            this._write(this.length, value);
            this._bubbleUp(this.length, value);
            return void 0;
          };
          BHeapStrategy2.prototype.dequeue = function() {
            var ret, val;
            ret = this._read(1);
            val = this._read(this.length);
            this.length -= 1;
            if (this.length > 0) {
              this._write(1, val);
              this._bubbleDown(1, val);
            }
            return ret;
          };
          BHeapStrategy2.prototype.peek = function() {
            return this._read(1);
          };
          BHeapStrategy2.prototype.clear = function() {
            this.length = 0;
            this._memory.length = 0;
            return void 0;
          };
          BHeapStrategy2.prototype._write = function(index, value) {
            var page;
            page = index >> this._shift;
            while (page >= this._memory.length) {
              this._memory.push(this._emptyMemoryPageTemplate.slice(0));
            }
            return this._memory[page][index & this._mask] = value;
          };
          BHeapStrategy2.prototype._read = function(index) {
            return this._memory[index >> this._shift][index & this._mask];
          };
          BHeapStrategy2.prototype._bubbleUp = function(index, value) {
            var compare, indexInPage, parentIndex, parentValue;
            compare = this.comparator;
            while (index > 1) {
              indexInPage = index & this._mask;
              if (index < this.pageSize || indexInPage > 3) {
                parentIndex = index & ~this._mask | indexInPage >> 1;
              } else if (indexInPage < 2) {
                parentIndex = index - this.pageSize >> this._shift;
                parentIndex += parentIndex & ~(this._mask >> 1);
                parentIndex |= this.pageSize >> 1;
              } else {
                parentIndex = index - 2;
              }
              parentValue = this._read(parentIndex);
              if (compare(parentValue, value) < 0) {
                break;
              }
              this._write(parentIndex, value);
              this._write(index, parentValue);
              index = parentIndex;
            }
            return void 0;
          };
          BHeapStrategy2.prototype._bubbleDown = function(index, value) {
            var childIndex1, childIndex2, childValue1, childValue2, compare;
            compare = this.comparator;
            while (index < this.length) {
              if (index > this._mask && !(index & this._mask - 1)) {
                childIndex1 = childIndex2 = index + 2;
              } else if (index & this.pageSize >> 1) {
                childIndex1 = (index & ~this._mask) >> 1;
                childIndex1 |= index & this._mask >> 1;
                childIndex1 = childIndex1 + 1 << this._shift;
                childIndex2 = childIndex1 + 1;
              } else {
                childIndex1 = index + (index & this._mask);
                childIndex2 = childIndex1 + 1;
              }
              if (childIndex1 !== childIndex2 && childIndex2 <= this.length) {
                childValue1 = this._read(childIndex1);
                childValue2 = this._read(childIndex2);
                if (compare(childValue1, value) < 0 && compare(childValue1, childValue2) <= 0) {
                  this._write(childIndex1, value);
                  this._write(index, childValue1);
                  index = childIndex1;
                } else if (compare(childValue2, value) < 0) {
                  this._write(childIndex2, value);
                  this._write(index, childValue2);
                  index = childIndex2;
                } else {
                  break;
                }
              } else if (childIndex1 <= this.length) {
                childValue1 = this._read(childIndex1);
                if (compare(childValue1, value) < 0) {
                  this._write(childIndex1, value);
                  this._write(index, childValue1);
                  index = childIndex1;
                } else {
                  break;
                }
              } else {
                break;
              }
            }
            return void 0;
          };
          return BHeapStrategy2;
        }();
      }, {}], 5: [function(_dereq_, module4, exports4) {
        var BinaryHeapStrategy;
        module4.exports = BinaryHeapStrategy = function() {
          function BinaryHeapStrategy2(options) {
            var ref;
            this.comparator = (options != null ? options.comparator : void 0) || function(a, b) {
              return a - b;
            };
            this.length = 0;
            this.data = ((ref = options.initialValues) != null ? ref.slice(0) : void 0) || [];
            this._heapify();
          }
          BinaryHeapStrategy2.prototype._heapify = function() {
            var i, j, ref;
            if (this.data.length > 0) {
              for (i = j = 1, ref = this.data.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
                this._bubbleUp(i);
              }
            }
            return void 0;
          };
          BinaryHeapStrategy2.prototype.queue = function(value) {
            this.data.push(value);
            this._bubbleUp(this.data.length - 1);
            return void 0;
          };
          BinaryHeapStrategy2.prototype.dequeue = function() {
            var last, ret;
            ret = this.data[0];
            last = this.data.pop();
            if (this.data.length > 0) {
              this.data[0] = last;
              this._bubbleDown(0);
            }
            return ret;
          };
          BinaryHeapStrategy2.prototype.peek = function() {
            return this.data[0];
          };
          BinaryHeapStrategy2.prototype.clear = function() {
            this.length = 0;
            this.data.length = 0;
            return void 0;
          };
          BinaryHeapStrategy2.prototype._bubbleUp = function(pos) {
            var parent, x;
            while (pos > 0) {
              parent = pos - 1 >>> 1;
              if (this.comparator(this.data[pos], this.data[parent]) < 0) {
                x = this.data[parent];
                this.data[parent] = this.data[pos];
                this.data[pos] = x;
                pos = parent;
              } else {
                break;
              }
            }
            return void 0;
          };
          BinaryHeapStrategy2.prototype._bubbleDown = function(pos) {
            var last, left, minIndex, right, x;
            last = this.data.length - 1;
            while (true) {
              left = (pos << 1) + 1;
              right = left + 1;
              minIndex = pos;
              if (left <= last && this.comparator(this.data[left], this.data[minIndex]) < 0) {
                minIndex = left;
              }
              if (right <= last && this.comparator(this.data[right], this.data[minIndex]) < 0) {
                minIndex = right;
              }
              if (minIndex !== pos) {
                x = this.data[minIndex];
                this.data[minIndex] = this.data[pos];
                this.data[pos] = x;
                pos = minIndex;
              } else {
                break;
              }
            }
            return void 0;
          };
          return BinaryHeapStrategy2;
        }();
      }, {}] }, {}, [1])(1);
    });
  }
});

// node_modules/image-js/lib/util/dxdy.js
var require_dxdy = __commonJS({
  "node_modules/image-js/lib/util/dxdy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.dys = exports2.dxs = void 0;
    var dxs = exports2.dxs = [1, 0, -1, 0, 1, 1, -1, -1];
    var dys = exports2.dys = [0, 1, 0, -1, 1, -1, 1, -1];
  }
});

// node_modules/image-js/lib/image/roi/creator/fromWaterShed.js
var require_fromWaterShed = __commonJS({
  "node_modules/image-js/lib/image/roi/creator/fromWaterShed.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = fromWaterShed;
    var _jsPriorityQueue = _interopRequireDefault(require_priority_queue());
    var _dxdy = require_dxdy();
    var _RoiMap = _interopRequireDefault(require_RoiMap());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function fromWaterShed(options = {}) {
      let {
        points,
        mask,
        image,
        fillMaxValue = this.maxValue,
        invert = false
      } = options;
      let currentImage = image || this;
      currentImage.checkProcessable("fromWaterShed", {
        bitDepth: [8, 16],
        components: 1
      });
      invert = !invert;
      if (!points) {
        points = currentImage.getLocalMaxima({
          invert,
          mask
        });
      }
      let maskExpectedValue = invert ? 0 : 1;
      let data = new Int16Array(currentImage.size);
      let width = currentImage.width;
      let height = currentImage.height;
      let toProcess = new _jsPriorityQueue.default({
        comparator: (a, b) => a[2] - b[2],
        strategy: _jsPriorityQueue.default.BinaryHeapStrategy
      });
      for (let i = 0; i < points.length; i++) {
        let index = points[i][0] + points[i][1] * width;
        data[index] = i + 1;
        let intensity = currentImage.data[index];
        if (invert && intensity <= fillMaxValue || !invert && intensity >= fillMaxValue) {
          toProcess.queue([points[i][0], points[i][1], intensity]);
        }
      }
      while (toProcess.length > 0) {
        let currentPoint = toProcess.dequeue();
        let currentValueIndex = currentPoint[0] + currentPoint[1] * width;
        for (let dir = 0; dir < 4; dir++) {
          let newX = currentPoint[0] + _dxdy.dxs[dir];
          let newY = currentPoint[1] + _dxdy.dys[dir];
          if (newX >= 0 && newY >= 0 && newX < width && newY < height) {
            let currentNeighbourIndex = newX + newY * width;
            if (!mask || mask.getBit(currentNeighbourIndex) === maskExpectedValue) {
              let intensity = currentImage.data[currentNeighbourIndex];
              if (invert && intensity <= fillMaxValue || !invert && intensity >= fillMaxValue) {
                if (data[currentNeighbourIndex] === 0) {
                  data[currentNeighbourIndex] = data[currentValueIndex];
                  toProcess.queue([currentPoint[0] + _dxdy.dxs[dir], currentPoint[1] + _dxdy.dys[dir], intensity]);
                }
              }
            }
          }
        }
      }
      return new _RoiMap.default(currentImage, data);
    }
  }
});

// node_modules/image-js/lib/image/roi/manager.js
var require_manager = __commonJS({
  "node_modules/image-js/lib/image/roi/manager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _jsQuantities = _interopRequireDefault(require_quantities());
    var _deepValue = _interopRequireDefault(require_deepValue());
    var _Image = _interopRequireDefault(require_Image());
    var _RoiLayer = _interopRequireDefault(require_RoiLayer());
    var _RoiMap = _interopRequireDefault(require_RoiMap());
    var _fromMask = _interopRequireDefault(require_fromMask());
    var _fromMaskConnectedComponentLabelingAlgorithm = _interopRequireDefault(require_fromMaskConnectedComponentLabelingAlgorithm());
    var _fromMaxima = _interopRequireDefault(require_fromMaxima());
    var _fromPoints = _interopRequireDefault(require_fromPoints());
    var _fromWaterShed = _interopRequireDefault(require_fromWaterShed());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var RoiManager = class {
      constructor(image, options = {}) {
        this._image = image;
        this._options = options;
        if (!this._options.label) {
          this._options.label = "default";
        }
        this._layers = {};
        this._painted = null;
      }
      // docs is in the corresponding file
      fromMaxima(options = {}) {
        let opt = Object.assign({}, this._options, options);
        let roiMap = _fromMaxima.default.call(this._image, options);
        this._layers[opt.label] = new _RoiLayer.default(roiMap, opt);
      }
      // docs is in the corresponding file
      fromPoints(points, options = {}) {
        let opt = Object.assign({}, this._options, options);
        let roiMap = _fromPoints.default.call(this._image, points, options);
        this._layers[opt.label] = new _RoiLayer.default(roiMap, opt);
        return this;
      }
      /**
       * @param {number[]} map
       * @param {object} [options]
       * @return {this}
       */
      putMap(map, options = {}) {
        let roiMap = new _RoiMap.default(this._image, map);
        let opt = Object.assign({}, this._options, options);
        this._layers[opt.label] = new _RoiLayer.default(roiMap, opt);
        return this;
      }
      // docs is in the corresponding file
      fromWaterShed(options = {}) {
        let opt = Object.assign({}, this._options, options);
        let roiMap = _fromWaterShed.default.call(this._image, options);
        this._layers[opt.label] = new _RoiLayer.default(roiMap, opt);
      }
      // docs is in the corresponding file
      fromMask(mask, options = {}) {
        let opt = Object.assign({}, this._options, options);
        let roiMap = _fromMask.default.call(this._image, mask, options);
        this._layers[opt.label] = new _RoiLayer.default(roiMap, opt);
        return this;
      }
      fromMaskConnectedComponentLabelingAlgorithm(mask, options = {}) {
        let opt = Object.assign({}, this._options, options);
        let roiMap = _fromMaskConnectedComponentLabelingAlgorithm.default.call(this._image, mask, options);
        this._layers[opt.label] = new _RoiLayer.default(roiMap, opt);
        return this;
      }
      /**
       *
       * @param {object} [options]
       * @return {RoiMap}
       */
      getMap(options = {}) {
        let opt = Object.assign({}, this._options, options);
        this._assertLayerWithLabel(opt.label);
        return this._layers[opt.label].roiMap;
      }
      /**
       * Return statistics about rows
       * @param {object} [options]
       * @return {object[]}
       */
      rowsInfo(options = {}) {
        return this.getMap(options).rowsInfo();
      }
      /**
       * Return statistics about columns
       * @param {object} [options]
       * @return {object[]}
       */
      colsInfo(options = {}) {
        return this.getMap(options).rowsInfo();
      }
      /**
       * Return the IDs of the Regions Of Interest (Roi) as an array of number
       * @param {object} [options]
       * @return {number[]}
       */
      getRoiIds(options = {}) {
        let rois = this.getRois(options);
        if (rois) {
          let ids = new Array(rois.length);
          for (let i = 0; i < rois.length; i++) {
            ids[i] = rois[i].id;
          }
          return ids;
        }
        throw new Error("ROIs not found");
      }
      /**
       * Allows to select ROI based on size, label and sign.
       * @param {object} [options={}]
       * @param {string} [options.label='default'] Label of the layer containing the ROI
       * @param {boolean} [options.positive=true] Select the positive region of interest
       * @param {boolean} [options.negative=true] Select he negative region of interest
       * @param {number} [options.minSurface=0]
       * @param {number} [options.maxSurface=Number.POSITIVE_INFINITY]
       * @param {number} [options.minWidth=0]
       * @param {number} [options.minHeight=Number.POSITIVE_INFINITY]
       * @param {number} [options.maxWidth=0]
       * @param {number} [options.maxHeight=Number.POSITIVE_INFINITY]
       * @param {number} [options.minRatio=0] Ratio width / height
       * @param {number} [options.maxRatio=Number.POSITIVE_INFINITY]
       * @return {Roi[]}
       */
      getRois(options = {}) {
        let {
          label = this._options.label,
          positive = true,
          negative = true,
          minSurface = 0,
          maxSurface = Number.POSITIVE_INFINITY,
          minWidth = 0,
          maxWidth = Number.POSITIVE_INFINITY,
          minHeight = 0,
          maxHeight = Number.POSITIVE_INFINITY,
          minRatio = 0,
          maxRatio = Number.POSITIVE_INFINITY
        } = options;
        if (!this._layers[label]) {
          throw new Error(`this Roi layer (${label}) does not exist`);
        }
        const allRois = this._layers[label].roi;
        const rois = [];
        for (const roi of allRois) {
          if ((roi.id < 0 && negative || roi.id > 0 && positive) && roi.surface >= minSurface && roi.surface <= maxSurface && roi.width >= minWidth && roi.width <= maxWidth && roi.height >= minHeight && roi.height <= maxHeight && roi.ratio >= minRatio && roi.ratio <= maxRatio) {
            rois.push(roi);
          }
        }
        return rois;
      }
      /**
       * Get an ROI by its id.
       * @param {number} roiId
       * @param {object} [options={}]
       * @param {string} [options.label='default'] Label of the layer containing the ROI
       * @return {Roi}
       */
      getRoi(roiId, options = {}) {
        const {
          label = this._options.label
        } = options;
        if (!this._layers[label]) {
          throw new Error(`this Roi layer (${label}) does not exist`);
        }
        const roi = this._layers[label].roi.find((roi2) => roi2.id === roiId);
        if (!roi) {
          throw new Error(`found no Roi with id ${roiId}`);
        }
        return roi;
      }
      /**
       * Returns an array of masks
       * See {@link Roi.getMask} for the options
       * @param {object} [options]
       * @return {Image[]} Retuns an array of masks (1 bit Image)
       */
      getMasks(options = {}) {
        let rois = this.getRois(options);
        let masks = new Array(rois.length);
        for (let i = 0; i < rois.length; i++) {
          masks[i] = rois[i].getMask(options);
        }
        return masks;
      }
      /**
       * Returns an array of masks
       * See {@link Roi.getAnalysisMasks} for the options
       * @param {object} [options]
       * @return {Image[]} Retuns an array of masks (1 bit Image)
       */
      getAnalysisMasks(options = {}) {
        const {
          analysisProperty
        } = options;
        let maskProperty = `${analysisProperty}Mask`;
        let rois = this.getRois(options);
        if (rois.length === 0 || !rois[0][maskProperty])
          return [];
        return rois.map((roi) => roi[maskProperty]);
      }
      /**
       *
       * @param {object} [options]
       * @return {number[]}
       */
      getData(options = {}) {
        let opt = Object.assign({}, this._options, options);
        this._assertLayerWithLabel(opt.label);
        return this._layers[opt.label].roiMap.data;
      }
      /**
       * Paint the ROI on a copy of the image and return this image.
       * For painting options {@link Image.paintMasks}
       * For ROI selection options, see {@link RoiManager.getMasks}
       * @param {object} [options] - all the options to select ROIs
       * @param {string} [options.labelProperty] - Paint a mask property on the image.
       *                                  May be any property of the ROI like
       *                                  for example id, surface, width, height, meanX, meanY.
       * @param {number} [options.pixelSize] Size of a pixel in SI
       * @param {string} [options.unit="pixel"] Unit in which to display the values
       * @return {Image} - The painted RGBA 8 bits image
       */
      paint(options = {}) {
        let {
          labelProperty,
          analysisProperty
        } = options;
        if (!this._painted) {
          this._painted = this._image.rgba8();
        }
        let masks = this.getMasks(options);
        if (labelProperty) {
          const rois = this.getRois(options);
          options.labels = rois.map((roi) => (0, _deepValue.default)(roi, labelProperty));
          const max = Math.max(...options.labels);
          let isSurface = false;
          let isDistance = false;
          if (labelProperty.includes("surface")) {
            isSurface = true;
          } else if (/(?:perimeter|min|max|external|width|height|length)/.test(labelProperty)) {
            isDistance = true;
          }
          if (isFinite(max)) {
            let unitLabel = "";
            if (options.unit !== "pixel" && options.pixelSize && (isDistance || isSurface)) {
              unitLabel = isSurface ? `${options.unit}^2` : options.unit;
              let siLabel = isSurface ? "m^2" : "m";
              let factor = isSurface ? options.pixelSize ** 2 : options.pixelSize;
              const convert = _jsQuantities.default.swiftConverter(siLabel, unitLabel);
              options.labels = options.labels.map((value) => {
                return convert(factor * value);
              });
            }
            if (max > 50) {
              options.labels = options.labels.map((number) => Math.round(number) + unitLabel);
            } else if (max > 10) {
              options.labels = options.labels.map((number) => number.toFixed(1) + unitLabel);
            } else {
              options.labels = options.labels.map((number) => number.toFixed(2) + unitLabel);
            }
          }
          options.labelsPosition = rois.map((roi) => [roi.meanX, roi.meanY]);
        }
        this._painted.paintMasks(masks, options);
        if (analysisProperty) {
          let analysisMasks = this.getAnalysisMasks(options);
          this._painted.paintMasks(analysisMasks, {
            color: options.analysisColor,
            alpha: options.analysisAlpha
          });
        }
        return this._painted;
      }
      // return a mask corresponding to all the selected masks
      getMask(options = {}) {
        let mask = new _Image.default(this._image.width, this._image.height, {
          kind: "BINARY"
        });
        let masks = this.getMasks(options);
        for (let i = 0; i < masks.length; i++) {
          let roi = masks[i];
          for (let x = 0; x < roi.width; x++) {
            for (let y = 0; y < roi.height; y++) {
              if (roi.getBitXY(x, y)) {
                mask.setBitXY(x + roi.position[0], y + roi.position[1]);
              }
            }
          }
        }
        return mask;
      }
      /**
       * Reset the changes to the current painted iamge to the image that was
       * used during the creation of the RoiManager except if a new image is
       * specified as parameter;
       * @param {object} [options]
       * @param {Image} [options.image] A new iamge that you would like to sue for painting over
       */
      resetPainted(options = {}) {
        const {
          image
        } = options;
        if (image) {
          this._painted = this.image.rgba8();
        } else {
          this._painted = this._image.rgba8();
        }
      }
      /**
       * In place modification of the roiMap that joins regions of interest
       * @param {object} [options]
       * @param {string|function(object,number,number)} [options.algorithm='commonBorderLength'] algorithm used to decide which ROIs are merged.
       *      Current implemented algorithms are 'commonBorderLength' that use the parameters
       *      'minCommonBorderLength' and 'maxCommonBorderLength' as well as 'commonBorderRatio' that uses
       *      the parameters 'minCommonBorderRatio' and 'maxCommonBorderRatio'.
       * @param {number} [options.minCommonBorderLength=5] minimal common number of pixels for merging
       * @param {number} [options.maxCommonBorderLength=100] maximal common number of pixels for merging
       * @param {number} [options.minCommonBorderRatio=0.3] minimal common border ratio for merging
       * @param {number} [options.maxCommonBorderRatio=1] maximal common border ratio for merging
       * @return {this}
       */
      mergeRoi(options = {}) {
        const roiMap = this.getMap(options);
        roiMap.mergeRoi(options);
        this.putMap(roiMap.data, options);
        return this;
      }
      /**
       * Merge multiple rois into one.
       * All rois in the provided array will be merged into the first one.
       * @param {Array<number>} roiIds - A list of Roi ids to merge
       * @param {object} [options]
       */
      mergeRois(roiIds, options = {}) {
        if (!Array.isArray(roiIds) || roiIds.some((id) => !Number.isInteger(id))) {
          throw new Error("Roi ids must be an array of integers");
        }
        if (roiIds.length < 2) {
          throw new Error("Roi ids must have at least two elements");
        }
        if (new Set(roiIds).size !== roiIds.length) {
          throw new Error("Roi ids must be all different");
        }
        roiIds.forEach((roiId) => this.getRoi(roiId));
        const roiMap = this.getMap(options);
        roiMap.mergeRois(roiIds);
        this.putMap(roiMap.data, options);
        return this;
      }
      /**
       * Finds all corresponding ROIs for all ROIs in the manager
       * @param {number[]} roiMap
       * @param {object} [options]
       * @return {Array} array of objects returned in correspondingRoisInformation
       */
      findCorrespondingRoi(roiMap, options = {}) {
        let allRois = this.getRois(options);
        let allRelated = [];
        for (let i = 0; i < allRois.length; i++) {
          let currentRoi = allRois[i];
          let x = currentRoi.minX;
          let y = currentRoi.minY;
          let allPoints = currentRoi.points;
          let roiSign = Math.sign(currentRoi.id);
          let currentRelated = correspondingRoisInformation(x, y, allPoints, roiMap, roiSign);
          allRelated.push(currentRelated);
        }
        return allRelated;
      }
      _assertLayerWithLabel(label) {
        if (!this._layers[label]) {
          throw new Error(`no layer with label ${label}`);
        }
      }
    };
    exports2.default = RoiManager;
    function correspondingRoisInformation(x, y, points, roiMap, roiSign) {
      let correspondingRois = {
        id: [],
        surface: [],
        roiSurfaceCovered: [],
        same: 0,
        opposite: 0,
        total: 0
      };
      for (let i = 0; i < points.length; i++) {
        let currentPoint = points[i];
        let currentX = currentPoint[0];
        let currentY = currentPoint[1];
        let correspondingRoiMapIndex = currentX + x + (currentY + y) * roiMap.width;
        let value = roiMap.data[correspondingRoiMapIndex];
        if (value > 0 || value < 0) {
          if (correspondingRois.id.includes(value)) {
            correspondingRois.surface[correspondingRois.id.indexOf(value)] += 1;
          } else {
            correspondingRois.id.push(value);
            correspondingRois.surface.push(1);
          }
        }
      }
      for (let i = 0; i < correspondingRois.id.length; i++) {
        let currentSign = Math.sign(correspondingRois.id[i]);
        if (currentSign === roiSign) {
          correspondingRois.same += correspondingRois.surface[i];
        } else {
          correspondingRois.opposite += correspondingRois.surface[i];
        }
        correspondingRois.roiSurfaceCovered[i] = correspondingRois.surface[i] / points.length;
      }
      correspondingRois.total = correspondingRois.opposite + correspondingRois.same;
      return correspondingRois;
    }
  }
});

// node_modules/image-js/lib/image/Image.js
var require_Image = __commonJS({
  "node_modules/image-js/lib/image/Image.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _bitMethods = _interopRequireDefault(require_bitMethods());
    var _checkProcessable = _interopRequireDefault(require_checkProcessable());
    var _export = _interopRequireDefault(require_export());
    var _extend = require_extend();
    var _getRGBAData = _interopRequireDefault(require_getRGBAData());
    var _kind = require_kind();
    var _kindNames = require_kindNames();
    var _load = _interopRequireDefault(require_load());
    var _valueMethods = _interopRequireDefault(require_valueMethods());
    var _extend2 = _interopRequireDefault(require_extend3());
    var _getImageParameters = _interopRequireDefault(require_getImageParameters());
    var _manager = _interopRequireDefault(require_manager());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var objectToString = Object.prototype.toString;
    var Image2 = class {
      constructor(width, height, data, options) {
        if (arguments.length === 1) {
          options = width;
          ({
            width,
            height,
            data
          } = options);
        } else if (data && !data.length) {
          options = data;
          ({
            data
          } = options);
        }
        if (width === void 0)
          width = 1;
        if (height === void 0)
          height = 1;
        if (options === void 0)
          options = {};
        if (typeof options !== "object" || options === null) {
          throw new TypeError("options must be an object");
        }
        if (!Number.isInteger(width) || width <= 0) {
          throw new RangeError("width must be a positive integer");
        }
        if (!Number.isInteger(height) || height <= 0) {
          throw new RangeError("height must be a positive integer");
        }
        const {
          kind = _kindNames.RGBA
        } = options;
        if (typeof kind !== "string") {
          throw new TypeError("kind must be a string");
        }
        const theKind = (0, _kind.getKind)(kind);
        const kindDefinition = Object.assign({}, options);
        for (const prop in theKind) {
          if (kindDefinition[prop] === void 0) {
            kindDefinition[prop] = theKind[prop];
          }
        }
        (0, _kind.verifyKindDefinition)(kindDefinition);
        const {
          components,
          bitDepth,
          colorModel
        } = kindDefinition;
        const alpha = kindDefinition.alpha + 0;
        const size = width * height;
        const channels = components + alpha;
        const maxValue = bitDepth === 32 ? Number.MAX_VALUE : 2 ** bitDepth - 1;
        if (data === void 0) {
          data = (0, _kind.createPixelArray)(size, components, alpha, channels, bitDepth, maxValue);
        } else {
          const expectedLength = (0, _kind.getTheoreticalPixelArraySize)(size, channels, bitDepth);
          if (data.length !== expectedLength) {
            throw new RangeError(`incorrect data size: ${data.length}. Should be ${expectedLength}`);
          }
        }
        this.width = width;
        this.height = height;
        this.data = data;
        this.size = size;
        this.components = components;
        this.alpha = alpha;
        this.bitDepth = bitDepth;
        this.maxValue = maxValue;
        this.colorModel = colorModel;
        this.channels = channels;
        this.meta = options.meta || {};
        Object.defineProperty(this, "parent", {
          enumerable: false,
          writable: true,
          configurable: true,
          value: options.parent || null
        });
        this.position = options.position || [0, 0];
        this.computed = null;
        this.sizes = [this.width, this.height];
        this.multiplierX = this.channels;
        this.multiplierY = this.channels * this.width;
        this.isClamped = this.bitDepth < 32;
        this.borderSizes = [0, 0];
      }
      get [Symbol.toStringTag]() {
        return "IJSImage";
      }
      static isImage(object) {
        return objectToString.call(object) === "[object IJSImage]";
      }
      /**
       * Creates an image from an HTML Canvas object
       * @param {Canvas} canvas
       * @return {Image}
       */
      static fromCanvas(canvas) {
        const ctx = canvas.getContext("2d");
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        return new Image2(imageData.width, imageData.height, imageData.data);
      }
      /**
       * Create a new Image based on the characteristics of another one.
       * @param {Image} other
       * @param {object} [options] - Override options to change some parameters
       * @return {Image}
       * @example
       * const newImage = Image.createFrom(image, { width: 100 });
       */
      static createFrom(other, options) {
        const newOptions = (0, _getImageParameters.default)(other);
        Object.assign(newOptions, {
          parent: other,
          position: [0, 0]
        }, options);
        return new Image2(newOptions);
      }
      /**
       * Create a new manager for regions of interest based on the current image.
       * @param {object} [options]
       * @return {RoiManager}
       */
      getRoiManager(options) {
        return new _manager.default(this, options);
      }
      /**
       * Create a copy a the current image, including its data.
       * @instance
       * @return {Image}
       */
      clone() {
        const newData = this.data.slice();
        return new Image2(this.width, this.height, newData, this);
      }
      apply(filter) {
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            let index = (y * this.width + x) * this.channels;
            filter.call(this, index);
          }
        }
      }
    };
    exports2.default = Image2;
    (0, _valueMethods.default)(Image2);
    (0, _bitMethods.default)(Image2);
    (0, _export.default)(Image2);
    Image2.prototype.checkProcessable = _checkProcessable.default;
    Image2.prototype.getRGBAData = _getRGBAData.default;
    Image2.load = _load.default;
    Image2.extendMethod = _extend.extendMethod;
    Image2.extendProperty = _extend.extendProperty;
    (0, _extend2.default)(Image2);
  }
});

// node_modules/image-js/lib/kernel/laplacianOfGaussian.js
var require_laplacianOfGaussian = __commonJS({
  "node_modules/image-js/lib/kernel/laplacianOfGaussian.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.laplacianOfGaussian = laplacianOfGaussian;
    function laplacianOfGaussian(sigma, nPoints, factor) {
      let kernel = new Array(nPoints);
      let i, j, x2, y2;
      if (!factor) {
        factor = 100;
      }
      factor *= -1;
      let center = (nPoints - 1) / 2;
      let sigma2 = 2 * sigma * sigma;
      for (i = 0; i < nPoints; i++) {
        kernel[i] = new Array(nPoints);
        y2 = (i - center) * (i - center);
        for (j = 0; j < nPoints; j++) {
          x2 = (j - center) * (j - center);
          kernel[i][j] = Math.round(factor * (1 - (x2 + y2) / sigma2) * Math.exp(-(x2 + y2) / sigma2));
        }
      }
      return kernel;
    }
  }
});

// node_modules/image-js/lib/kernel/kernel.js
var require_kernel3 = __commonJS({
  "node_modules/image-js/lib/kernel/kernel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _exportNames = {
      laplacianOfGaussian: true
    };
    Object.defineProperty(exports2, "laplacianOfGaussian", {
      enumerable: true,
      get: function() {
        return _laplacianOfGaussian.laplacianOfGaussian;
      }
    });
    var _kernels = require_kernels();
    Object.keys(_kernels).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      if (key in exports2 && exports2[key] === _kernels[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _kernels[key];
        }
      });
    });
    var _laplacianOfGaussian = require_laplacianOfGaussian();
  }
});

// node_modules/image-js/lib/worker/worker.js
var require_worker = __commonJS({
  "node_modules/image-js/lib/worker/worker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = exports2.default = void 0;
  }
});

// node_modules/image-js/lib/index.js
var require_lib20 = __commonJS({
  "node_modules/image-js/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "Image", {
      enumerable: true,
      get: function() {
        return _Image.default;
      }
    });
    exports2.Kernel = void 0;
    Object.defineProperty(exports2, "Shape", {
      enumerable: true,
      get: function() {
        return _Shape.default;
      }
    });
    Object.defineProperty(exports2, "Stack", {
      enumerable: true,
      get: function() {
        return _Stack.default;
      }
    });
    exports2.Static = void 0;
    Object.defineProperty(exports2, "Worker", {
      enumerable: true,
      get: function() {
        return _worker.default;
      }
    });
    Object.defineProperty(exports2, "default", {
      enumerable: true,
      get: function() {
        return _Image.default;
      }
    });
    var _Image = _interopRequireDefault(require_Image());
    var _greyAlgorithms = require_greyAlgorithms();
    var _thresholdAlgorithms = require_thresholdAlgorithms();
    var Kernel = _interopRequireWildcard(require_kernel3());
    exports2.Kernel = Kernel;
    var _Stack = _interopRequireDefault(require_Stack());
    var _Shape = _interopRequireDefault(require_Shape());
    var _worker = _interopRequireDefault(require_worker());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != typeof e && "function" != typeof e)
        return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n.default = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Static = exports2.Static = {
      grey: _greyAlgorithms.names,
      threshold: _thresholdAlgorithms.names
    };
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "node_modules/is-arrayish/index.js"(exports2, module2) {
    module2.exports = function isArrayish(obj) {
      if (!obj || typeof obj === "string") {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
    };
  }
});

// node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS({
  "node_modules/simple-swizzle/index.js"(exports2, module2) {
    "use strict";
    var isArrayish = require_is_arrayish();
    var concat = Array.prototype.concat;
    var slice = Array.prototype.slice;
    var swizzle = module2.exports = function swizzle2(args) {
      var results = [];
      for (var i = 0, len = args.length; i < len; i++) {
        var arg = args[i];
        if (isArrayish(arg)) {
          results = concat.call(results, slice.call(arg));
        } else {
          results.push(arg);
        }
      }
      return results;
    };
    swizzle.wrap = function(fn) {
      return function() {
        return fn(swizzle(arguments));
      };
    };
  }
});

// node_modules/color-string/index.js
var require_color_string = __commonJS({
  "node_modules/color-string/index.js"(exports2, module2) {
    var colorNames = require_color_name();
    var swizzle = require_simple_swizzle();
    var hasOwnProperty = Object.hasOwnProperty;
    var reverseNames = /* @__PURE__ */ Object.create(null);
    for (name in colorNames) {
      if (hasOwnProperty.call(colorNames, name)) {
        reverseNames[colorNames[name]] = name;
      }
    }
    var name;
    var cs = module2.exports = {
      to: {},
      get: {}
    };
    cs.get = function(string) {
      var prefix = string.substring(0, 3).toLowerCase();
      var val;
      var model;
      switch (prefix) {
        case "hsl":
          val = cs.get.hsl(string);
          model = "hsl";
          break;
        case "hwb":
          val = cs.get.hwb(string);
          model = "hwb";
          break;
        default:
          val = cs.get.rgb(string);
          model = "rgb";
          break;
      }
      if (!val) {
        return null;
      }
      return { model, value: val };
    };
    cs.get.rgb = function(string) {
      if (!string) {
        return null;
      }
      var abbr = /^#([a-f0-9]{3,4})$/i;
      var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
      var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var keyword = /^(\w+)$/;
      var rgb = [0, 0, 0, 1];
      var match;
      var i;
      var hexAlpha;
      if (match = string.match(hex)) {
        hexAlpha = match[2];
        match = match[1];
        for (i = 0; i < 3; i++) {
          var i2 = i * 2;
          rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha, 16) / 255;
        }
      } else if (match = string.match(abbr)) {
        match = match[1];
        hexAlpha = match[3];
        for (i = 0; i < 3; i++) {
          rgb[i] = parseInt(match[i] + match[i], 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match = string.match(rgba)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = parseInt(match[i + 1], 0);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(per)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(keyword)) {
        if (match[1] === "transparent") {
          return [0, 0, 0, 0];
        }
        if (!hasOwnProperty.call(colorNames, match[1])) {
          return null;
        }
        rgb = colorNames[match[1]];
        rgb[3] = 1;
        return rgb;
      } else {
        return null;
      }
      for (i = 0; i < 3; i++) {
        rgb[i] = clamp(rgb[i], 0, 255);
      }
      rgb[3] = clamp(rgb[3], 0, 1);
      return rgb;
    };
    cs.get.hsl = function(string) {
      if (!string) {
        return null;
      }
      var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hsl);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = (parseFloat(match[1]) % 360 + 360) % 360;
        var s = clamp(parseFloat(match[2]), 0, 100);
        var l = clamp(parseFloat(match[3]), 0, 100);
        var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, s, l, a];
      }
      return null;
    };
    cs.get.hwb = function(string) {
      if (!string) {
        return null;
      }
      var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hwb);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = (parseFloat(match[1]) % 360 + 360) % 360;
        var w = clamp(parseFloat(match[2]), 0, 100);
        var b = clamp(parseFloat(match[3]), 0, 100);
        var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, w, b, a];
      }
      return null;
    };
    cs.to.hex = function() {
      var rgba = swizzle(arguments);
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
    };
    cs.to.rgb = function() {
      var rgba = swizzle(arguments);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
    };
    cs.to.rgb.percent = function() {
      var rgba = swizzle(arguments);
      var r = Math.round(rgba[0] / 255 * 100);
      var g = Math.round(rgba[1] / 255 * 100);
      var b = Math.round(rgba[2] / 255 * 100);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
    };
    cs.to.hsl = function() {
      var hsla = swizzle(arguments);
      return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
    };
    cs.to.hwb = function() {
      var hwba = swizzle(arguments);
      var a = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a + ")";
    };
    cs.to.keyword = function(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    };
    function clamp(num, min, max) {
      return Math.min(Math.max(min, num), max);
    }
    function hexDouble(num) {
      var str = Math.round(num).toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    }
  }
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module2.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/color/index.js
var require_color2 = __commonJS({
  "node_modules/color/index.js"(exports2, module2) {
    var colorString = require_color_string();
    var convert = require_color_convert();
    var skippedModels = [
      // To be honest, I don't really feel like keyword belongs in color convert, but eh.
      "keyword",
      // Gray conflicts with some method names, and has its own method defined.
      "gray",
      // Shouldn't really be in color-convert either...
      "hex"
    ];
    var hashedModelKeys = {};
    for (const model of Object.keys(convert)) {
      hashedModelKeys[[...convert[model].labels].sort().join("")] = model;
    }
    var limiters = {};
    function Color(object, model) {
      if (!(this instanceof Color)) {
        return new Color(object, model);
      }
      if (model && model in skippedModels) {
        model = null;
      }
      if (model && !(model in convert)) {
        throw new Error("Unknown model: " + model);
      }
      let i;
      let channels;
      if (object == null) {
        this.model = "rgb";
        this.color = [0, 0, 0];
        this.valpha = 1;
      } else if (object instanceof Color) {
        this.model = object.model;
        this.color = [...object.color];
        this.valpha = object.valpha;
      } else if (typeof object === "string") {
        const result = colorString.get(object);
        if (result === null) {
          throw new Error("Unable to parse color from string: " + object);
        }
        this.model = result.model;
        channels = convert[this.model].channels;
        this.color = result.value.slice(0, channels);
        this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
      } else if (object.length > 0) {
        this.model = model || "rgb";
        channels = convert[this.model].channels;
        const newArray = Array.prototype.slice.call(object, 0, channels);
        this.color = zeroArray(newArray, channels);
        this.valpha = typeof object[channels] === "number" ? object[channels] : 1;
      } else if (typeof object === "number") {
        this.model = "rgb";
        this.color = [
          object >> 16 & 255,
          object >> 8 & 255,
          object & 255
        ];
        this.valpha = 1;
      } else {
        this.valpha = 1;
        const keys = Object.keys(object);
        if ("alpha" in object) {
          keys.splice(keys.indexOf("alpha"), 1);
          this.valpha = typeof object.alpha === "number" ? object.alpha : 0;
        }
        const hashedKeys = keys.sort().join("");
        if (!(hashedKeys in hashedModelKeys)) {
          throw new Error("Unable to parse color from object: " + JSON.stringify(object));
        }
        this.model = hashedModelKeys[hashedKeys];
        const { labels } = convert[this.model];
        const color = [];
        for (i = 0; i < labels.length; i++) {
          color.push(object[labels[i]]);
        }
        this.color = zeroArray(color);
      }
      if (limiters[this.model]) {
        channels = convert[this.model].channels;
        for (i = 0; i < channels; i++) {
          const limit = limiters[this.model][i];
          if (limit) {
            this.color[i] = limit(this.color[i]);
          }
        }
      }
      this.valpha = Math.max(0, Math.min(1, this.valpha));
      if (Object.freeze) {
        Object.freeze(this);
      }
    }
    Color.prototype = {
      toString() {
        return this.string();
      },
      toJSON() {
        return this[this.model]();
      },
      string(places) {
        let self2 = this.model in colorString.to ? this : this.rgb();
        self2 = self2.round(typeof places === "number" ? places : 1);
        const args = self2.valpha === 1 ? self2.color : [...self2.color, this.valpha];
        return colorString.to[self2.model](args);
      },
      percentString(places) {
        const self2 = this.rgb().round(typeof places === "number" ? places : 1);
        const args = self2.valpha === 1 ? self2.color : [...self2.color, this.valpha];
        return colorString.to.rgb.percent(args);
      },
      array() {
        return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];
      },
      object() {
        const result = {};
        const { channels } = convert[this.model];
        const { labels } = convert[this.model];
        for (let i = 0; i < channels; i++) {
          result[labels[i]] = this.color[i];
        }
        if (this.valpha !== 1) {
          result.alpha = this.valpha;
        }
        return result;
      },
      unitArray() {
        const rgb = this.rgb().color;
        rgb[0] /= 255;
        rgb[1] /= 255;
        rgb[2] /= 255;
        if (this.valpha !== 1) {
          rgb.push(this.valpha);
        }
        return rgb;
      },
      unitObject() {
        const rgb = this.rgb().object();
        rgb.r /= 255;
        rgb.g /= 255;
        rgb.b /= 255;
        if (this.valpha !== 1) {
          rgb.alpha = this.valpha;
        }
        return rgb;
      },
      round(places) {
        places = Math.max(places || 0, 0);
        return new Color([...this.color.map(roundToPlace(places)), this.valpha], this.model);
      },
      alpha(value) {
        if (value !== void 0) {
          return new Color([...this.color, Math.max(0, Math.min(1, value))], this.model);
        }
        return this.valpha;
      },
      // Rgb
      red: getset("rgb", 0, maxfn(255)),
      green: getset("rgb", 1, maxfn(255)),
      blue: getset("rgb", 2, maxfn(255)),
      hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, (value) => (value % 360 + 360) % 360),
      saturationl: getset("hsl", 1, maxfn(100)),
      lightness: getset("hsl", 2, maxfn(100)),
      saturationv: getset("hsv", 1, maxfn(100)),
      value: getset("hsv", 2, maxfn(100)),
      chroma: getset("hcg", 1, maxfn(100)),
      gray: getset("hcg", 2, maxfn(100)),
      white: getset("hwb", 1, maxfn(100)),
      wblack: getset("hwb", 2, maxfn(100)),
      cyan: getset("cmyk", 0, maxfn(100)),
      magenta: getset("cmyk", 1, maxfn(100)),
      yellow: getset("cmyk", 2, maxfn(100)),
      black: getset("cmyk", 3, maxfn(100)),
      x: getset("xyz", 0, maxfn(95.047)),
      y: getset("xyz", 1, maxfn(100)),
      z: getset("xyz", 2, maxfn(108.833)),
      l: getset("lab", 0, maxfn(100)),
      a: getset("lab", 1),
      b: getset("lab", 2),
      keyword(value) {
        if (value !== void 0) {
          return new Color(value);
        }
        return convert[this.model].keyword(this.color);
      },
      hex(value) {
        if (value !== void 0) {
          return new Color(value);
        }
        return colorString.to.hex(this.rgb().round().color);
      },
      hexa(value) {
        if (value !== void 0) {
          return new Color(value);
        }
        const rgbArray = this.rgb().round().color;
        let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();
        if (alphaHex.length === 1) {
          alphaHex = "0" + alphaHex;
        }
        return colorString.to.hex(rgbArray) + alphaHex;
      },
      rgbNumber() {
        const rgb = this.rgb().color;
        return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
      },
      luminosity() {
        const rgb = this.rgb().color;
        const lum = [];
        for (const [i, element] of rgb.entries()) {
          const chan = element / 255;
          lum[i] = chan <= 0.04045 ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;
        }
        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
      },
      contrast(color2) {
        const lum1 = this.luminosity();
        const lum2 = color2.luminosity();
        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05);
        }
        return (lum2 + 0.05) / (lum1 + 0.05);
      },
      level(color2) {
        const contrastRatio = this.contrast(color2);
        if (contrastRatio >= 7) {
          return "AAA";
        }
        return contrastRatio >= 4.5 ? "AA" : "";
      },
      isDark() {
        const rgb = this.rgb().color;
        const yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 1e4;
        return yiq < 128;
      },
      isLight() {
        return !this.isDark();
      },
      negate() {
        const rgb = this.rgb();
        for (let i = 0; i < 3; i++) {
          rgb.color[i] = 255 - rgb.color[i];
        }
        return rgb;
      },
      lighten(ratio) {
        const hsl = this.hsl();
        hsl.color[2] += hsl.color[2] * ratio;
        return hsl;
      },
      darken(ratio) {
        const hsl = this.hsl();
        hsl.color[2] -= hsl.color[2] * ratio;
        return hsl;
      },
      saturate(ratio) {
        const hsl = this.hsl();
        hsl.color[1] += hsl.color[1] * ratio;
        return hsl;
      },
      desaturate(ratio) {
        const hsl = this.hsl();
        hsl.color[1] -= hsl.color[1] * ratio;
        return hsl;
      },
      whiten(ratio) {
        const hwb = this.hwb();
        hwb.color[1] += hwb.color[1] * ratio;
        return hwb;
      },
      blacken(ratio) {
        const hwb = this.hwb();
        hwb.color[2] += hwb.color[2] * ratio;
        return hwb;
      },
      grayscale() {
        const rgb = this.rgb().color;
        const value = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
        return Color.rgb(value, value, value);
      },
      fade(ratio) {
        return this.alpha(this.valpha - this.valpha * ratio);
      },
      opaquer(ratio) {
        return this.alpha(this.valpha + this.valpha * ratio);
      },
      rotate(degrees) {
        const hsl = this.hsl();
        let hue = hsl.color[0];
        hue = (hue + degrees) % 360;
        hue = hue < 0 ? 360 + hue : hue;
        hsl.color[0] = hue;
        return hsl;
      },
      mix(mixinColor, weight) {
        if (!mixinColor || !mixinColor.rgb) {
          throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
        }
        const color1 = mixinColor.rgb();
        const color2 = this.rgb();
        const p = weight === void 0 ? 0.5 : weight;
        const w = 2 * p - 1;
        const a = color1.alpha() - color2.alpha();
        const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
        const w2 = 1 - w1;
        return Color.rgb(
          w1 * color1.red() + w2 * color2.red(),
          w1 * color1.green() + w2 * color2.green(),
          w1 * color1.blue() + w2 * color2.blue(),
          color1.alpha() * p + color2.alpha() * (1 - p)
        );
      }
    };
    for (const model of Object.keys(convert)) {
      if (skippedModels.includes(model)) {
        continue;
      }
      const { channels } = convert[model];
      Color.prototype[model] = function(...args) {
        if (this.model === model) {
          return new Color(this);
        }
        if (args.length > 0) {
          return new Color(args, model);
        }
        return new Color([...assertArray(convert[this.model][model].raw(this.color)), this.valpha], model);
      };
      Color[model] = function(...args) {
        let color = args[0];
        if (typeof color === "number") {
          color = zeroArray(args, channels);
        }
        return new Color(color, model);
      };
    }
    function roundTo(number, places) {
      return Number(number.toFixed(places));
    }
    function roundToPlace(places) {
      return function(number) {
        return roundTo(number, places);
      };
    }
    function getset(model, channel, modifier) {
      model = Array.isArray(model) ? model : [model];
      for (const m of model) {
        (limiters[m] || (limiters[m] = []))[channel] = modifier;
      }
      model = model[0];
      return function(value) {
        let result;
        if (value !== void 0) {
          if (modifier) {
            value = modifier(value);
          }
          result = this[model]();
          result.color[channel] = value;
          return result;
        }
        result = this[model]().color[channel];
        if (modifier) {
          result = modifier(result);
        }
        return result;
      };
    }
    function maxfn(max) {
      return function(v) {
        return Math.max(0, Math.min(max, v));
      };
    }
    function assertArray(value) {
      return Array.isArray(value) ? value : [value];
    }
    function zeroArray(array, length) {
      for (let i = 0; i < length; i++) {
        if (typeof array[i] !== "number") {
          array[i] = 0;
        }
      }
      return array;
    }
    module2.exports = Color;
  }
});

// supernote-typescript/lib/conversion.js
var require_conversion = __commonJS({
  "supernote-typescript/lib/conversion.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RattaRLEDecoder = exports2.toImage = void 0;
    var image_js_1 = require_lib20();
    var color_1 = __importDefault(require_color2());
    function concatUint8Arrays(chunks) {
      let totalLength = 0;
      for (const chunk of chunks) {
        totalLength += chunk.length;
      }
      const concatenatedArray = new Uint8Array(totalLength);
      let offset = 0;
      for (const chunk of chunks) {
        concatenatedArray.set(chunk, offset);
        offset += chunk.length;
      }
      return concatenatedArray;
    }
    function compositeImages(sourceImage, destinationImage) {
      return __awaiter(this, void 0, void 0, function* () {
        if (sourceImage.width !== destinationImage.width || sourceImage.height !== destinationImage.height) {
          throw new Error("Images must have the same dimensions for compositing.");
        }
        for (let y = 0; y < destinationImage.height; y++) {
          for (let x = 0; x < destinationImage.width; x++) {
            const sourcePixel = sourceImage.getPixelXY(x, y);
            const destinationPixel = destinationImage.getPixelXY(x, y);
            const blendedPixel = blendPixelOverlay(sourcePixel, destinationPixel);
            destinationImage.setPixelXY(x, y, blendedPixel);
          }
        }
      });
    }
    function blendPixelOverlay(sourcePixel, destinationPixel) {
      const [sourceA, sourceR, sourceG, sourceB] = sourcePixel;
      const [destinationA, destinationR, destinationG, destinationB] = destinationPixel;
      if (sourceR === 0 && sourceG === 0 && sourceB === 0 && sourceA == 0) {
        return [destinationA, destinationR, destinationG, destinationB];
      }
      return sourcePixel;
    }
    function toImage2(note, pageNumbers) {
      const pages = pageNumbers ? pageNumbers.map((n) => note.pages[n - 1]) : note.pages;
      const decoder = new RattaRLEDecoder();
      return Promise.all(pages.map((page, pageIndex) => __awaiter(this, void 0, void 0, function* () {
        const overlays = page.LAYERSEQ.map((name) => page[name]).filter((layer) => layer.bitmapBuffer !== null && layer.bitmapBuffer.length);
        const promises = overlays.map((layer) => __awaiter(this, void 0, void 0, function* () {
          let buffer = null;
          if (layer.LAYERNAME == "BGLAYER" && page.PAGESTYLE.startsWith("user_")) {
            return yield image_js_1.Image.load(layer.bitmapBuffer);
          }
          buffer = decoder.decode(layer.bitmapBuffer, note.pageWidth, note.pageHeight);
          return new image_js_1.Image(note.pageWidth, note.pageHeight, buffer, {
            components: 3,
            alpha: 1
          });
        }));
        let images = yield Promise.all(promises);
        images = images.reverse();
        let output = images[0].clone();
        for (let i = 1; i < overlays.length; i++) {
          compositeImages(images[i], output);
        }
        return output.grey({ keepAlpha: true });
      })));
    }
    exports2.toImage = toImage2;
    var defaultPalette = {
      background: (0, color_1.default)("transparent"),
      black: (0, color_1.default)("black"),
      darkGray: (0, color_1.default)("darkgray"),
      gray: (0, color_1.default)("gray"),
      white: (0, color_1.default)("white"),
      markerBlack: (0, color_1.default)("black"),
      markerDarkGray: (0, color_1.default)("darkgray"),
      markerGray: (0, color_1.default)("gray"),
      darkGrayX2: (0, color_1.default)("darkgray"),
      grayX2: (0, color_1.default)("gray"),
      markerDarkGrayX2: (0, color_1.default)("darkgray"),
      markerGrayX2: (0, color_1.default)("gray")
    };
    var RattaRLEDecoder = class {
      constructor() {
        this.encodedPalette = {
          black: 97,
          background: 98,
          darkGray: 99,
          gray: 100,
          white: 101,
          markerBlack: 102,
          markerDarkGray: 103,
          markerGray: 104,
          darkGrayX2: 157,
          grayX2: 201,
          markerDarkGrayX2: 158,
          markerGrayX2: 202
        };
        this.specialLengthMarker = 255;
        this.specialLength = 16384;
        this.specialLengthForBlank = 1024;
      }
      /**
       * @param buffer Input buffer following Ratta RLE protocol.
       * @param width Page width.
       * @param height Page height.
       * @param palette Optionally custom palette.
       * @param allBlank Blank toggle.
       * @returns Decoded buffer.
       * Adopted from https://github.com/jya-dev/supernote-tool.
       */
      decode(buffer, width, height, palette, allBlank = false) {
        const pal = palette !== null && palette !== void 0 ? palette : defaultPalette;
        const translation = Object.entries(this.encodedPalette).reduce((acc, [key, value]) => {
          var _a;
          acc[value] = (_a = pal[key]) !== null && _a !== void 0 ? _a : defaultPalette[key];
          return acc;
        }, {});
        const expectedLength = width * height * 4;
        const chunks = [];
        let waiting = [];
        let holder = null;
        let [color, length] = [0, 0];
        for (let index = 1; index < buffer.length; index += 2) {
          color = buffer.at(index - 1);
          length = buffer.at(index);
          let pushed = false;
          if (holder !== null) {
            let [prevColor, prevLength] = holder;
            holder = null;
            if (color === prevColor) {
              length = 1 + length + ((prevLength & 127) + 1 << 7);
              waiting.push([color, length]);
              pushed = true;
            } else {
              prevLength = (prevLength & 127) + 1 << 7;
              waiting.push([prevColor, prevLength]);
            }
          }
          if (!pushed) {
            if (length === this.specialLengthMarker) {
              if (allBlank)
                length = this.specialLengthForBlank;
              else
                length = this.specialLength;
              waiting.push([color, length]);
              pushed = true;
            } else if ((length & 128) !== 0) {
              holder = [color, length];
            } else {
              length += 1;
              waiting.push([color, length]);
              pushed = true;
            }
          }
          for (const [color2, length2] of waiting.values()) {
            this.addColorBuffer(chunks, color2, length2, translation);
          }
          waiting = [];
        }
        if (holder !== null) {
          [color, length] = holder;
          length = this.adjustTailLength(length, this.getChunksLength(chunks), expectedLength);
          if (length > 0) {
            this.addColorBuffer(chunks, color, length, translation);
          }
        }
        let result = concatUint8Arrays(chunks);
        if (result.length !== expectedLength)
          throw new Error(`Uint8Array length ${result.length} doesn't match expected length ${expectedLength}.`);
        return result;
      }
      addColorBuffer(chunks, encodedColor, length, translation) {
        let newColor = encodedColor === -1 ? (0, color_1.default)("transparent") : translation[encodedColor];
        let chunk;
        if (newColor === void 0) {
          throw Error(`unknown color 0x${encodedColor.toString(16)}`);
        }
        if (newColor.alpha() === 0) {
          chunk = Uint8Array.from(new Uint8Array([0, 0, 0, 0]));
        } else {
          chunk = Uint8Array.from(new Uint8Array([...newColor.rgb().array(), ~~(255 * newColor.alpha())]));
        }
        for (let index = 0; index < length; index++) {
          chunks.push(chunk);
        }
        return chunks;
      }
      adjustTailLength(tailLength, uncompressedLength, expectedLength) {
        const gap = expectedLength - uncompressedLength;
        let length;
        for (let i = 7; i >= 0; i--) {
          length = (tailLength & 127) + 1 << i;
          if (length <= gap) {
            return length;
          }
        }
        return 0;
      }
      getChunksLength(chunks) {
        return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
      }
    };
    exports2.RattaRLEDecoder = RattaRLEDecoder;
  }
});

// supernote-typescript/lib/mirror.js
var require_mirror = __commonJS({
  "supernote-typescript/lib/mirror.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fetchMirrorFrame = void 0;
    var image_js_1 = require_lib20();
    function fetchMirrorFrame2(ipAddress) {
      var _a;
      return __awaiter(this, void 0, void 0, function* () {
        const url = `http://${ipAddress}/screencast.mjpeg`;
        const controller = new AbortController();
        const response = yield fetch(url, {
          method: "GET",
          signal: controller.signal
        });
        if (!response.ok) {
          throw new Error("Failed to fetch the resource.");
        }
        const contentType = response.headers.get("content-type");
        if (!contentType || !contentType.includes("multipart")) {
          throw new Error("Invalid response. Expected multipart content type.");
        }
        const reader = (_a = response.body) === null || _a === void 0 ? void 0 : _a.getReader();
        if (!reader) {
          throw new Error("Failed to get reader for response body.");
        }
        let boundary = contentType.split("boundary=")[1];
        if (!boundary) {
          throw new Error("Boundary not found in response headers.");
        }
        let currentPartHeaders = [];
        let buffer = new Uint8Array();
        return new Promise((resolve2, reject2) => {
          let found = false;
          const headerEnd = "\r\n\r\n";
          const processChunk = (chunk) => __awaiter(this, void 0, void 0, function* () {
            buffer = concatUint8Arrays(buffer, chunk);
            let start = new TextDecoder().decode(buffer).indexOf("Content-Type:", 0);
            let end = findBoundary(buffer, boundary, start + 2);
            const part = buffer.slice(start, end);
            const headerEndIndex = new TextDecoder().decode(part).indexOf(headerEnd);
            if (currentPartHeaders.length === 0) {
              if (headerEndIndex !== -1) {
                const headerStr = new TextDecoder().decode(part.slice(0, headerEndIndex));
                currentPartHeaders = headerStr.split("\r\n");
              }
            }
            const contentTypeHeader = currentPartHeaders.find((header) => header.toLowerCase().startsWith("content-type:"));
            const contentLengthHeader = currentPartHeaders.find((header) => header.toLowerCase().startsWith("content-length:"));
            if (contentTypeHeader && contentTypeHeader.includes("image/jpeg")) {
              if (contentLengthHeader) {
                found = true;
                const contentLength = parseInt(contentLengthHeader.split(":")[1].trim());
                if (buffer.length < headerEndIndex + contentLength + 1) {
                  return;
                }
                const imageData = buffer.slice(headerEndIndex + headerEnd.length, headerEndIndex + contentLength + 1);
                const image = image_js_1.Image.load(imageData);
                resolve2(image);
                controller.abort();
              }
            }
          });
          const read = () => __awaiter(this, void 0, void 0, function* () {
            const { done, value } = yield reader.read();
            const txt = new TextDecoder().decode(value);
            if (done) {
              if (!found) {
                reject2(new Error("No JPEG image found in multipart stream."));
              }
              return;
            }
            yield processChunk(value);
            yield read();
          });
          read().catch((error) => reject2(error));
        });
      });
    }
    exports2.fetchMirrorFrame = fetchMirrorFrame2;
    function findBoundary(data, boundary, startIndex = 0) {
      const boundaryStr = `${boundary}`;
      return new TextDecoder().decode(data).indexOf(boundaryStr);
    }
    function concatUint8Arrays(a, b) {
      const result = new Uint8Array(a.length + b.length);
      result.set(a, 0);
      result.set(b, a.length);
      return result;
    }
  }
});

// supernote-typescript/lib/index.js
var require_lib21 = __commonJS({
  "supernote-typescript/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fetchMirrorFrame = exports2.toImage = exports2.SupernoteX = void 0;
    var parsing_1 = require_parsing();
    Object.defineProperty(exports2, "SupernoteX", { enumerable: true, get: function() {
      return parsing_1.SupernoteX;
    } });
    var conversion_1 = require_conversion();
    Object.defineProperty(exports2, "toImage", { enumerable: true, get: function() {
      return conversion_1.toImage;
    } });
    var mirror_1 = require_mirror();
    Object.defineProperty(exports2, "fetchMirrorFrame", { enumerable: true, get: function() {
      return mirror_1.fetchMirrorFrame;
    } });
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  SupernoteView: () => SupernoteView,
  VIEW_TYPE_SUPERNOTE: () => VIEW_TYPE_SUPERNOTE,
  default: () => SupernotePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_supernote_typescript = __toESM(require_lib21());
var DEFAULT_SETTINGS = {
  mirrorIP: "",
  invertColorsWhenDark: true,
  showTOC: true,
  showExportButtons: true,
  collapseRecognizedText: false
};
function generateTimestamp() {
  const date = new Date();
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  const day = String(date.getDate()).padStart(2, "0");
  const hours = String(date.getHours()).padStart(2, "0");
  const minutes = String(date.getMinutes()).padStart(2, "0");
  const seconds = String(date.getSeconds()).padStart(2, "0");
  const timestamp = `${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;
  return timestamp;
}
var VaultWriter = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
  }
  async writeMarkdownFile(file, sn, imgs) {
    var _a, _b;
    let content = "";
    let filename = `${(_a = file.parent) == null ? void 0 : _a.path}/${file.basename}.md`;
    let i = 0;
    while (this.app.vault.getFileByPath(filename) !== null) {
      filename = `${(_b = file.parent) == null ? void 0 : _b.path}/${file.basename} ${++i}.md`;
    }
    content = this.app.fileManager.generateMarkdownLink(file, filename);
    content += "\n";
    for (let i2 = 0; i2 < sn.pages.length; i2++) {
      content += `## Page ${i2 + 1}

`;
      if (sn.pages[i2].text !== void 0 && sn.pages[i2].text.length > 0) {
        content += `${sn.pages[i2].text}
`;
      }
      if (imgs) {
        let subpath = "";
        if (this.settings.invertColorsWhenDark) {
          subpath = "#supernote-invert-dark";
        }
        const link = this.app.fileManager.generateMarkdownLink(imgs[i2], filename, subpath);
        content += `${link}
`;
      }
    }
    this.app.vault.create(filename, content);
  }
  async writeImageFiles(file, sn) {
    let images = await (0, import_supernote_typescript.toImage)(sn);
    let imgs = [];
    for (let i = 0; i < images.length; i++) {
      let filename = await this.app.fileManager.getAvailablePathForAttachment(`${file.basename}-${i}.png`);
      imgs.push(await this.app.vault.createBinary(filename, images[i].toBuffer()));
    }
    return imgs;
  }
  async attachMarkdownFile(file) {
    const note = await this.app.vault.readBinary(file);
    let sn = new import_supernote_typescript.SupernoteX(new Uint8Array(note));
    this.writeMarkdownFile(file, sn, null);
  }
  async attachNoteFiles(file) {
    const note = await this.app.vault.readBinary(file);
    let sn = new import_supernote_typescript.SupernoteX(new Uint8Array(note));
    const imgs = await this.writeImageFiles(file, sn);
    this.writeMarkdownFile(file, sn, imgs);
  }
};
var vw;
var VIEW_TYPE_SUPERNOTE = "supernote-view";
var SupernoteView = class extends import_obsidian.FileView {
  constructor(leaf, settings) {
    super(leaf);
    this.settings = settings;
  }
  getViewType() {
    return VIEW_TYPE_SUPERNOTE;
  }
  getDisplayText() {
    if (!this.file) {
      return "Supernote View";
    }
    return this.file.basename;
  }
  async onLoadFile(file) {
    const container = this.containerEl.children[1];
    container.empty();
    container.createEl("h1", { text: file.name });
    const note = await this.app.vault.readBinary(file);
    let sn = new import_supernote_typescript.SupernoteX(new Uint8Array(note));
    let images = await (0, import_supernote_typescript.toImage)(sn);
    if (this.settings.showExportButtons) {
      const exportNoteBtn = container.createEl("p").createEl("button", {
        text: "Attach markdown to vault",
        cls: "mod-cta"
      });
      exportNoteBtn.addEventListener("click", async () => {
        vw.attachMarkdownFile(file);
      });
      const exportAllBtn = container.createEl("p").createEl("button", {
        text: "Attach markdown and images to vault",
        cls: "mod-cta"
      });
      exportAllBtn.addEventListener("click", async () => {
        vw.attachNoteFiles(file);
      });
    }
    if (images.length > 1 && this.settings.showTOC) {
      const atoc = container.createEl("a");
      atoc.id = "toc";
      atoc.createEl("h2", { text: "Table of contents" });
      const ul = container.createEl("ul");
      for (let i = 0; i < images.length; i++) {
        const a = container.createEl("li").createEl("a");
        a.href = `#page${i + 1}`;
        a.text = `Page ${i + 1}`;
      }
    }
    for (let i = 0; i < images.length; i++) {
      const imageDataUrl = images[i].toDataURL();
      if (images.length > 1 && this.settings.showTOC) {
        const a = container.createEl("a");
        a.id = `page${i + 1}`;
        a.href = "#toc";
        a.createEl("h3", { text: `Page ${i + 1}` });
      }
      if (sn.pages[i].text !== void 0 && sn.pages[i].text.length > 0) {
        let text;
        if (this.settings.collapseRecognizedText) {
          text = container.createEl("details", {
            text: "\n" + sn.pages[i].text
          });
          text.createEl("summary", { text: `Page ${i + 1} Recognized Text` });
        } else {
          text = container.createEl("div", {
            text: sn.pages[i].text
          });
        }
        text.setAttr("style", "user-select: text; white-space: pre-line; margin-top: 1.2em;");
      }
      const imgElement = container.createEl("img");
      imgElement.src = imageDataUrl;
      if (this.settings.invertColorsWhenDark) {
        imgElement.addClass("supernote-invert-dark");
      }
      imgElement.draggable = true;
      if (this.settings.showExportButtons) {
        const saveButton = container.createEl("button", {
          text: "Save image to vault",
          cls: "mod-cta"
        });
        saveButton.addEventListener("click", async () => {
          const filename = await this.app.fileManager.getAvailablePathForAttachment(`${file.basename}}.png`);
          await this.app.vault.createBinary(filename, images[i].toBuffer());
        });
      }
    }
  }
  async onClose() {
  }
};
var SupernotePlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    vw = new VaultWriter(this.app, this.settings);
    this.addSettingTab(new SupernoteSettingTab(this.app, this));
    this.registerView(
      VIEW_TYPE_SUPERNOTE,
      (leaf) => new SupernoteView(leaf, this.settings)
    );
    this.registerExtensions(["note"], VIEW_TYPE_SUPERNOTE);
    this.addCommand({
      id: "insert-supernote-screen-mirror-image",
      name: "Insert a Supernote screen mirroring image as attachment",
      editorCallback: async (editor, view) => {
        var _a, _b, _c, _d;
        let ts = generateTimestamp();
        const f = ((_b = (_a = this.app.workspace.activeEditor) == null ? void 0 : _a.file) == null ? void 0 : _b.basename) || "";
        const filename = await this.app.fileManager.getAvailablePathForAttachment(`supernote-mirror-${f}-${ts}.png`);
        try {
          if (this.settings.mirrorIP.length == 0) {
            throw new Error("IP is unset, please set in Supernote plugin settings");
          }
          let image = await (0, import_supernote_typescript.fetchMirrorFrame)(`${this.settings.mirrorIP}:8080`);
          const file = await this.app.vault.createBinary(filename, image.toBuffer());
          const path = (_d = (_c = this.app.workspace.activeEditor) == null ? void 0 : _c.file) == null ? void 0 : _d.path;
          if (!path) {
            throw new Error("Active file path is null");
          }
          const link = this.app.fileManager.generateMarkdownLink(file, path);
          editor.replaceRange(link, editor.getCursor());
        } catch (err) {
          new MirrorErrorModal(this.app, this.settings, err).open();
        }
      }
    });
    this.addCommand({
      id: "export-supernote-note-as-files",
      name: "Export this Supernote note as a markdown and PNG files as attachments",
      checkCallback: (checking) => {
        const file = this.app.workspace.getActiveFile();
        const ext = file == null ? void 0 : file.extension;
        if (ext === "note") {
          if (checking) {
            return true;
          }
          try {
            if (!file) {
              throw new Error("No file to attach");
            }
            vw.attachNoteFiles(file);
          } catch (err) {
            new ErrorModal(this.app, err).open();
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "export-supernote-note-as-markdown",
      name: "Export this Supernote note as a markdown file attachment",
      checkCallback: (checking) => {
        const file = this.app.workspace.getActiveFile();
        const ext = file == null ? void 0 : file.extension;
        if (ext === "note") {
          if (checking) {
            return true;
          }
          try {
            if (!file) {
              throw new Error("No file to attach");
            }
            vw.attachMarkdownFile(file);
          } catch (err) {
            new ErrorModal(this.app, err).open();
          }
          return true;
        }
        return false;
      }
    });
  }
  onunload() {
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_SUPERNOTE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (!leaf) {
        throw new Error("leaf is null");
      }
      await leaf.setViewState({ type: VIEW_TYPE_SUPERNOTE, active: true });
    }
    workspace.revealLeaf(leaf);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var MirrorErrorModal = class extends import_obsidian.Modal {
  constructor(app, settings, error) {
    super(app);
    this.error = error;
    this.settings = settings;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.setText(`Error: ${this.error.message}. Is the Supernote connected to Wifi on IP ${this.settings.mirrorIP} and running Screen Mirroring?`);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ErrorModal = class extends import_obsidian.Modal {
  constructor(app, error) {
    super(app);
    this.error = error;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.setText(`Error: ${this.error.message}.`);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var SupernoteSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName('Supernote IP address for "Screen Mirroring"').setDesc('See Supernote "Screen Mirroring" documentation for how to enable').addText(
      (text) => text.setPlaceholder("IP )e.g. 192.168.1.2").setValue(this.plugin.settings.mirrorIP).onChange(async (value) => {
        this.plugin.settings.mirrorIP = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName('Invert colors in "Dark mode"').setDesc('When Obsidian is in "Dark mode" increase image visibility by inverting colors of images').addToggle(
      (text) => text.setValue(this.plugin.settings.invertColorsWhenDark).onChange(async (value) => {
        this.plugin.settings.invertColorsWhenDark = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show table of contents and page headings").setDesc(
      "When viewing .note files, show a table of contents and page number headings"
    ).addToggle(
      (text) => text.setValue(this.plugin.settings.showTOC).onChange(async (value) => {
        this.plugin.settings.showTOC = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show export buttons").setDesc(
      "When viewing .note files, show buttons for exporting images and/or markdown files to vault. These features can still be accessed via the command pallete."
    ).addToggle(
      (text) => text.setValue(this.plugin.settings.showExportButtons).onChange(async (value) => {
        this.plugin.settings.showExportButtons = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Collapse recognized text").setDesc("When viewing .note files, hide recognized text in a collapsible element. This does not affect exported markdown.").addToggle(
      (text) => text.setValue(this.plugin.settings.collapseRecognizedText).onChange(async (value) => {
        this.plugin.settings.collapseRecognizedText = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

/* nosourcemap */